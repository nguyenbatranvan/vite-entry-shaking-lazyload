"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/esbuild/lib/main.js
var require_main = __commonJS({
  "node_modules/esbuild/lib/main.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name2 in all)
        __defProp2(target, name2, { get: all[name2], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var node_exports = {};
    __export2(node_exports, {
      analyzeMetafile: () => analyzeMetafile,
      analyzeMetafileSync: () => analyzeMetafileSync,
      build: () => build2,
      buildSync: () => buildSync,
      context: () => context,
      default: () => node_default,
      formatMessages: () => formatMessages2,
      formatMessagesSync: () => formatMessagesSync,
      initialize: () => initialize,
      transform: () => transform2,
      transformSync: () => transformSync,
      version: () => version5
    });
    module2.exports = __toCommonJS2(node_exports);
    function encodePacket(packet) {
      let visit2 = (value2) => {
        if (value2 === null) {
          bb.write8(0);
        } else if (typeof value2 === "boolean") {
          bb.write8(1);
          bb.write8(+value2);
        } else if (typeof value2 === "number") {
          bb.write8(2);
          bb.write32(value2 | 0);
        } else if (typeof value2 === "string") {
          bb.write8(3);
          bb.write(encodeUTF8(value2));
        } else if (value2 instanceof Uint8Array) {
          bb.write8(4);
          bb.write(value2);
        } else if (value2 instanceof Array) {
          bb.write8(5);
          bb.write32(value2.length);
          for (let item of value2) {
            visit2(item);
          }
        } else {
          let keys2 = Object.keys(value2);
          bb.write8(6);
          bb.write32(keys2.length);
          for (let key of keys2) {
            bb.write(encodeUTF8(key));
            visit2(value2[key]);
          }
        }
      };
      let bb = new ByteBuffer();
      bb.write32(0);
      bb.write32(packet.id << 1 | +!packet.isRequest);
      visit2(packet.value);
      writeUInt32LE(bb.buf, bb.len - 4, 0);
      return bb.buf.subarray(0, bb.len);
    }
    function decodePacket(bytes) {
      let visit2 = () => {
        switch (bb.read8()) {
          case 0:
            return null;
          case 1:
            return !!bb.read8();
          case 2:
            return bb.read32();
          case 3:
            return decodeUTF8(bb.read());
          case 4:
            return bb.read();
          case 5: {
            let count = bb.read32();
            let value22 = [];
            for (let i = 0; i < count; i++) {
              value22.push(visit2());
            }
            return value22;
          }
          case 6: {
            let count = bb.read32();
            let value22 = {};
            for (let i = 0; i < count; i++) {
              value22[decodeUTF8(bb.read())] = visit2();
            }
            return value22;
          }
          default:
            throw new Error("Invalid packet");
        }
      };
      let bb = new ByteBuffer(bytes);
      let id = bb.read32();
      let isRequest = (id & 1) === 0;
      id >>>= 1;
      let value2 = visit2();
      if (bb.ptr !== bytes.length) {
        throw new Error("Invalid packet");
      }
      return { id, isRequest, value: value2 };
    }
    var ByteBuffer = class {
      constructor(buf = new Uint8Array(1024)) {
        this.buf = buf;
        this.len = 0;
        this.ptr = 0;
      }
      _write(delta) {
        if (this.len + delta > this.buf.length) {
          let clone = new Uint8Array((this.len + delta) * 2);
          clone.set(this.buf);
          this.buf = clone;
        }
        this.len += delta;
        return this.len - delta;
      }
      write8(value2) {
        let offset4 = this._write(1);
        this.buf[offset4] = value2;
      }
      write32(value2) {
        let offset4 = this._write(4);
        writeUInt32LE(this.buf, value2, offset4);
      }
      write(bytes) {
        let offset4 = this._write(4 + bytes.length);
        writeUInt32LE(this.buf, bytes.length, offset4);
        this.buf.set(bytes, offset4 + 4);
      }
      _read(delta) {
        if (this.ptr + delta > this.buf.length) {
          throw new Error("Invalid packet");
        }
        this.ptr += delta;
        return this.ptr - delta;
      }
      read8() {
        return this.buf[this._read(1)];
      }
      read32() {
        return readUInt32LE(this.buf, this._read(4));
      }
      read() {
        let length = this.read32();
        let bytes = new Uint8Array(length);
        let ptr = this._read(bytes.length);
        bytes.set(this.buf.subarray(ptr, ptr + length));
        return bytes;
      }
    };
    var encodeUTF8;
    var decodeUTF8;
    var encodeInvariant;
    if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
      let encoder = new TextEncoder();
      let decoder = new TextDecoder();
      encodeUTF8 = (text) => encoder.encode(text);
      decodeUTF8 = (bytes) => decoder.decode(bytes);
      encodeInvariant = 'new TextEncoder().encode("")';
    } else if (typeof Buffer !== "undefined") {
      encodeUTF8 = (text) => Buffer.from(text);
      decodeUTF8 = (bytes) => {
        let { buffer, byteOffset, byteLength } = bytes;
        return Buffer.from(buffer, byteOffset, byteLength).toString();
      };
      encodeInvariant = 'Buffer.from("")';
    } else {
      throw new Error("No UTF-8 codec found");
    }
    if (!(encodeUTF8("") instanceof Uint8Array))
      throw new Error(`Invariant violation: "${encodeInvariant} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);
    function readUInt32LE(buffer, offset4) {
      return buffer[offset4++] | buffer[offset4++] << 8 | buffer[offset4++] << 16 | buffer[offset4++] << 24;
    }
    function writeUInt32LE(buffer, value2, offset4) {
      buffer[offset4++] = value2;
      buffer[offset4++] = value2 >> 8;
      buffer[offset4++] = value2 >> 16;
      buffer[offset4++] = value2 >> 24;
    }
    var quote = JSON.stringify;
    var buildLogLevelDefault = "warning";
    var transformLogLevelDefault = "silent";
    function validateTarget(target) {
      validateStringValue(target, "target");
      if (target.indexOf(",") >= 0)
        throw new Error(`Invalid target: ${target}`);
      return target;
    }
    var canBeAnything = () => null;
    var mustBeBoolean = (value2) => typeof value2 === "boolean" ? null : "a boolean";
    var mustBeString = (value2) => typeof value2 === "string" ? null : "a string";
    var mustBeRegExp = (value2) => value2 instanceof RegExp ? null : "a RegExp object";
    var mustBeInteger = (value2) => typeof value2 === "number" && value2 === (value2 | 0) ? null : "an integer";
    var mustBeFunction = (value2) => typeof value2 === "function" ? null : "a function";
    var mustBeArray = (value2) => Array.isArray(value2) ? null : "an array";
    var mustBeObject = (value2) => typeof value2 === "object" && value2 !== null && !Array.isArray(value2) ? null : "an object";
    var mustBeEntryPoints = (value2) => typeof value2 === "object" && value2 !== null ? null : "an array or an object";
    var mustBeWebAssemblyModule = (value2) => value2 instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
    var mustBeObjectOrNull = (value2) => typeof value2 === "object" && !Array.isArray(value2) ? null : "an object or null";
    var mustBeStringOrBoolean = (value2) => typeof value2 === "string" || typeof value2 === "boolean" ? null : "a string or a boolean";
    var mustBeStringOrObject = (value2) => typeof value2 === "string" || typeof value2 === "object" && value2 !== null && !Array.isArray(value2) ? null : "a string or an object";
    var mustBeStringOrArray = (value2) => typeof value2 === "string" || Array.isArray(value2) ? null : "a string or an array";
    var mustBeStringOrUint8Array = (value2) => typeof value2 === "string" || value2 instanceof Uint8Array ? null : "a string or a Uint8Array";
    var mustBeStringOrURL = (value2) => typeof value2 === "string" || value2 instanceof URL ? null : "a string or a URL";
    function getFlag(object, keys2, key, mustBeFn) {
      let value2 = object[key];
      keys2[key + ""] = true;
      if (value2 === void 0)
        return void 0;
      let mustBe = mustBeFn(value2);
      if (mustBe !== null)
        throw new Error(`${quote(key)} must be ${mustBe}`);
      return value2;
    }
    function checkForInvalidFlags(object, keys2, where) {
      for (let key in object) {
        if (!(key in keys2)) {
          throw new Error(`Invalid option ${where}: ${quote(key)}`);
        }
      }
    }
    function validateInitializeOptions(options2) {
      let keys2 = /* @__PURE__ */ Object.create(null);
      let wasmURL = getFlag(options2, keys2, "wasmURL", mustBeStringOrURL);
      let wasmModule = getFlag(options2, keys2, "wasmModule", mustBeWebAssemblyModule);
      let worker = getFlag(options2, keys2, "worker", mustBeBoolean);
      checkForInvalidFlags(options2, keys2, "in initialize() call");
      return {
        wasmURL,
        wasmModule,
        worker
      };
    }
    function validateMangleCache(mangleCache) {
      let validated;
      if (mangleCache !== void 0) {
        validated = /* @__PURE__ */ Object.create(null);
        for (let key in mangleCache) {
          let value2 = mangleCache[key];
          if (typeof value2 === "string" || value2 === false) {
            validated[key] = value2;
          } else {
            throw new Error(`Expected ${quote(key)} in mangle cache to map to either a string or false`);
          }
        }
      }
      return validated;
    }
    function pushLogFlags(flags, options2, keys2, isTTY2, logLevelDefault) {
      let color = getFlag(options2, keys2, "color", mustBeBoolean);
      let logLevel = getFlag(options2, keys2, "logLevel", mustBeString);
      let logLimit = getFlag(options2, keys2, "logLimit", mustBeInteger);
      if (color !== void 0)
        flags.push(`--color=${color}`);
      else if (isTTY2)
        flags.push(`--color=true`);
      flags.push(`--log-level=${logLevel || logLevelDefault}`);
      flags.push(`--log-limit=${logLimit || 0}`);
    }
    function validateStringValue(value2, what, key) {
      if (typeof value2 !== "string") {
        throw new Error(`Expected value for ${what}${key !== void 0 ? " " + quote(key) : ""} to be a string, got ${typeof value2} instead`);
      }
      return value2;
    }
    function pushCommonFlags(flags, options2, keys2) {
      let legalComments = getFlag(options2, keys2, "legalComments", mustBeString);
      let sourceRoot = getFlag(options2, keys2, "sourceRoot", mustBeString);
      let sourcesContent = getFlag(options2, keys2, "sourcesContent", mustBeBoolean);
      let target = getFlag(options2, keys2, "target", mustBeStringOrArray);
      let format2 = getFlag(options2, keys2, "format", mustBeString);
      let globalName = getFlag(options2, keys2, "globalName", mustBeString);
      let mangleProps = getFlag(options2, keys2, "mangleProps", mustBeRegExp);
      let reserveProps = getFlag(options2, keys2, "reserveProps", mustBeRegExp);
      let mangleQuoted = getFlag(options2, keys2, "mangleQuoted", mustBeBoolean);
      let minify = getFlag(options2, keys2, "minify", mustBeBoolean);
      let minifySyntax = getFlag(options2, keys2, "minifySyntax", mustBeBoolean);
      let minifyWhitespace = getFlag(options2, keys2, "minifyWhitespace", mustBeBoolean);
      let minifyIdentifiers = getFlag(options2, keys2, "minifyIdentifiers", mustBeBoolean);
      let drop = getFlag(options2, keys2, "drop", mustBeArray);
      let charset = getFlag(options2, keys2, "charset", mustBeString);
      let treeShaking = getFlag(options2, keys2, "treeShaking", mustBeBoolean);
      let ignoreAnnotations = getFlag(options2, keys2, "ignoreAnnotations", mustBeBoolean);
      let jsx = getFlag(options2, keys2, "jsx", mustBeString);
      let jsxFactory = getFlag(options2, keys2, "jsxFactory", mustBeString);
      let jsxFragment = getFlag(options2, keys2, "jsxFragment", mustBeString);
      let jsxImportSource = getFlag(options2, keys2, "jsxImportSource", mustBeString);
      let jsxDev = getFlag(options2, keys2, "jsxDev", mustBeBoolean);
      let jsxSideEffects = getFlag(options2, keys2, "jsxSideEffects", mustBeBoolean);
      let define = getFlag(options2, keys2, "define", mustBeObject);
      let logOverride = getFlag(options2, keys2, "logOverride", mustBeObject);
      let supported = getFlag(options2, keys2, "supported", mustBeObject);
      let pure = getFlag(options2, keys2, "pure", mustBeArray);
      let keepNames = getFlag(options2, keys2, "keepNames", mustBeBoolean);
      let platform3 = getFlag(options2, keys2, "platform", mustBeString);
      if (legalComments)
        flags.push(`--legal-comments=${legalComments}`);
      if (sourceRoot !== void 0)
        flags.push(`--source-root=${sourceRoot}`);
      if (sourcesContent !== void 0)
        flags.push(`--sources-content=${sourcesContent}`);
      if (target) {
        if (Array.isArray(target))
          flags.push(`--target=${Array.from(target).map(validateTarget).join(",")}`);
        else
          flags.push(`--target=${validateTarget(target)}`);
      }
      if (format2)
        flags.push(`--format=${format2}`);
      if (globalName)
        flags.push(`--global-name=${globalName}`);
      if (platform3)
        flags.push(`--platform=${platform3}`);
      if (minify)
        flags.push("--minify");
      if (minifySyntax)
        flags.push("--minify-syntax");
      if (minifyWhitespace)
        flags.push("--minify-whitespace");
      if (minifyIdentifiers)
        flags.push("--minify-identifiers");
      if (charset)
        flags.push(`--charset=${charset}`);
      if (treeShaking !== void 0)
        flags.push(`--tree-shaking=${treeShaking}`);
      if (ignoreAnnotations)
        flags.push(`--ignore-annotations`);
      if (drop)
        for (let what of drop)
          flags.push(`--drop:${validateStringValue(what, "drop")}`);
      if (mangleProps)
        flags.push(`--mangle-props=${mangleProps.source}`);
      if (reserveProps)
        flags.push(`--reserve-props=${reserveProps.source}`);
      if (mangleQuoted !== void 0)
        flags.push(`--mangle-quoted=${mangleQuoted}`);
      if (jsx)
        flags.push(`--jsx=${jsx}`);
      if (jsxFactory)
        flags.push(`--jsx-factory=${jsxFactory}`);
      if (jsxFragment)
        flags.push(`--jsx-fragment=${jsxFragment}`);
      if (jsxImportSource)
        flags.push(`--jsx-import-source=${jsxImportSource}`);
      if (jsxDev)
        flags.push(`--jsx-dev`);
      if (jsxSideEffects)
        flags.push(`--jsx-side-effects`);
      if (define) {
        for (let key in define) {
          if (key.indexOf("=") >= 0)
            throw new Error(`Invalid define: ${key}`);
          flags.push(`--define:${key}=${validateStringValue(define[key], "define", key)}`);
        }
      }
      if (logOverride) {
        for (let key in logOverride) {
          if (key.indexOf("=") >= 0)
            throw new Error(`Invalid log override: ${key}`);
          flags.push(`--log-override:${key}=${validateStringValue(logOverride[key], "log override", key)}`);
        }
      }
      if (supported) {
        for (let key in supported) {
          if (key.indexOf("=") >= 0)
            throw new Error(`Invalid supported: ${key}`);
          const value2 = supported[key];
          if (typeof value2 !== "boolean")
            throw new Error(`Expected value for supported ${quote(key)} to be a boolean, got ${typeof value2} instead`);
          flags.push(`--supported:${key}=${value2}`);
        }
      }
      if (pure)
        for (let fn of pure)
          flags.push(`--pure:${validateStringValue(fn, "pure")}`);
      if (keepNames)
        flags.push(`--keep-names`);
    }
    function flagsForBuildOptions(callName, options2, isTTY2, logLevelDefault, writeDefault) {
      var _a2;
      let flags = [];
      let entries = [];
      let keys2 = /* @__PURE__ */ Object.create(null);
      let stdinContents = null;
      let stdinResolveDir = null;
      pushLogFlags(flags, options2, keys2, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options2, keys2);
      let sourcemap = getFlag(options2, keys2, "sourcemap", mustBeStringOrBoolean);
      let bundle = getFlag(options2, keys2, "bundle", mustBeBoolean);
      let splitting = getFlag(options2, keys2, "splitting", mustBeBoolean);
      let preserveSymlinks = getFlag(options2, keys2, "preserveSymlinks", mustBeBoolean);
      let metafile = getFlag(options2, keys2, "metafile", mustBeBoolean);
      let outfile = getFlag(options2, keys2, "outfile", mustBeString);
      let outdir = getFlag(options2, keys2, "outdir", mustBeString);
      let outbase = getFlag(options2, keys2, "outbase", mustBeString);
      let tsconfig = getFlag(options2, keys2, "tsconfig", mustBeString);
      let resolveExtensions = getFlag(options2, keys2, "resolveExtensions", mustBeArray);
      let nodePathsInput = getFlag(options2, keys2, "nodePaths", mustBeArray);
      let mainFields = getFlag(options2, keys2, "mainFields", mustBeArray);
      let conditions = getFlag(options2, keys2, "conditions", mustBeArray);
      let external = getFlag(options2, keys2, "external", mustBeArray);
      let packages = getFlag(options2, keys2, "packages", mustBeString);
      let alias = getFlag(options2, keys2, "alias", mustBeObject);
      let loader = getFlag(options2, keys2, "loader", mustBeObject);
      let outExtension = getFlag(options2, keys2, "outExtension", mustBeObject);
      let publicPath = getFlag(options2, keys2, "publicPath", mustBeString);
      let entryNames = getFlag(options2, keys2, "entryNames", mustBeString);
      let chunkNames = getFlag(options2, keys2, "chunkNames", mustBeString);
      let assetNames = getFlag(options2, keys2, "assetNames", mustBeString);
      let inject = getFlag(options2, keys2, "inject", mustBeArray);
      let banner = getFlag(options2, keys2, "banner", mustBeObject);
      let footer = getFlag(options2, keys2, "footer", mustBeObject);
      let entryPoints = getFlag(options2, keys2, "entryPoints", mustBeEntryPoints);
      let absWorkingDir = getFlag(options2, keys2, "absWorkingDir", mustBeString);
      let stdin = getFlag(options2, keys2, "stdin", mustBeObject);
      let write = (_a2 = getFlag(options2, keys2, "write", mustBeBoolean)) != null ? _a2 : writeDefault;
      let allowOverwrite = getFlag(options2, keys2, "allowOverwrite", mustBeBoolean);
      let mangleCache = getFlag(options2, keys2, "mangleCache", mustBeObject);
      keys2.plugins = true;
      checkForInvalidFlags(options2, keys2, `in ${callName}() call`);
      if (sourcemap)
        flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
      if (bundle)
        flags.push("--bundle");
      if (allowOverwrite)
        flags.push("--allow-overwrite");
      if (splitting)
        flags.push("--splitting");
      if (preserveSymlinks)
        flags.push("--preserve-symlinks");
      if (metafile)
        flags.push(`--metafile`);
      if (outfile)
        flags.push(`--outfile=${outfile}`);
      if (outdir)
        flags.push(`--outdir=${outdir}`);
      if (outbase)
        flags.push(`--outbase=${outbase}`);
      if (tsconfig)
        flags.push(`--tsconfig=${tsconfig}`);
      if (packages)
        flags.push(`--packages=${packages}`);
      if (resolveExtensions) {
        let values = [];
        for (let value2 of resolveExtensions) {
          validateStringValue(value2, "resolve extension");
          if (value2.indexOf(",") >= 0)
            throw new Error(`Invalid resolve extension: ${value2}`);
          values.push(value2);
        }
        flags.push(`--resolve-extensions=${values.join(",")}`);
      }
      if (publicPath)
        flags.push(`--public-path=${publicPath}`);
      if (entryNames)
        flags.push(`--entry-names=${entryNames}`);
      if (chunkNames)
        flags.push(`--chunk-names=${chunkNames}`);
      if (assetNames)
        flags.push(`--asset-names=${assetNames}`);
      if (mainFields) {
        let values = [];
        for (let value2 of mainFields) {
          validateStringValue(value2, "main field");
          if (value2.indexOf(",") >= 0)
            throw new Error(`Invalid main field: ${value2}`);
          values.push(value2);
        }
        flags.push(`--main-fields=${values.join(",")}`);
      }
      if (conditions) {
        let values = [];
        for (let value2 of conditions) {
          validateStringValue(value2, "condition");
          if (value2.indexOf(",") >= 0)
            throw new Error(`Invalid condition: ${value2}`);
          values.push(value2);
        }
        flags.push(`--conditions=${values.join(",")}`);
      }
      if (external)
        for (let name2 of external)
          flags.push(`--external:${validateStringValue(name2, "external")}`);
      if (alias) {
        for (let old2 in alias) {
          if (old2.indexOf("=") >= 0)
            throw new Error(`Invalid package name in alias: ${old2}`);
          flags.push(`--alias:${old2}=${validateStringValue(alias[old2], "alias", old2)}`);
        }
      }
      if (banner) {
        for (let type in banner) {
          if (type.indexOf("=") >= 0)
            throw new Error(`Invalid banner file type: ${type}`);
          flags.push(`--banner:${type}=${validateStringValue(banner[type], "banner", type)}`);
        }
      }
      if (footer) {
        for (let type in footer) {
          if (type.indexOf("=") >= 0)
            throw new Error(`Invalid footer file type: ${type}`);
          flags.push(`--footer:${type}=${validateStringValue(footer[type], "footer", type)}`);
        }
      }
      if (inject)
        for (let path32 of inject)
          flags.push(`--inject:${validateStringValue(path32, "inject")}`);
      if (loader) {
        for (let ext2 in loader) {
          if (ext2.indexOf("=") >= 0)
            throw new Error(`Invalid loader extension: ${ext2}`);
          flags.push(`--loader:${ext2}=${validateStringValue(loader[ext2], "loader", ext2)}`);
        }
      }
      if (outExtension) {
        for (let ext2 in outExtension) {
          if (ext2.indexOf("=") >= 0)
            throw new Error(`Invalid out extension: ${ext2}`);
          flags.push(`--out-extension:${ext2}=${validateStringValue(outExtension[ext2], "out extension", ext2)}`);
        }
      }
      if (entryPoints) {
        if (Array.isArray(entryPoints)) {
          for (let i = 0, n2 = entryPoints.length; i < n2; i++) {
            let entryPoint = entryPoints[i];
            if (typeof entryPoint === "object" && entryPoint !== null) {
              let entryPointKeys = /* @__PURE__ */ Object.create(null);
              let input = getFlag(entryPoint, entryPointKeys, "in", mustBeString);
              let output = getFlag(entryPoint, entryPointKeys, "out", mustBeString);
              checkForInvalidFlags(entryPoint, entryPointKeys, "in entry point at index " + i);
              if (input === void 0)
                throw new Error('Missing property "in" for entry point at index ' + i);
              if (output === void 0)
                throw new Error('Missing property "out" for entry point at index ' + i);
              entries.push([output, input]);
            } else {
              entries.push(["", validateStringValue(entryPoint, "entry point at index " + i)]);
            }
          }
        } else {
          for (let key in entryPoints) {
            entries.push([key, validateStringValue(entryPoints[key], "entry point", key)]);
          }
        }
      }
      if (stdin) {
        let stdinKeys = /* @__PURE__ */ Object.create(null);
        let contents = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
        let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
        let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
        let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
        checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
        if (sourcefile)
          flags.push(`--sourcefile=${sourcefile}`);
        if (loader2)
          flags.push(`--loader=${loader2}`);
        if (resolveDir)
          stdinResolveDir = resolveDir;
        if (typeof contents === "string")
          stdinContents = encodeUTF8(contents);
        else if (contents instanceof Uint8Array)
          stdinContents = contents;
      }
      let nodePaths = [];
      if (nodePathsInput) {
        for (let value2 of nodePathsInput) {
          value2 += "";
          nodePaths.push(value2);
        }
      }
      return {
        entries,
        flags,
        write,
        stdinContents,
        stdinResolveDir,
        absWorkingDir,
        nodePaths,
        mangleCache: validateMangleCache(mangleCache)
      };
    }
    function flagsForTransformOptions(callName, options2, isTTY2, logLevelDefault) {
      let flags = [];
      let keys2 = /* @__PURE__ */ Object.create(null);
      pushLogFlags(flags, options2, keys2, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options2, keys2);
      let sourcemap = getFlag(options2, keys2, "sourcemap", mustBeStringOrBoolean);
      let tsconfigRaw = getFlag(options2, keys2, "tsconfigRaw", mustBeStringOrObject);
      let sourcefile = getFlag(options2, keys2, "sourcefile", mustBeString);
      let loader = getFlag(options2, keys2, "loader", mustBeString);
      let banner = getFlag(options2, keys2, "banner", mustBeString);
      let footer = getFlag(options2, keys2, "footer", mustBeString);
      let mangleCache = getFlag(options2, keys2, "mangleCache", mustBeObject);
      checkForInvalidFlags(options2, keys2, `in ${callName}() call`);
      if (sourcemap)
        flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
      if (tsconfigRaw)
        flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
      if (sourcefile)
        flags.push(`--sourcefile=${sourcefile}`);
      if (loader)
        flags.push(`--loader=${loader}`);
      if (banner)
        flags.push(`--banner=${banner}`);
      if (footer)
        flags.push(`--footer=${footer}`);
      return {
        flags,
        mangleCache: validateMangleCache(mangleCache)
      };
    }
    function createChannel(streamIn) {
      const requestCallbacksByKey = {};
      const closeData = { didClose: false, reason: "" };
      let responseCallbacks = {};
      let nextRequestID = 0;
      let nextBuildKey = 0;
      let stdout = new Uint8Array(16 * 1024);
      let stdoutUsed = 0;
      let readFromStdout = (chunk) => {
        let limit = stdoutUsed + chunk.length;
        if (limit > stdout.length) {
          let swap = new Uint8Array(limit * 2);
          swap.set(stdout);
          stdout = swap;
        }
        stdout.set(chunk, stdoutUsed);
        stdoutUsed += chunk.length;
        let offset4 = 0;
        while (offset4 + 4 <= stdoutUsed) {
          let length = readUInt32LE(stdout, offset4);
          if (offset4 + 4 + length > stdoutUsed) {
            break;
          }
          offset4 += 4;
          handleIncomingPacket(stdout.subarray(offset4, offset4 + length));
          offset4 += length;
        }
        if (offset4 > 0) {
          stdout.copyWithin(0, offset4, stdoutUsed);
          stdoutUsed -= offset4;
        }
      };
      let afterClose = (error2) => {
        closeData.didClose = true;
        if (error2)
          closeData.reason = ": " + (error2.message || error2);
        const text = "The service was stopped" + closeData.reason;
        for (let id in responseCallbacks) {
          responseCallbacks[id](text, null);
        }
        responseCallbacks = {};
      };
      let sendRequest = (refs, value2, callback) => {
        if (closeData.didClose)
          return callback("The service is no longer running" + closeData.reason, null);
        let id = nextRequestID++;
        responseCallbacks[id] = (error2, response) => {
          try {
            callback(error2, response);
          } finally {
            if (refs)
              refs.unref();
          }
        };
        if (refs)
          refs.ref();
        streamIn.writeToStdin(encodePacket({ id, isRequest: true, value: value2 }));
      };
      let sendResponse = (id, value2) => {
        if (closeData.didClose)
          throw new Error("The service is no longer running" + closeData.reason);
        streamIn.writeToStdin(encodePacket({ id, isRequest: false, value: value2 }));
      };
      let handleRequest = async (id, request) => {
        try {
          if (request.command === "ping") {
            sendResponse(id, {});
            return;
          }
          if (typeof request.key === "number") {
            const requestCallbacks = requestCallbacksByKey[request.key];
            if (requestCallbacks) {
              const callback = requestCallbacks[request.command];
              if (callback) {
                await callback(id, request);
                return;
              }
            }
          }
          throw new Error(`Invalid command: ` + request.command);
        } catch (e) {
          sendResponse(id, { errors: [extractErrorMessageV8(e, streamIn, null, void 0, "")] });
        }
      };
      let isFirstPacket = true;
      let handleIncomingPacket = (bytes) => {
        if (isFirstPacket) {
          isFirstPacket = false;
          let binaryVersion = String.fromCharCode(...bytes);
          if (binaryVersion !== "0.17.14") {
            throw new Error(`Cannot start service: Host version "${"0.17.14"}" does not match binary version ${quote(binaryVersion)}`);
          }
          return;
        }
        let packet = decodePacket(bytes);
        if (packet.isRequest) {
          handleRequest(packet.id, packet.value);
        } else {
          let callback = responseCallbacks[packet.id];
          delete responseCallbacks[packet.id];
          if (packet.value.error)
            callback(packet.value.error, {});
          else
            callback(null, packet.value);
        }
      };
      let buildOrContext = ({ callName, refs, options: options2, isTTY: isTTY2, defaultWD: defaultWD2, callback }) => {
        let refCount = 0;
        const buildKey = nextBuildKey++;
        const requestCallbacks = {};
        const buildRefs = {
          ref() {
            if (++refCount === 1) {
              if (refs)
                refs.ref();
            }
          },
          unref() {
            if (--refCount === 0) {
              delete requestCallbacksByKey[buildKey];
              if (refs)
                refs.unref();
            }
          }
        };
        requestCallbacksByKey[buildKey] = requestCallbacks;
        buildRefs.ref();
        buildOrContextImpl(
          callName,
          buildKey,
          sendRequest,
          sendResponse,
          buildRefs,
          streamIn,
          requestCallbacks,
          options2,
          isTTY2,
          defaultWD2,
          (err, res) => {
            try {
              callback(err, res);
            } finally {
              buildRefs.unref();
            }
          }
        );
      };
      let transform22 = ({ callName, refs, input, options: options2, isTTY: isTTY2, fs: fs3, callback }) => {
        const details = createObjectStash();
        let start = (inputPath) => {
          try {
            if (typeof input !== "string" && !(input instanceof Uint8Array))
              throw new Error('The input to "transform" must be a string or a Uint8Array');
            let {
              flags,
              mangleCache
            } = flagsForTransformOptions(callName, options2, isTTY2, transformLogLevelDefault);
            let request = {
              command: "transform",
              flags,
              inputFS: inputPath !== null,
              input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === "string" ? encodeUTF8(input) : input
            };
            if (mangleCache)
              request.mangleCache = mangleCache;
            sendRequest(refs, request, (error2, response) => {
              if (error2)
                return callback(new Error(error2), null);
              let errors = replaceDetailsInMessages(response.errors, details);
              let warnings = replaceDetailsInMessages(response.warnings, details);
              let outstanding = 1;
              let next = () => {
                if (--outstanding === 0) {
                  let result = {
                    warnings,
                    code: response.code,
                    map: response.map,
                    mangleCache: void 0,
                    legalComments: void 0
                  };
                  if ("legalComments" in response)
                    result.legalComments = response == null ? void 0 : response.legalComments;
                  if (response.mangleCache)
                    result.mangleCache = response == null ? void 0 : response.mangleCache;
                  callback(null, result);
                }
              };
              if (errors.length > 0)
                return callback(failureErrorWithLog("Transform failed", errors, warnings), null);
              if (response.codeFS) {
                outstanding++;
                fs3.readFile(response.code, (err, contents) => {
                  if (err !== null) {
                    callback(err, null);
                  } else {
                    response.code = contents;
                    next();
                  }
                });
              }
              if (response.mapFS) {
                outstanding++;
                fs3.readFile(response.map, (err, contents) => {
                  if (err !== null) {
                    callback(err, null);
                  } else {
                    response.map = contents;
                    next();
                  }
                });
              }
              next();
            });
          } catch (e) {
            let flags = [];
            try {
              pushLogFlags(flags, options2, {}, isTTY2, transformLogLevelDefault);
            } catch {
            }
            const error2 = extractErrorMessageV8(e, streamIn, details, void 0, "");
            sendRequest(refs, { command: "error", flags, error: error2 }, () => {
              error2.detail = details.load(error2.detail);
              callback(failureErrorWithLog("Transform failed", [error2], []), null);
            });
          }
        };
        if ((typeof input === "string" || input instanceof Uint8Array) && input.length > 1024 * 1024) {
          let next = start;
          start = () => fs3.writeFile(input, next);
        }
        start(null);
      };
      let formatMessages22 = ({ callName, refs, messages: messages2, options: options2, callback }) => {
        let result = sanitizeMessages(messages2, "messages", null, "");
        if (!options2)
          throw new Error(`Missing second argument in ${callName}() call`);
        let keys2 = {};
        let kind = getFlag(options2, keys2, "kind", mustBeString);
        let color = getFlag(options2, keys2, "color", mustBeBoolean);
        let terminalWidth = getFlag(options2, keys2, "terminalWidth", mustBeInteger);
        checkForInvalidFlags(options2, keys2, `in ${callName}() call`);
        if (kind === void 0)
          throw new Error(`Missing "kind" in ${callName}() call`);
        if (kind !== "error" && kind !== "warning")
          throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
        let request = {
          command: "format-msgs",
          messages: result,
          isWarning: kind === "warning"
        };
        if (color !== void 0)
          request.color = color;
        if (terminalWidth !== void 0)
          request.terminalWidth = terminalWidth;
        sendRequest(refs, request, (error2, response) => {
          if (error2)
            return callback(new Error(error2), null);
          callback(null, response.messages);
        });
      };
      let analyzeMetafile2 = ({ callName, refs, metafile, options: options2, callback }) => {
        if (options2 === void 0)
          options2 = {};
        let keys2 = {};
        let color = getFlag(options2, keys2, "color", mustBeBoolean);
        let verbose = getFlag(options2, keys2, "verbose", mustBeBoolean);
        checkForInvalidFlags(options2, keys2, `in ${callName}() call`);
        let request = {
          command: "analyze-metafile",
          metafile
        };
        if (color !== void 0)
          request.color = color;
        if (verbose !== void 0)
          request.verbose = verbose;
        sendRequest(refs, request, (error2, response) => {
          if (error2)
            return callback(new Error(error2), null);
          callback(null, response.result);
        });
      };
      return {
        readFromStdout,
        afterClose,
        service: {
          buildOrContext,
          transform: transform22,
          formatMessages: formatMessages22,
          analyzeMetafile: analyzeMetafile2
        }
      };
    }
    function buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options2, isTTY2, defaultWD2, callback) {
      const details = createObjectStash();
      const isContext = callName === "context";
      const handleError = (e, pluginName) => {
        const flags = [];
        try {
          pushLogFlags(flags, options2, {}, isTTY2, buildLogLevelDefault);
        } catch {
        }
        const message = extractErrorMessageV8(e, streamIn, details, void 0, pluginName);
        sendRequest(refs, { command: "error", flags, error: message }, () => {
          message.detail = details.load(message.detail);
          callback(failureErrorWithLog(isContext ? "Context failed" : "Build failed", [message], []), null);
        });
      };
      let plugins2;
      if (typeof options2 === "object") {
        const value2 = options2.plugins;
        if (value2 !== void 0) {
          if (!Array.isArray(value2))
            return handleError(new Error(`"plugins" must be an array`), "");
          plugins2 = value2;
        }
      }
      if (plugins2 && plugins2.length > 0) {
        if (streamIn.isSync)
          return handleError(new Error("Cannot use plugins in synchronous API calls"), "");
        handlePlugins(
          buildKey,
          sendRequest,
          sendResponse,
          refs,
          streamIn,
          requestCallbacks,
          options2,
          plugins2,
          details
        ).then(
          (result) => {
            if (!result.ok)
              return handleError(result.error, result.pluginName);
            try {
              buildOrContextContinue(result.requestPlugins, result.runOnEndCallbacks, result.scheduleOnDisposeCallbacks);
            } catch (e) {
              handleError(e, "");
            }
          },
          (e) => handleError(e, "")
        );
        return;
      }
      try {
        buildOrContextContinue(null, (result, done) => done([], []), () => {
        });
      } catch (e) {
        handleError(e, "");
      }
      function buildOrContextContinue(requestPlugins, runOnEndCallbacks, scheduleOnDisposeCallbacks) {
        const writeDefault = streamIn.hasFS;
        const {
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir,
          nodePaths,
          mangleCache
        } = flagsForBuildOptions(callName, options2, isTTY2, buildLogLevelDefault, writeDefault);
        if (write && !streamIn.hasFS)
          throw new Error(`The "write" option is unavailable in this environment`);
        const request = {
          command: "build",
          key: buildKey,
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir: absWorkingDir || defaultWD2,
          nodePaths,
          context: isContext
        };
        if (requestPlugins)
          request.plugins = requestPlugins;
        if (mangleCache)
          request.mangleCache = mangleCache;
        const buildResponseToResult = (response, callback2) => {
          const result = {
            errors: replaceDetailsInMessages(response.errors, details),
            warnings: replaceDetailsInMessages(response.warnings, details),
            outputFiles: void 0,
            metafile: void 0,
            mangleCache: void 0
          };
          const originalErrors = result.errors.slice();
          const originalWarnings = result.warnings.slice();
          if (response.outputFiles)
            result.outputFiles = response.outputFiles.map(convertOutputFiles);
          if (response.metafile)
            result.metafile = JSON.parse(response.metafile);
          if (response.mangleCache)
            result.mangleCache = response.mangleCache;
          if (response.writeToStdout !== void 0)
            console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
          runOnEndCallbacks(result, (onEndErrors, onEndWarnings) => {
            if (originalErrors.length > 0 || onEndErrors.length > 0) {
              const error2 = failureErrorWithLog("Build failed", originalErrors.concat(onEndErrors), originalWarnings.concat(onEndWarnings));
              return callback2(error2, null, onEndErrors, onEndWarnings);
            }
            callback2(null, result, onEndErrors, onEndWarnings);
          });
        };
        let latestResultPromise;
        let provideLatestResult;
        if (isContext)
          requestCallbacks["on-end"] = (id, request2) => new Promise((resolve5) => {
            buildResponseToResult(request2, (err, result, onEndErrors, onEndWarnings) => {
              const response = {
                errors: onEndErrors,
                warnings: onEndWarnings
              };
              if (provideLatestResult)
                provideLatestResult(err, result);
              latestResultPromise = void 0;
              provideLatestResult = void 0;
              sendResponse(id, response);
              resolve5();
            });
          });
        sendRequest(refs, request, (error2, response) => {
          if (error2)
            return callback(new Error(error2), null);
          if (!isContext) {
            return buildResponseToResult(response, (err, res) => {
              scheduleOnDisposeCallbacks();
              return callback(err, res);
            });
          }
          if (response.errors.length > 0) {
            return callback(failureErrorWithLog("Context failed", response.errors, response.warnings), null);
          }
          let didDispose = false;
          const result = {
            rebuild: () => {
              if (!latestResultPromise)
                latestResultPromise = new Promise((resolve5, reject) => {
                  let settlePromise;
                  provideLatestResult = (err, result2) => {
                    if (!settlePromise)
                      settlePromise = () => err ? reject(err) : resolve5(result2);
                  };
                  const triggerAnotherBuild = () => {
                    const request2 = {
                      command: "rebuild",
                      key: buildKey
                    };
                    sendRequest(refs, request2, (error22, response2) => {
                      if (error22) {
                        reject(new Error(error22));
                      } else if (settlePromise) {
                        settlePromise();
                      } else {
                        triggerAnotherBuild();
                      }
                    });
                  };
                  triggerAnotherBuild();
                });
              return latestResultPromise;
            },
            watch: (options22 = {}) => new Promise((resolve5, reject) => {
              if (!streamIn.hasFS)
                throw new Error(`Cannot use the "watch" API in this environment`);
              const keys2 = {};
              checkForInvalidFlags(options22, keys2, `in watch() call`);
              const request2 = {
                command: "watch",
                key: buildKey
              };
              sendRequest(refs, request2, (error22) => {
                if (error22)
                  reject(new Error(error22));
                else
                  resolve5(void 0);
              });
            }),
            serve: (options22 = {}) => new Promise((resolve5, reject) => {
              if (!streamIn.hasFS)
                throw new Error(`Cannot use the "serve" API in this environment`);
              const keys2 = {};
              const port = getFlag(options22, keys2, "port", mustBeInteger);
              const host = getFlag(options22, keys2, "host", mustBeString);
              const servedir = getFlag(options22, keys2, "servedir", mustBeString);
              const keyfile = getFlag(options22, keys2, "keyfile", mustBeString);
              const certfile = getFlag(options22, keys2, "certfile", mustBeString);
              const onRequest = getFlag(options22, keys2, "onRequest", mustBeFunction);
              checkForInvalidFlags(options22, keys2, `in serve() call`);
              const request2 = {
                command: "serve",
                key: buildKey,
                onRequest: !!onRequest
              };
              if (port !== void 0)
                request2.port = port;
              if (host !== void 0)
                request2.host = host;
              if (servedir !== void 0)
                request2.servedir = servedir;
              if (keyfile !== void 0)
                request2.keyfile = keyfile;
              if (certfile !== void 0)
                request2.certfile = certfile;
              sendRequest(refs, request2, (error22, response2) => {
                if (error22)
                  return reject(new Error(error22));
                if (onRequest) {
                  requestCallbacks["serve-request"] = (id, request3) => {
                    onRequest(request3.args);
                    sendResponse(id, {});
                  };
                }
                resolve5(response2);
              });
            }),
            cancel: () => new Promise((resolve5) => {
              if (didDispose)
                return resolve5();
              const request2 = {
                command: "cancel",
                key: buildKey
              };
              sendRequest(refs, request2, () => {
                resolve5();
              });
            }),
            dispose: () => new Promise((resolve5) => {
              if (didDispose)
                return resolve5();
              didDispose = true;
              const request2 = {
                command: "dispose",
                key: buildKey
              };
              sendRequest(refs, request2, () => {
                resolve5();
                scheduleOnDisposeCallbacks();
                refs.unref();
              });
            })
          };
          refs.ref();
          callback(null, result);
        });
      }
    }
    var handlePlugins = async (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins2, details) => {
      let onStartCallbacks = [];
      let onEndCallbacks = [];
      let onResolveCallbacks = {};
      let onLoadCallbacks = {};
      let onDisposeCallbacks = [];
      let nextCallbackID = 0;
      let i = 0;
      let requestPlugins = [];
      let isSetupDone = false;
      plugins2 = [...plugins2];
      for (let item of plugins2) {
        let keys2 = {};
        if (typeof item !== "object")
          throw new Error(`Plugin at index ${i} must be an object`);
        const name2 = getFlag(item, keys2, "name", mustBeString);
        if (typeof name2 !== "string" || name2 === "")
          throw new Error(`Plugin at index ${i} is missing a name`);
        try {
          let setup = getFlag(item, keys2, "setup", mustBeFunction);
          if (typeof setup !== "function")
            throw new Error(`Plugin is missing a setup function`);
          checkForInvalidFlags(item, keys2, `on plugin ${quote(name2)}`);
          let plugin = {
            name: name2,
            onStart: false,
            onEnd: false,
            onResolve: [],
            onLoad: []
          };
          i++;
          let resolve5 = (path32, options2 = {}) => {
            if (!isSetupDone)
              throw new Error('Cannot call "resolve" before plugin setup has completed');
            if (typeof path32 !== "string")
              throw new Error(`The path to resolve must be a string`);
            let keys22 = /* @__PURE__ */ Object.create(null);
            let pluginName = getFlag(options2, keys22, "pluginName", mustBeString);
            let importer = getFlag(options2, keys22, "importer", mustBeString);
            let namespace = getFlag(options2, keys22, "namespace", mustBeString);
            let resolveDir = getFlag(options2, keys22, "resolveDir", mustBeString);
            let kind = getFlag(options2, keys22, "kind", mustBeString);
            let pluginData = getFlag(options2, keys22, "pluginData", canBeAnything);
            checkForInvalidFlags(options2, keys22, "in resolve() call");
            return new Promise((resolve22, reject) => {
              const request = {
                command: "resolve",
                path: path32,
                key: buildKey,
                pluginName: name2
              };
              if (pluginName != null)
                request.pluginName = pluginName;
              if (importer != null)
                request.importer = importer;
              if (namespace != null)
                request.namespace = namespace;
              if (resolveDir != null)
                request.resolveDir = resolveDir;
              if (kind != null)
                request.kind = kind;
              else
                throw new Error(`Must specify "kind" when calling "resolve"`);
              if (pluginData != null)
                request.pluginData = details.store(pluginData);
              sendRequest(refs, request, (error2, response) => {
                if (error2 !== null)
                  reject(new Error(error2));
                else
                  resolve22({
                    errors: replaceDetailsInMessages(response.errors, details),
                    warnings: replaceDetailsInMessages(response.warnings, details),
                    path: response.path,
                    external: response.external,
                    sideEffects: response.sideEffects,
                    namespace: response.namespace,
                    suffix: response.suffix,
                    pluginData: details.load(response.pluginData)
                  });
              });
            });
          };
          let promise2 = setup({
            initialOptions,
            resolve: resolve5,
            onStart(callback) {
              let registeredText = `This error came from the "onStart" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
              onStartCallbacks.push({ name: name2, callback, note: registeredNote });
              plugin.onStart = true;
            },
            onEnd(callback) {
              let registeredText = `This error came from the "onEnd" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
              onEndCallbacks.push({ name: name2, callback, note: registeredNote });
              plugin.onEnd = true;
            },
            onResolve(options2, callback) {
              let registeredText = `This error came from the "onResolve" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
              let keys22 = {};
              let filter2 = getFlag(options2, keys22, "filter", mustBeRegExp);
              let namespace = getFlag(options2, keys22, "namespace", mustBeString);
              checkForInvalidFlags(options2, keys22, `in onResolve() call for plugin ${quote(name2)}`);
              if (filter2 == null)
                throw new Error(`onResolve() call is missing a filter`);
              let id = nextCallbackID++;
              onResolveCallbacks[id] = { name: name2, callback, note: registeredNote };
              plugin.onResolve.push({ id, filter: filter2.source, namespace: namespace || "" });
            },
            onLoad(options2, callback) {
              let registeredText = `This error came from the "onLoad" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
              let keys22 = {};
              let filter2 = getFlag(options2, keys22, "filter", mustBeRegExp);
              let namespace = getFlag(options2, keys22, "namespace", mustBeString);
              checkForInvalidFlags(options2, keys22, `in onLoad() call for plugin ${quote(name2)}`);
              if (filter2 == null)
                throw new Error(`onLoad() call is missing a filter`);
              let id = nextCallbackID++;
              onLoadCallbacks[id] = { name: name2, callback, note: registeredNote };
              plugin.onLoad.push({ id, filter: filter2.source, namespace: namespace || "" });
            },
            onDispose(callback) {
              onDisposeCallbacks.push(callback);
            },
            esbuild: streamIn.esbuild
          });
          if (promise2)
            await promise2;
          requestPlugins.push(plugin);
        } catch (e) {
          return { ok: false, error: e, pluginName: name2 };
        }
      }
      requestCallbacks["on-start"] = async (id, request) => {
        let response = { errors: [], warnings: [] };
        await Promise.all(onStartCallbacks.map(async ({ name: name2, callback, note }) => {
          try {
            let result = await callback();
            if (result != null) {
              if (typeof result !== "object")
                throw new Error(`Expected onStart() callback in plugin ${quote(name2)} to return an object`);
              let keys2 = {};
              let errors = getFlag(result, keys2, "errors", mustBeArray);
              let warnings = getFlag(result, keys2, "warnings", mustBeArray);
              checkForInvalidFlags(result, keys2, `from onStart() callback in plugin ${quote(name2)}`);
              if (errors != null)
                response.errors.push(...sanitizeMessages(errors, "errors", details, name2));
              if (warnings != null)
                response.warnings.push(...sanitizeMessages(warnings, "warnings", details, name2));
            }
          } catch (e) {
            response.errors.push(extractErrorMessageV8(e, streamIn, details, note && note(), name2));
          }
        }));
        sendResponse(id, response);
      };
      requestCallbacks["on-resolve"] = async (id, request) => {
        let response = {}, name2 = "", callback, note;
        for (let id2 of request.ids) {
          try {
            ({ name: name2, callback, note } = onResolveCallbacks[id2]);
            let result = await callback({
              path: request.path,
              importer: request.importer,
              namespace: request.namespace,
              resolveDir: request.resolveDir,
              kind: request.kind,
              pluginData: details.load(request.pluginData)
            });
            if (result != null) {
              if (typeof result !== "object")
                throw new Error(`Expected onResolve() callback in plugin ${quote(name2)} to return an object`);
              let keys2 = {};
              let pluginName = getFlag(result, keys2, "pluginName", mustBeString);
              let path32 = getFlag(result, keys2, "path", mustBeString);
              let namespace = getFlag(result, keys2, "namespace", mustBeString);
              let suffix = getFlag(result, keys2, "suffix", mustBeString);
              let external = getFlag(result, keys2, "external", mustBeBoolean);
              let sideEffects = getFlag(result, keys2, "sideEffects", mustBeBoolean);
              let pluginData = getFlag(result, keys2, "pluginData", canBeAnything);
              let errors = getFlag(result, keys2, "errors", mustBeArray);
              let warnings = getFlag(result, keys2, "warnings", mustBeArray);
              let watchFiles = getFlag(result, keys2, "watchFiles", mustBeArray);
              let watchDirs = getFlag(result, keys2, "watchDirs", mustBeArray);
              checkForInvalidFlags(result, keys2, `from onResolve() callback in plugin ${quote(name2)}`);
              response.id = id2;
              if (pluginName != null)
                response.pluginName = pluginName;
              if (path32 != null)
                response.path = path32;
              if (namespace != null)
                response.namespace = namespace;
              if (suffix != null)
                response.suffix = suffix;
              if (external != null)
                response.external = external;
              if (sideEffects != null)
                response.sideEffects = sideEffects;
              if (pluginData != null)
                response.pluginData = details.store(pluginData);
              if (errors != null)
                response.errors = sanitizeMessages(errors, "errors", details, name2);
              if (warnings != null)
                response.warnings = sanitizeMessages(warnings, "warnings", details, name2);
              if (watchFiles != null)
                response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
              if (watchDirs != null)
                response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
              break;
            }
          } catch (e) {
            response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name2)] };
            break;
          }
        }
        sendResponse(id, response);
      };
      requestCallbacks["on-load"] = async (id, request) => {
        let response = {}, name2 = "", callback, note;
        for (let id2 of request.ids) {
          try {
            ({ name: name2, callback, note } = onLoadCallbacks[id2]);
            let result = await callback({
              path: request.path,
              namespace: request.namespace,
              suffix: request.suffix,
              pluginData: details.load(request.pluginData)
            });
            if (result != null) {
              if (typeof result !== "object")
                throw new Error(`Expected onLoad() callback in plugin ${quote(name2)} to return an object`);
              let keys2 = {};
              let pluginName = getFlag(result, keys2, "pluginName", mustBeString);
              let contents = getFlag(result, keys2, "contents", mustBeStringOrUint8Array);
              let resolveDir = getFlag(result, keys2, "resolveDir", mustBeString);
              let pluginData = getFlag(result, keys2, "pluginData", canBeAnything);
              let loader = getFlag(result, keys2, "loader", mustBeString);
              let errors = getFlag(result, keys2, "errors", mustBeArray);
              let warnings = getFlag(result, keys2, "warnings", mustBeArray);
              let watchFiles = getFlag(result, keys2, "watchFiles", mustBeArray);
              let watchDirs = getFlag(result, keys2, "watchDirs", mustBeArray);
              checkForInvalidFlags(result, keys2, `from onLoad() callback in plugin ${quote(name2)}`);
              response.id = id2;
              if (pluginName != null)
                response.pluginName = pluginName;
              if (contents instanceof Uint8Array)
                response.contents = contents;
              else if (contents != null)
                response.contents = encodeUTF8(contents);
              if (resolveDir != null)
                response.resolveDir = resolveDir;
              if (pluginData != null)
                response.pluginData = details.store(pluginData);
              if (loader != null)
                response.loader = loader;
              if (errors != null)
                response.errors = sanitizeMessages(errors, "errors", details, name2);
              if (warnings != null)
                response.warnings = sanitizeMessages(warnings, "warnings", details, name2);
              if (watchFiles != null)
                response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
              if (watchDirs != null)
                response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
              break;
            }
          } catch (e) {
            response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name2)] };
            break;
          }
        }
        sendResponse(id, response);
      };
      let runOnEndCallbacks = (result, done) => done([], []);
      if (onEndCallbacks.length > 0) {
        runOnEndCallbacks = (result, done) => {
          (async () => {
            const onEndErrors = [];
            const onEndWarnings = [];
            for (const { name: name2, callback, note } of onEndCallbacks) {
              let newErrors;
              let newWarnings;
              try {
                const value2 = await callback(result);
                if (value2 != null) {
                  if (typeof value2 !== "object")
                    throw new Error(`Expected onEnd() callback in plugin ${quote(name2)} to return an object`);
                  let keys2 = {};
                  let errors = getFlag(value2, keys2, "errors", mustBeArray);
                  let warnings = getFlag(value2, keys2, "warnings", mustBeArray);
                  checkForInvalidFlags(value2, keys2, `from onEnd() callback in plugin ${quote(name2)}`);
                  if (errors != null)
                    newErrors = sanitizeMessages(errors, "errors", details, name2);
                  if (warnings != null)
                    newWarnings = sanitizeMessages(warnings, "warnings", details, name2);
                }
              } catch (e) {
                newErrors = [extractErrorMessageV8(e, streamIn, details, note && note(), name2)];
              }
              if (newErrors) {
                onEndErrors.push(...newErrors);
                try {
                  result.errors.push(...newErrors);
                } catch {
                }
              }
              if (newWarnings) {
                onEndWarnings.push(...newWarnings);
                try {
                  result.warnings.push(...newWarnings);
                } catch {
                }
              }
            }
            done(onEndErrors, onEndWarnings);
          })();
        };
      }
      let scheduleOnDisposeCallbacks = () => {
        for (const cb of onDisposeCallbacks) {
          setTimeout(() => cb(), 0);
        }
      };
      isSetupDone = true;
      return {
        ok: true,
        requestPlugins,
        runOnEndCallbacks,
        scheduleOnDisposeCallbacks
      };
    };
    function createObjectStash() {
      const map2 = /* @__PURE__ */ new Map();
      let nextID = 0;
      return {
        load(id) {
          return map2.get(id);
        },
        store(value2) {
          if (value2 === void 0)
            return -1;
          const id = nextID++;
          map2.set(id, value2);
          return id;
        }
      };
    }
    function extractCallerV8(e, streamIn, ident) {
      let note;
      let tried = false;
      return () => {
        if (tried)
          return note;
        tried = true;
        try {
          let lines = (e.stack + "").split("\n");
          lines.splice(1, 1);
          let location2 = parseStackLinesV8(streamIn, lines, ident);
          if (location2) {
            note = { text: e.message, location: location2 };
            return note;
          }
        } catch {
        }
      };
    }
    function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {
      let text = "Internal error";
      let location2 = null;
      try {
        text = (e && e.message || e) + "";
      } catch {
      }
      try {
        location2 = parseStackLinesV8(streamIn, (e.stack + "").split("\n"), "");
      } catch {
      }
      return { id: "", pluginName, text, location: location2, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };
    }
    function parseStackLinesV8(streamIn, lines, ident) {
      let at3 = "    at ";
      if (streamIn.readFileSync && !lines[0].startsWith(at3) && lines[1].startsWith(at3)) {
        for (let i = 1; i < lines.length; i++) {
          let line = lines[i];
          if (!line.startsWith(at3))
            continue;
          line = line.slice(at3.length);
          while (true) {
            let match = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);
            if (match) {
              line = match[1];
              continue;
            }
            match = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);
            if (match) {
              line = match[1];
              continue;
            }
            match = /^(\S+):(\d+):(\d+)$/.exec(line);
            if (match) {
              let contents;
              try {
                contents = streamIn.readFileSync(match[1], "utf8");
              } catch {
                break;
              }
              let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match[2] - 1] || "";
              let column = +match[3] - 1;
              let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;
              return {
                file: match[1],
                namespace: "file",
                line: +match[2],
                column: encodeUTF8(lineText.slice(0, column)).length,
                length: encodeUTF8(lineText.slice(column, column + length)).length,
                lineText: lineText + "\n" + lines.slice(1).join("\n"),
                suggestion: ""
              };
            }
            break;
          }
        }
      }
      return null;
    }
    function failureErrorWithLog(text, errors, warnings) {
      let limit = 5;
      let summary = errors.length < 1 ? "" : ` with ${errors.length} error${errors.length < 2 ? "" : "s"}:` + errors.slice(0, limit + 1).map((e, i) => {
        if (i === limit)
          return "\n...";
        if (!e.location)
          return `
error: ${e.text}`;
        let { file, line, column } = e.location;
        let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : "";
        return `
${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;
      }).join("");
      let error2 = new Error(`${text}${summary}`);
      error2.errors = errors;
      error2.warnings = warnings;
      return error2;
    }
    function replaceDetailsInMessages(messages2, stash) {
      for (const message of messages2) {
        message.detail = stash.load(message.detail);
      }
      return messages2;
    }
    function sanitizeLocation(location2, where) {
      if (location2 == null)
        return null;
      let keys2 = {};
      let file = getFlag(location2, keys2, "file", mustBeString);
      let namespace = getFlag(location2, keys2, "namespace", mustBeString);
      let line = getFlag(location2, keys2, "line", mustBeInteger);
      let column = getFlag(location2, keys2, "column", mustBeInteger);
      let length = getFlag(location2, keys2, "length", mustBeInteger);
      let lineText = getFlag(location2, keys2, "lineText", mustBeString);
      let suggestion = getFlag(location2, keys2, "suggestion", mustBeString);
      checkForInvalidFlags(location2, keys2, where);
      return {
        file: file || "",
        namespace: namespace || "",
        line: line || 0,
        column: column || 0,
        length: length || 0,
        lineText: lineText || "",
        suggestion: suggestion || ""
      };
    }
    function sanitizeMessages(messages2, property, stash, fallbackPluginName) {
      let messagesClone = [];
      let index = 0;
      for (const message of messages2) {
        let keys2 = {};
        let id = getFlag(message, keys2, "id", mustBeString);
        let pluginName = getFlag(message, keys2, "pluginName", mustBeString);
        let text = getFlag(message, keys2, "text", mustBeString);
        let location2 = getFlag(message, keys2, "location", mustBeObjectOrNull);
        let notes = getFlag(message, keys2, "notes", mustBeArray);
        let detail = getFlag(message, keys2, "detail", canBeAnything);
        let where = `in element ${index} of "${property}"`;
        checkForInvalidFlags(message, keys2, where);
        let notesClone = [];
        if (notes) {
          for (const note of notes) {
            let noteKeys = {};
            let noteText = getFlag(note, noteKeys, "text", mustBeString);
            let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
            checkForInvalidFlags(note, noteKeys, where);
            notesClone.push({
              text: noteText || "",
              location: sanitizeLocation(noteLocation, where)
            });
          }
        }
        messagesClone.push({
          id: id || "",
          pluginName: pluginName || fallbackPluginName,
          text: text || "",
          location: sanitizeLocation(location2, where),
          notes: notesClone,
          detail: stash ? stash.store(detail) : -1
        });
        index++;
      }
      return messagesClone;
    }
    function sanitizeStringArray(values, property) {
      const result = [];
      for (const value2 of values) {
        if (typeof value2 !== "string")
          throw new Error(`${quote(property)} must be an array of strings`);
        result.push(value2);
      }
      return result;
    }
    function convertOutputFiles({ path: path32, contents }) {
      let text = null;
      return {
        path: path32,
        contents,
        get text() {
          const binary2 = this.contents;
          if (text === null || binary2 !== contents) {
            contents = binary2;
            text = decodeUTF8(binary2);
          }
          return text;
        }
      };
    }
    var fs2 = require("fs");
    var os2 = require("os");
    var path4 = require("path");
    var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
    var isValidBinaryPath = (x) => !!x && x !== "/usr/bin/esbuild";
    var packageDarwin_arm64 = "@esbuild/darwin-arm64";
    var packageDarwin_x64 = "@esbuild/darwin-x64";
    var knownWindowsPackages = {
      "win32 arm64 LE": "@esbuild/win32-arm64",
      "win32 ia32 LE": "@esbuild/win32-ia32",
      "win32 x64 LE": "@esbuild/win32-x64"
    };
    var knownUnixlikePackages = {
      "android arm64 LE": "@esbuild/android-arm64",
      "darwin arm64 LE": "@esbuild/darwin-arm64",
      "darwin x64 LE": "@esbuild/darwin-x64",
      "freebsd arm64 LE": "@esbuild/freebsd-arm64",
      "freebsd x64 LE": "@esbuild/freebsd-x64",
      "linux arm LE": "@esbuild/linux-arm",
      "linux arm64 LE": "@esbuild/linux-arm64",
      "linux ia32 LE": "@esbuild/linux-ia32",
      "linux mips64el LE": "@esbuild/linux-mips64el",
      "linux ppc64 LE": "@esbuild/linux-ppc64",
      "linux riscv64 LE": "@esbuild/linux-riscv64",
      "linux s390x BE": "@esbuild/linux-s390x",
      "linux x64 LE": "@esbuild/linux-x64",
      "linux loong64 LE": "@esbuild/linux-loong64",
      "netbsd x64 LE": "@esbuild/netbsd-x64",
      "openbsd x64 LE": "@esbuild/openbsd-x64",
      "sunos x64 LE": "@esbuild/sunos-x64"
    };
    var knownWebAssemblyFallbackPackages = {
      "android arm LE": "@esbuild/android-arm",
      "android x64 LE": "@esbuild/android-x64"
    };
    function pkgAndSubpathForCurrentPlatform() {
      let pkg;
      let subpath;
      let isWASM = false;
      let platformKey = `${process.platform} ${os2.arch()} ${os2.endianness()}`;
      if (platformKey in knownWindowsPackages) {
        pkg = knownWindowsPackages[platformKey];
        subpath = "esbuild.exe";
      } else if (platformKey in knownUnixlikePackages) {
        pkg = knownUnixlikePackages[platformKey];
        subpath = "bin/esbuild";
      } else if (platformKey in knownWebAssemblyFallbackPackages) {
        pkg = knownWebAssemblyFallbackPackages[platformKey];
        subpath = "bin/esbuild";
        isWASM = true;
      } else {
        throw new Error(`Unsupported platform: ${platformKey}`);
      }
      return { pkg, subpath, isWASM };
    }
    function pkgForSomeOtherPlatform() {
      const libMainJS = require.resolve("esbuild");
      const nodeModulesDirectory = path4.dirname(path4.dirname(path4.dirname(libMainJS)));
      if (path4.basename(nodeModulesDirectory) === "node_modules") {
        for (const unixKey in knownUnixlikePackages) {
          try {
            const pkg = knownUnixlikePackages[unixKey];
            if (fs2.existsSync(path4.join(nodeModulesDirectory, pkg)))
              return pkg;
          } catch {
          }
        }
        for (const windowsKey in knownWindowsPackages) {
          try {
            const pkg = knownWindowsPackages[windowsKey];
            if (fs2.existsSync(path4.join(nodeModulesDirectory, pkg)))
              return pkg;
          } catch {
          }
        }
      }
      return null;
    }
    function downloadedBinPath(pkg, subpath) {
      const esbuildLibDir = path4.dirname(require.resolve("esbuild"));
      return path4.join(esbuildLibDir, `downloaded-${pkg.replace("/", "-")}-${path4.basename(subpath)}`);
    }
    function generateBinPath() {
      if (isValidBinaryPath(ESBUILD_BINARY_PATH)) {
        if (!fs2.existsSync(ESBUILD_BINARY_PATH)) {
          console.warn(`[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=${ESBUILD_BINARY_PATH}`);
        } else {
          return { binPath: ESBUILD_BINARY_PATH, isWASM: false };
        }
      }
      const { pkg, subpath, isWASM } = pkgAndSubpathForCurrentPlatform();
      let binPath;
      try {
        binPath = require.resolve(`${pkg}/${subpath}`);
      } catch (e) {
        binPath = downloadedBinPath(pkg, subpath);
        if (!fs2.existsSync(binPath)) {
          try {
            require.resolve(pkg);
          } catch {
            const otherPkg = pkgForSomeOtherPlatform();
            if (otherPkg) {
              let suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead of npm which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
              if (pkg === packageDarwin_x64 && otherPkg === packageDarwin_arm64 || pkg === packageDarwin_arm64 && otherPkg === packageDarwin_x64) {
                suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild with npm running inside of Rosetta 2 and then
trying to use it with node running outside of Rosetta 2, or vice versa (Rosetta
2 is Apple's on-the-fly x86_64-to-arm64 translation service).

If you are installing with npm, you can try ensuring that both npm and node are
not running under Rosetta 2 and then reinstalling esbuild. This likely involves
changing how you installed npm and/or node. For example, installing node with
the universal installer here should work: https://nodejs.org/en/download/. Or
you could consider using yarn instead of npm which has built-in support for
installing a package on multiple platforms simultaneously.

If you are installing with yarn, you can try listing both "arm64" and "x64"
in your ".yarnrc.yml" file using the "supportedArchitectures" feature:
https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
              }
              throw new Error(`
You installed esbuild for another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.
${suggestions}
Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
            }
            throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" or "--omit=optional" flags. The "optionalDependencies" feature
of "package.json" is used by esbuild to install the correct binary executable
for your current platform.`);
          }
          throw e;
        }
      }
      if (/\.zip\//.test(binPath)) {
        let pnpapi;
        try {
          pnpapi = require("pnpapi");
        } catch (e) {
        }
        if (pnpapi) {
          const root = pnpapi.getPackageInformation(pnpapi.topLevel).packageLocation;
          const binTargetPath = path4.join(
            root,
            "node_modules",
            ".cache",
            "esbuild",
            `pnpapi-${pkg.replace("/", "-")}-${"0.17.14"}-${path4.basename(subpath)}`
          );
          if (!fs2.existsSync(binTargetPath)) {
            fs2.mkdirSync(path4.dirname(binTargetPath), { recursive: true });
            fs2.copyFileSync(binPath, binTargetPath);
            fs2.chmodSync(binTargetPath, 493);
          }
          return { binPath: binTargetPath, isWASM };
        }
      }
      return { binPath, isWASM };
    }
    var child_process = require("child_process");
    var crypto = require("crypto");
    var path22 = require("path");
    var fs22 = require("fs");
    var os22 = require("os");
    var tty3 = require("tty");
    var worker_threads;
    if (process.env.ESBUILD_WORKER_THREADS !== "0") {
      try {
        worker_threads = require("worker_threads");
      } catch {
      }
      let [major, minor] = process.versions.node.split(".");
      if (
        // <v12.17.0 does not work
        +major < 12 || +major === 12 && +minor < 17 || +major === 13 && +minor < 13
      ) {
        worker_threads = void 0;
      }
    }
    var _a;
    var isInternalWorkerThread = ((_a = worker_threads == null ? void 0 : worker_threads.workerData) == null ? void 0 : _a.esbuildVersion) === "0.17.14";
    var esbuildCommandAndArgs = () => {
      if ((!ESBUILD_BINARY_PATH || false) && (path22.basename(__filename) !== "main.js" || path22.basename(__dirname) !== "lib")) {
        throw new Error(
          `The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

More information: The file containing the code for esbuild's JavaScript API (${__filename}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`
        );
      }
      if (false) {
        return ["node", [path22.join(__dirname, "..", "bin", "esbuild")]];
      } else {
        const { binPath, isWASM } = generateBinPath();
        if (isWASM) {
          return ["node", [binPath]];
        } else {
          return [binPath, []];
        }
      }
    };
    var isTTY = () => tty3.isatty(2);
    var fsSync = {
      readFile(tempFile, callback) {
        try {
          let contents = fs22.readFileSync(tempFile, "utf8");
          try {
            fs22.unlinkSync(tempFile);
          } catch {
          }
          callback(null, contents);
        } catch (err) {
          callback(err, null);
        }
      },
      writeFile(contents, callback) {
        try {
          let tempFile = randomFileName();
          fs22.writeFileSync(tempFile, contents);
          callback(tempFile);
        } catch {
          callback(null);
        }
      }
    };
    var fsAsync = {
      readFile(tempFile, callback) {
        try {
          fs22.readFile(tempFile, "utf8", (err, contents) => {
            try {
              fs22.unlink(tempFile, () => callback(err, contents));
            } catch {
              callback(err, contents);
            }
          });
        } catch (err) {
          callback(err, null);
        }
      },
      writeFile(contents, callback) {
        try {
          let tempFile = randomFileName();
          fs22.writeFile(tempFile, contents, (err) => err !== null ? callback(null) : callback(tempFile));
        } catch {
          callback(null);
        }
      }
    };
    var version5 = "0.17.14";
    var build2 = (options2) => ensureServiceIsRunning().build(options2);
    var context = (buildOptions) => ensureServiceIsRunning().context(buildOptions);
    var transform2 = (input, options2) => ensureServiceIsRunning().transform(input, options2);
    var formatMessages2 = (messages2, options2) => ensureServiceIsRunning().formatMessages(messages2, options2);
    var analyzeMetafile = (messages2, options2) => ensureServiceIsRunning().analyzeMetafile(messages2, options2);
    var buildSync = (options2) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.buildSync(options2);
      }
      let result;
      runServiceSync((service) => service.buildOrContext({
        callName: "buildSync",
        refs: null,
        options: options2,
        isTTY: isTTY(),
        defaultWD,
        callback: (err, res) => {
          if (err)
            throw err;
          result = res;
        }
      }));
      return result;
    };
    var transformSync = (input, options2) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.transformSync(input, options2);
      }
      let result;
      runServiceSync((service) => service.transform({
        callName: "transformSync",
        refs: null,
        input,
        options: options2 || {},
        isTTY: isTTY(),
        fs: fsSync,
        callback: (err, res) => {
          if (err)
            throw err;
          result = res;
        }
      }));
      return result;
    };
    var formatMessagesSync = (messages2, options2) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.formatMessagesSync(messages2, options2);
      }
      let result;
      runServiceSync((service) => service.formatMessages({
        callName: "formatMessagesSync",
        refs: null,
        messages: messages2,
        options: options2,
        callback: (err, res) => {
          if (err)
            throw err;
          result = res;
        }
      }));
      return result;
    };
    var analyzeMetafileSync = (metafile, options2) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.analyzeMetafileSync(metafile, options2);
      }
      let result;
      runServiceSync((service) => service.analyzeMetafile({
        callName: "analyzeMetafileSync",
        refs: null,
        metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
        options: options2,
        callback: (err, res) => {
          if (err)
            throw err;
          result = res;
        }
      }));
      return result;
    };
    var initializeWasCalled = false;
    var initialize = (options2) => {
      options2 = validateInitializeOptions(options2 || {});
      if (options2.wasmURL)
        throw new Error(`The "wasmURL" option only works in the browser`);
      if (options2.wasmModule)
        throw new Error(`The "wasmModule" option only works in the browser`);
      if (options2.worker)
        throw new Error(`The "worker" option only works in the browser`);
      if (initializeWasCalled)
        throw new Error('Cannot call "initialize" more than once');
      ensureServiceIsRunning();
      initializeWasCalled = true;
      return Promise.resolve();
    };
    var defaultWD = process.cwd();
    var longLivedService;
    var ensureServiceIsRunning = () => {
      if (longLivedService)
        return longLivedService;
      let [command, args] = esbuildCommandAndArgs();
      let child = child_process.spawn(command, args.concat(`--service=${"0.17.14"}`, "--ping"), {
        windowsHide: true,
        stdio: ["pipe", "pipe", "inherit"],
        cwd: defaultWD
      });
      let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin(bytes) {
          child.stdin.write(bytes, (err) => {
            if (err)
              afterClose(err);
          });
        },
        readFileSync: fs22.readFileSync,
        isSync: false,
        hasFS: true,
        esbuild: node_exports
      });
      child.stdin.on("error", afterClose);
      child.on("error", afterClose);
      const stdin = child.stdin;
      const stdout = child.stdout;
      stdout.on("data", readFromStdout);
      stdout.on("end", afterClose);
      let refCount = 0;
      child.unref();
      if (stdin.unref) {
        stdin.unref();
      }
      if (stdout.unref) {
        stdout.unref();
      }
      const refs = {
        ref() {
          if (++refCount === 1)
            child.ref();
        },
        unref() {
          if (--refCount === 0)
            child.unref();
        }
      };
      longLivedService = {
        build: (options2) => new Promise((resolve5, reject) => {
          service.buildOrContext({
            callName: "build",
            refs,
            options: options2,
            isTTY: isTTY(),
            defaultWD,
            callback: (err, res) => err ? reject(err) : resolve5(res)
          });
        }),
        context: (options2) => new Promise((resolve5, reject) => service.buildOrContext({
          callName: "context",
          refs,
          options: options2,
          isTTY: isTTY(),
          defaultWD,
          callback: (err, res) => err ? reject(err) : resolve5(res)
        })),
        transform: (input, options2) => new Promise((resolve5, reject) => service.transform({
          callName: "transform",
          refs,
          input,
          options: options2 || {},
          isTTY: isTTY(),
          fs: fsAsync,
          callback: (err, res) => err ? reject(err) : resolve5(res)
        })),
        formatMessages: (messages2, options2) => new Promise((resolve5, reject) => service.formatMessages({
          callName: "formatMessages",
          refs,
          messages: messages2,
          options: options2,
          callback: (err, res) => err ? reject(err) : resolve5(res)
        })),
        analyzeMetafile: (metafile, options2) => new Promise((resolve5, reject) => service.analyzeMetafile({
          callName: "analyzeMetafile",
          refs,
          metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
          options: options2,
          callback: (err, res) => err ? reject(err) : resolve5(res)
        }))
      };
      return longLivedService;
    };
    var runServiceSync = (callback) => {
      let [command, args] = esbuildCommandAndArgs();
      let stdin = new Uint8Array();
      let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin(bytes) {
          if (stdin.length !== 0)
            throw new Error("Must run at most one command");
          stdin = bytes;
        },
        isSync: true,
        hasFS: true,
        esbuild: node_exports
      });
      callback(service);
      let stdout = child_process.execFileSync(command, args.concat(`--service=${"0.17.14"}`), {
        cwd: defaultWD,
        windowsHide: true,
        input: stdin,
        // We don't know how large the output could be. If it's too large, the
        // command will fail with ENOBUFS. Reserve 16mb for now since that feels
        // like it should be enough. Also allow overriding this with an environment
        // variable.
        maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
      });
      readFromStdout(stdout);
      afterClose(null);
    };
    var randomFileName = () => {
      return path22.join(os22.tmpdir(), `esbuild-${crypto.randomBytes(32).toString("hex")}`);
    };
    var workerThreadService = null;
    var startWorkerThreadService = (worker_threads2) => {
      let { port1: mainPort, port2: workerPort } = new worker_threads2.MessageChannel();
      let worker = new worker_threads2.Worker(__filename, {
        workerData: { workerPort, defaultWD, esbuildVersion: "0.17.14" },
        transferList: [workerPort],
        // From node's documentation: https://nodejs.org/api/worker_threads.html
        //
        //   Take care when launching worker threads from preload scripts (scripts loaded
        //   and run using the `-r` command line flag). Unless the `execArgv` option is
        //   explicitly set, new Worker threads automatically inherit the command line flags
        //   from the running process and will preload the same preload scripts as the main
        //   thread. If the preload script unconditionally launches a worker thread, every
        //   thread spawned will spawn another until the application crashes.
        //
        execArgv: []
      });
      let nextID = 0;
      let fakeBuildError = (text) => {
        let error2 = new Error(`Build failed with 1 error:
error: ${text}`);
        let errors = [{ id: "", pluginName: "", text, location: null, notes: [], detail: void 0 }];
        error2.errors = errors;
        error2.warnings = [];
        return error2;
      };
      let validateBuildSyncOptions = (options2) => {
        if (!options2)
          return;
        let plugins2 = options2.plugins;
        if (plugins2 && plugins2.length > 0)
          throw fakeBuildError(`Cannot use plugins in synchronous API calls`);
      };
      let applyProperties = (object, properties) => {
        for (let key in properties) {
          object[key] = properties[key];
        }
      };
      let runCallSync = (command, args) => {
        let id = nextID++;
        let sharedBuffer = new SharedArrayBuffer(8);
        let sharedBufferView = new Int32Array(sharedBuffer);
        let msg = { sharedBuffer, id, command, args };
        worker.postMessage(msg);
        let status2 = Atomics.wait(sharedBufferView, 0, 0);
        if (status2 !== "ok" && status2 !== "not-equal")
          throw new Error("Internal error: Atomics.wait() failed: " + status2);
        let { message: { id: id2, resolve: resolve5, reject, properties } } = worker_threads2.receiveMessageOnPort(mainPort);
        if (id !== id2)
          throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
        if (reject) {
          applyProperties(reject, properties);
          throw reject;
        }
        return resolve5;
      };
      worker.unref();
      return {
        buildSync(options2) {
          validateBuildSyncOptions(options2);
          return runCallSync("build", [options2]);
        },
        transformSync(input, options2) {
          return runCallSync("transform", [input, options2]);
        },
        formatMessagesSync(messages2, options2) {
          return runCallSync("formatMessages", [messages2, options2]);
        },
        analyzeMetafileSync(metafile, options2) {
          return runCallSync("analyzeMetafile", [metafile, options2]);
        }
      };
    };
    var startSyncServiceWorker = () => {
      let workerPort = worker_threads.workerData.workerPort;
      let parentPort = worker_threads.parentPort;
      let extractProperties = (object) => {
        let properties = {};
        if (object && typeof object === "object") {
          for (let key in object) {
            properties[key] = object[key];
          }
        }
        return properties;
      };
      try {
        let service = ensureServiceIsRunning();
        defaultWD = worker_threads.workerData.defaultWD;
        parentPort.on("message", (msg) => {
          (async () => {
            let { sharedBuffer, id, command, args } = msg;
            let sharedBufferView = new Int32Array(sharedBuffer);
            try {
              switch (command) {
                case "build":
                  workerPort.postMessage({ id, resolve: await service.build(args[0]) });
                  break;
                case "transform":
                  workerPort.postMessage({ id, resolve: await service.transform(args[0], args[1]) });
                  break;
                case "formatMessages":
                  workerPort.postMessage({ id, resolve: await service.formatMessages(args[0], args[1]) });
                  break;
                case "analyzeMetafile":
                  workerPort.postMessage({ id, resolve: await service.analyzeMetafile(args[0], args[1]) });
                  break;
                default:
                  throw new Error(`Invalid command: ${command}`);
              }
            } catch (reject) {
              workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
            }
            Atomics.add(sharedBufferView, 0, 1);
            Atomics.notify(sharedBufferView, 0, Infinity);
          })();
        });
      } catch (reject) {
        parentPort.on("message", (msg) => {
          let { sharedBuffer, id } = msg;
          let sharedBufferView = new Int32Array(sharedBuffer);
          workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
          Atomics.add(sharedBufferView, 0, 1);
          Atomics.notify(sharedBufferView, 0, Infinity);
        });
      }
    };
    if (isInternalWorkerThread) {
      startSyncServiceWorker();
    }
    var node_default = node_exports;
  }
});

// node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "node_modules/resolve/lib/homedir.js"(exports2, module2) {
    "use strict";
    var os2 = require("os");
    module2.exports = os2.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "node_modules/resolve/lib/caller.js"(exports2, module2) {
    module2.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "node_modules/path-parse/index.js"(exports2, module2) {
    "use strict";
    var isWindows3 = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win323 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win323.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix3 = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix3.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows3)
      module2.exports = win323.parse;
    else
      module2.exports = posix3.parse;
    module2.exports.posix = posix3.parse;
    module2.exports.win32 = win323.parse;
  }
});

// node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "node_modules/resolve/lib/node-modules-paths.js"(exports2, module2) {
    var path4 = require("path");
    var parse7 = path4.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse7(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse7(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path4.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module2.exports = function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request,
          start,
          function() {
            return getNodeModulesDirs(start, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/resolve/lib/normalize-options.js"(exports2, module2) {
    module2.exports = function(x, opts) {
      return opts || {};
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice2 = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice2.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice2.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice2.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/is-core-module/core.json
var require_core = __commonJS({
  "node_modules/is-core-module/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "node_modules/is-core-module/index.js"(exports2, module2) {
    "use strict";
    var has = require_src();
    function specifierIncluded(current3, specifier) {
      var nodeParts = current3.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current3, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current3, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current3 = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current3 !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current3, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current3, specifierValue);
    }
    var data3 = require_core();
    module2.exports = function isCore(x, nodeVersion) {
      return has(data3, x) && versionIncluded(nodeVersion, data3[x]);
    };
  }
});

// node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "node_modules/resolve/lib/async.js"(exports2, module2) {
    var fs2 = require("fs");
    var getHomedir = require_homedir();
    var path4 = require("path");
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = process.platform !== "win32" && fs2.realpath && typeof fs2.realpath.native === "function" ? fs2.realpath.native : fs2.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path4.join(homedir, ".node_modules"),
        path4.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs2.stat(file, function(err, stat2) {
        if (!err) {
          return cb(null, stat2.isFile() || stat2.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir, cb) {
      fs2.stat(dir, function(err, stat2) {
        if (!err) {
          return cb(null, stat2.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath4(x, cb) {
      realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT")
          cb(realpathErr);
        else
          cb(null, realpathErr ? x : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath4, x, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath4(x, cb);
      } else {
        cb(null, x);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile2, pkgfile, cb) {
      readFile2(pkgfile, function(readFileErr, body) {
        if (readFileErr)
          cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path4.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolve5(x, options2, callback) {
      var cb = callback;
      var opts = options2;
      if (typeof options2 === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile2 = opts.readFile || fs2.readFile;
      var realpath4 = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions3 = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path4.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path4.resolve(basedir);
      maybeRealpath(
        realpath4,
        absoluteStart,
        opts,
        function(err2, realStart) {
          if (err2)
            cb(err2);
          else
            init4(realStart);
        }
      );
      var res;
      function init4(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          res = path4.resolve(basedir2, x);
          if (x === "." || x === ".." || x.slice(-1) === "/")
            res += "/";
          if (/\/$/.test(x) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else
            loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
          return cb(null, x);
        } else
          loadNodeModules(x, basedir2, function(err2, n2, pkg) {
            if (err2)
              cb(err2);
            else if (n2) {
              return maybeRealpath(realpath4, n2, opts, function(err3, realN) {
                if (err3) {
                  cb(err3);
                } else {
                  cb(null, realN, pkg);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function onfile(err2, m, pkg) {
        if (err2)
          cb(err2);
        else if (m)
          cb(null, m, pkg);
        else
          loadAsDirectory(res, function(err3, d, pkg2) {
            if (err3)
              cb(err3);
            else if (d) {
              maybeRealpath(realpath4, d, opts, function(err4, realD) {
                if (err4) {
                  cb(err4);
                } else {
                  cb(null, realD, pkg2);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function loadAsFile(x2, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions3);
        load2(exts, x2, loadAsFilePackage);
        function load2(exts2, x3, loadPackage) {
          if (exts2.length === 0)
            return cb2(null, void 0, loadPackage);
          var file = x3 + exts2[0];
          var pkg = loadPackage;
          if (pkg)
            onpkg(null, pkg);
          else
            loadpkg(path4.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2)
              return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path4.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x3, rel);
              if (r)
                return load2(
                  [""].concat(extensions3.slice()),
                  path4.resolve(dir, r),
                  pkg
                );
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2)
              return cb2(err2);
            if (ex)
              return cb2(null, file, pkg);
            load2(exts2.slice(1), x3, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/")
          return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return cb2(null);
        maybeRealpath(realpath4, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return loadpkg(path4.dirname(dir), cb2);
          var pkgfile = path4.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex)
              return loadpkg(path4.dirname(dir), cb2);
            readPackage(readFile2, pkgfile, function(err3, pkgParam) {
              if (err3)
                cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath4, x2, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return cb2(unwrapErr);
          var pkgfile = path4.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2)
              return cb2(err2);
            if (!ex)
              return loadAsFile(path4.join(x2, "index"), fpkg, cb2);
            readPackage(readFile2, pkgfile, function(err3, pkgParam) {
              if (err3)
                return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path4.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                  if (err4)
                    return cb2(err4);
                  if (m)
                    return cb2(null, m, pkg2);
                  if (!pkg2)
                    return loadAsFile(path4.join(x2, "index"), pkg2, cb2);
                  var dir = path4.resolve(x2, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n2, pkg3) {
                    if (err5)
                      return cb2(err5);
                    if (n2)
                      return cb2(null, n2, pkg3);
                    loadAsFile(path4.join(x2, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path4.join(x2, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0)
          return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path4.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2)
            return cb2(err2);
          if (!isdir2)
            return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m, pkg) {
          if (err2)
            return cb2(err2);
          if (m)
            return cb2(null, m, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n2, pkg) {
          if (err2)
            return cb2(err2);
          if (n2)
            return cb2(null, n2, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x2, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        processDirs(
          cb2,
          packageIterator ? packageIterator(x2, start, thunk, opts) : thunk()
        );
      }
    };
  }
});

// node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "node_modules/resolve/lib/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "node:test": ">= 18",
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "node_modules/resolve/lib/core.js"(exports2, module2) {
    var current3 = process.versions && process.versions.node && process.versions.node.split(".") || [];
    function specifierIncluded(specifier) {
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(current3[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        } else if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(specifierValue);
    }
    var data3 = require_core2();
    var core2 = {};
    for (mod in data3) {
      if (Object.prototype.hasOwnProperty.call(data3, mod)) {
        core2[mod] = versionIncluded(data3[mod]);
      }
    }
    var mod;
    module2.exports = core2;
  }
});

// node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "node_modules/resolve/lib/is-core.js"(exports2, module2) {
    var isCoreModule = require_is_core_module();
    module2.exports = function isCore(x) {
      return isCoreModule(x);
    };
  }
});

// node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "node_modules/resolve/lib/sync.js"(exports2, module2) {
    var isCore = require_is_core_module();
    var fs2 = require("fs");
    var path4 = require("path");
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = process.platform !== "win32" && fs2.realpathSync && typeof fs2.realpathSync.native === "function" ? fs2.realpathSync.native : fs2.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path4.join(homedir, ".node_modules"),
        path4.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat2 = fs2.statSync(file, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat2 && (stat2.isFile() || stat2.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat2 = fs2.statSync(dir, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat2 && stat2.isDirectory();
    };
    var defaultRealpathSync = function realpathSync3(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync3, x, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync3(x);
      }
      return x;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync4, pkgfile) {
      var body = readFileSync4(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path4.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolveSync(x, options2) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options2);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync4 = opts.readFileSync || fs2.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync3 = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions3 = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path4.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync3, path4.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path4.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m)
          return maybeRealpathSync(realpathSync3, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n2 = loadNodeModulesSync(x, absoluteStart);
        if (n2)
          return maybeRealpathSync(realpathSync3, n2, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path4.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path4.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path4.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions3.length; i++) {
          var file = x2 + extensions3[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/")
          return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return;
        var pkgfile = path4.join(maybeRealpathSync(realpathSync3, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path4.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync4, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(
            pkg,
            /*pkgfile,*/
            dir
          );
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x2) {
        var pkgfile = path4.join(maybeRealpathSync(realpathSync3, x2, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync4, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(
              pkg,
              /*pkgfile,*/
              x2
            );
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m2 = loadAsFileSync(path4.resolve(x2, pkg.main));
              if (m2)
                return m2;
              var n3 = loadAsDirectorySync(path4.resolve(x2, pkg.main));
              if (n3)
                return n3;
            } catch (e) {
            }
          }
        }
        return loadAsFileSync(path4.join(x2, "/index"));
      }
      function loadNodeModulesSync(x2, start) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path4.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2)
              return m2;
            var n3 = loadAsDirectorySync(dir);
            if (n3)
              return n3;
          }
        }
      }
    };
  }
});

// node_modules/resolve/index.js
var require_resolve = __commonJS({
  "node_modules/resolve/index.js"(exports2, module2) {
    var async2 = require_async();
    async2.core = require_core3();
    async2.isCore = require_is_core();
    async2.sync = require_sync();
    module2.exports = async2;
  }
});

// node_modules/vite/dist/node/constants.js
var import_node_path, import_node_url, import_node_fs, import_meta, version, CSS_LANGS_RE, FS_PREFIX, VALID_ID_PREFIX, CLIENT_PUBLIC_PATH, ENV_PUBLIC_PATH, VITE_PACKAGE_DIR, CLIENT_ENTRY, ENV_ENTRY, CLIENT_DIR, KNOWN_ASSET_TYPES, DEFAULT_ASSETS_RE;
var init_constants = __esm({
  "node_modules/vite/dist/node/constants.js"() {
    import_node_path = __toESM(require("path"), 1);
    import_node_url = require("url");
    import_node_fs = require("fs");
    import_meta = {};
    ({ version } = JSON.parse((0, import_node_fs.readFileSync)(new URL("../../package.json", import_meta.url)).toString()));
    CSS_LANGS_RE = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
    FS_PREFIX = `/@fs/`;
    VALID_ID_PREFIX = `/@id/`;
    CLIENT_PUBLIC_PATH = `/@vite/client`;
    ENV_PUBLIC_PATH = `/@vite/env`;
    VITE_PACKAGE_DIR = (0, import_node_path.resolve)(
      // import.meta.url is `dist/node/constants.js` after bundle
      (0, import_node_url.fileURLToPath)(import_meta.url),
      "../../.."
    );
    CLIENT_ENTRY = (0, import_node_path.resolve)(VITE_PACKAGE_DIR, "dist/client/client.mjs");
    ENV_ENTRY = (0, import_node_path.resolve)(VITE_PACKAGE_DIR, "dist/client/env.mjs");
    CLIENT_DIR = import_node_path.default.dirname(CLIENT_ENTRY);
    KNOWN_ASSET_TYPES = [
      // images
      "png",
      "jpe?g",
      "jfif",
      "pjpeg",
      "pjp",
      "gif",
      "svg",
      "ico",
      "webp",
      "avif",
      // media
      "mp4",
      "webm",
      "ogg",
      "mp3",
      "wav",
      "flac",
      "aac",
      // fonts
      "woff2?",
      "eot",
      "ttf",
      "otf",
      // other
      "webmanifest",
      "pdf",
      "txt"
    ];
    DEFAULT_ASSETS_RE = new RegExp(`\\.(` + KNOWN_ASSET_TYPES.join("|") + `)(\\?.*)?$`);
  }
});

// node_modules/rollup/dist/es/shared/node-entry.js
function relative(from, to) {
  const fromParts = from.split(ANY_SLASH_REGEX).filter(Boolean);
  const toParts = to.split(ANY_SLASH_REGEX).filter(Boolean);
  if (fromParts[0] === ".")
    fromParts.shift();
  if (toParts[0] === ".")
    toParts.shift();
  while (fromParts[0] && toParts[0] && fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  while (toParts[0] === ".." && fromParts.length > 0) {
    toParts.shift();
    fromParts.pop();
  }
  while (fromParts.pop()) {
    toParts.unshift("..");
  }
  return toParts.join("/");
}
function escapeId(id) {
  if (!needsEscapeRegEx.test(id))
    return id;
  return id.replace(backSlashRegEx, "\\\\").replace(quoteNewlineRegEx, "\\$1");
}
function isAbsolute(path4) {
  return ABSOLUTE_PATH_REGEX.test(path4);
}
function relativeId(id) {
  if (!isAbsolute(id))
    return id;
  return relative((0, import_node_path2.resolve)(), id);
}
function getOrCreate(map2, key, init4) {
  const existing = map2.get(key);
  if (existing !== void 0) {
    return existing;
  }
  const value2 = init4();
  map2.set(key, value2);
  return value2;
}
function getNewSet() {
  return /* @__PURE__ */ new Set();
}
function errorIllegalImportReassignment(name2, importingId) {
  return {
    code: ILLEGAL_REASSIGNMENT,
    message: `Illegal reassignment of import "${name2}" in "${relativeId(importingId)}".`
  };
}
function errorModuleLevelDirective(directive, id) {
  return {
    code: MODULE_LEVEL_DIRECTIVE,
    id,
    message: `Module level directives cause errors when bundled, "${directive}" in "${relativeId(id)}" was ignored.`
  };
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function createInclusionContext() {
  return {
    brokenFlow: BROKEN_FLOW_NONE,
    includedCallArguments: /* @__PURE__ */ new Set(),
    includedLabels: /* @__PURE__ */ new Set()
  };
}
function createHasEffectsContext() {
  return {
    accessed: new PathTracker(),
    assigned: new PathTracker(),
    brokenFlow: BROKEN_FLOW_NONE,
    called: new DiscriminatedPathTracker(),
    ignore: {
      breaks: false,
      continues: false,
      labels: /* @__PURE__ */ new Set(),
      returnYield: false,
      this: false
    },
    includedLabels: /* @__PURE__ */ new Set(),
    instantiated: new DiscriminatedPathTracker(),
    replacedVariableInits: /* @__PURE__ */ new Map()
  };
}
function assembleMemberDescriptions(memberDescriptions, inheritedDescriptions = null) {
  return Object.create(inheritedDescriptions, memberDescriptions);
}
function hasMemberEffectWhenCalled(members, memberName, interaction, context) {
  if (typeof memberName !== "string" || !members[memberName]) {
    return true;
  }
  return members[memberName].hasEffectsWhenCalled?.(interaction, context) || false;
}
function getMemberReturnExpressionWhenCalled(members, memberName) {
  if (typeof memberName !== "string" || !members[memberName])
    return UNKNOWN_RETURN_EXPRESSION;
  return [members[memberName].returns, false];
}
function skipThrough(node2, st, c) {
  c(node2, st);
}
function ignore(_node, _st, _c) {
}
function getAndCreateKeys(esTreeNode) {
  keys[esTreeNode.type] = Object.keys(esTreeNode).filter(
    (key) => typeof esTreeNode[key] === "object" && key.charCodeAt(0) !== 95
    /* _ */
  );
  return keys[esTreeNode.type];
}
function toBase64(value2) {
  let outString = "";
  do {
    const currentDigit = value2 % base;
    value2 = value2 / base | 0;
    outString = chars2[currentDigit] + outString;
  } while (value2 !== 0);
  return outString;
}
function getSafeName(baseName, usedNames, forbiddenNames) {
  let safeName = baseName;
  let count = 1;
  while (usedNames.has(safeName) || RESERVED_NAMES$1.has(safeName) || forbiddenNames?.has(safeName)) {
    safeName = `${baseName}$${toBase64(count++)}`;
  }
  usedNames.add(safeName);
  return safeName;
}
function is_reference(node2, parent) {
  if (node2.type === "MemberExpression") {
    return !node2.computed && is_reference(node2.object, node2);
  }
  if (node2.type === "Identifier") {
    if (!parent)
      return true;
    switch (parent.type) {
      case "MemberExpression":
        return parent.computed || node2 === parent.object;
      case "MethodDefinition":
        return parent.computed;
      case "PropertyDefinition":
        return parent.computed || node2 === parent.value;
      case "Property":
        return parent.computed || node2 === parent.value;
      case "ExportSpecifier":
      case "ImportSpecifier":
        return node2 === parent.local;
      case "LabeledStatement":
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      default:
        return true;
    }
  }
  return false;
}
function getGlobalAtPath(path4) {
  let currentGlobal = knownGlobals;
  for (const pathSegment of path4) {
    if (typeof pathSegment !== "string") {
      return null;
    }
    currentGlobal = currentGlobal[pathSegment];
    if (!currentGlobal) {
      return null;
    }
  }
  return currentGlobal[ValueProperties];
}
function closestParentFunctionOrProgram(node2) {
  while (node2 && !/^Program|Function/.test(node2.type)) {
    node2 = node2.parent;
  }
  return node2;
}
function treeshakeNode(node2, code, start, end) {
  code.remove(start, end);
  if (node2.annotations) {
    for (const annotation of node2.annotations) {
      if (annotation.start < start) {
        code.remove(annotation.start, annotation.end);
      } else {
        return;
      }
    }
  }
}
function findFirstOccurrenceOutsideComment(code, searchString, start = 0) {
  let searchPos, charCodeAfterSlash;
  searchPos = code.indexOf(searchString, start);
  while (true) {
    start = code.indexOf("/", start);
    if (start === -1 || start >= searchPos)
      return searchPos;
    charCodeAfterSlash = code.charCodeAt(++start);
    ++start;
    start = charCodeAfterSlash === 47 ? code.indexOf("\n", start) + 1 : code.indexOf("*/", start) + 2;
    if (start > searchPos) {
      searchPos = code.indexOf(searchString, start);
    }
  }
}
function findNonWhiteSpace(code, index) {
  NON_WHITESPACE.lastIndex = index;
  const result = NON_WHITESPACE.exec(code);
  return result.index;
}
function findFirstLineBreakOutsideComment(code) {
  let lineBreakPos, charCodeAfterSlash, start = 0;
  lineBreakPos = code.indexOf("\n", start);
  while (true) {
    start = code.indexOf("/", start);
    if (start === -1 || start > lineBreakPos)
      return [lineBreakPos, lineBreakPos + 1];
    charCodeAfterSlash = code.charCodeAt(start + 1);
    if (charCodeAfterSlash === 47)
      return [start, lineBreakPos + 1];
    start = code.indexOf("*/", start + 3) + 2;
    if (start > lineBreakPos) {
      lineBreakPos = code.indexOf("\n", start);
    }
  }
}
function renderStatementList(statements, code, start, end, options2) {
  let currentNode, currentNodeStart, currentNodeNeedsBoundaries, nextNodeStart;
  let nextNode = statements[0];
  let nextNodeNeedsBoundaries = !nextNode.included || nextNode.needsBoundaries;
  if (nextNodeNeedsBoundaries) {
    nextNodeStart = start + findFirstLineBreakOutsideComment(code.original.slice(start, nextNode.start))[1];
  }
  for (let nextIndex3 = 1; nextIndex3 <= statements.length; nextIndex3++) {
    currentNode = nextNode;
    currentNodeStart = nextNodeStart;
    currentNodeNeedsBoundaries = nextNodeNeedsBoundaries;
    nextNode = statements[nextIndex3];
    nextNodeNeedsBoundaries = nextNode === void 0 ? false : !nextNode.included || nextNode.needsBoundaries;
    if (currentNodeNeedsBoundaries || nextNodeNeedsBoundaries) {
      nextNodeStart = currentNode.end + findFirstLineBreakOutsideComment(code.original.slice(currentNode.end, nextNode === void 0 ? end : nextNode.start))[1];
      if (currentNode.included) {
        currentNodeNeedsBoundaries ? currentNode.render(code, options2, {
          end: nextNodeStart,
          start: currentNodeStart
        }) : currentNode.render(code, options2);
      } else {
        treeshakeNode(currentNode, code, currentNodeStart, nextNodeStart);
      }
    } else {
      currentNode.render(code, options2);
    }
  }
}
function getSystemExportStatement(exportedVariables, { exportNamesByVariable, snippets: { _, getObject, getPropertyAccess } }, modifier = "") {
  if (exportedVariables.length === 1 && exportNamesByVariable.get(exportedVariables[0]).length === 1) {
    const variable = exportedVariables[0];
    return `exports('${exportNamesByVariable.get(variable)}',${_}${variable.getName(getPropertyAccess)}${modifier})`;
  } else {
    const fields = [];
    for (const variable of exportedVariables) {
      for (const exportName of exportNamesByVariable.get(variable)) {
        fields.push([exportName, variable.getName(getPropertyAccess) + modifier]);
      }
    }
    return `exports(${getObject(fields, { lineBreakIndent: null })})`;
  }
}
function getDeclarationStart(code, start) {
  return findNonWhiteSpace(code, findFirstOccurrenceOutsideComment(code, "default", start) + 7);
}
function getIdInsertPosition(code, declarationKeyword, endMarker, start) {
  const declarationEnd = findFirstOccurrenceOutsideComment(code, declarationKeyword, start) + declarationKeyword.length;
  code = code.slice(declarationEnd, findFirstOccurrenceOutsideComment(code, endMarker, declarationEnd));
  const generatorStarPos = findFirstOccurrenceOutsideComment(code, "*");
  if (generatorStarPos === -1) {
    return declarationEnd;
  }
  return declarationEnd + generatorStarPos + 1;
}
function getToStringTagValue(getObject) {
  return getObject([["value", "'Module'"]], {
    lineBreakIndent: null
  });
}
function isInAstralSet(code, set2) {
  var pos = 65536;
  for (var i = 0; i < set2.length; i += 2) {
    pos += set2[i];
    if (pos > code) {
      return false;
    }
    pos += set2[i + 1];
    if (pos >= code) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
function binop(name2, prec) {
  return new TokenType(name2, { beforeExpr: true, binop: prec });
}
function kw(name2, options2) {
  if (options2 === void 0)
    options2 = {};
  options2.keyword = name2;
  return keywords[name2] = new TokenType(name2, options2);
}
function isNewLine(code) {
  return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
  if (end === void 0)
    end = code.length;
  for (var i = from; i < end; i++) {
    var next = code.charCodeAt(i);
    if (isNewLine(next)) {
      return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}
function codePointToString(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
function getLineInfo(input, offset4) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset4);
    if (nextBreak < 0) {
      return new Position(line, offset4 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
function getOptions(opts) {
  var options2 = {};
  for (var opt in defaultOptions) {
    options2[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options2.ecmaVersion === "latest") {
    options2.ecmaVersion = 1e8;
  } else if (options2.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options2.ecmaVersion = 11;
  } else if (options2.ecmaVersion >= 2015) {
    options2.ecmaVersion -= 2009;
  }
  if (options2.allowReserved == null) {
    options2.allowReserved = options2.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options2.allowHashBang = options2.ecmaVersion >= 14;
  }
  if (isArray(options2.onToken)) {
    var tokens = options2.onToken;
    options2.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options2.onComment)) {
    options2.onComment = pushComment(options2, options2.onComment);
  }
  return options2;
}
function pushComment(options2, array2) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start,
      end
    };
    if (options2.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options2.ranges) {
      comment.range = [start, end];
    }
    array2.push(comment);
  };
}
function functionFlags(async2, generator) {
  return SCOPE_FUNCTION | (async2 ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
function isPrivateNameConflicted(privateNameMap, element) {
  var name2 = element.key.name;
  var curr = privateNameMap[name2];
  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name2] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name2] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node2, name2) {
  var computed = node2.computed;
  var key = node2.key;
  return !computed && (key.type === "Identifier" && key.name === name2 || key.type === "Literal" && key.value === name2);
}
function isPrivateFieldAccess(node2) {
  return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess(node2.expression);
}
function finishNodeAt(node2, type, pos, loc) {
  node2.type = type;
  node2.end = pos;
  if (this.options.locations) {
    node2.loc.end = loc;
  }
  if (this.options.ranges) {
    node2.range[1] = pos;
  }
  return node2;
}
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
var import_node_path2, import_path, import_node_process, import_node_perf_hooks, import_node_crypto, import_promises, import_node_events, tty, comma2, semicolon2, chars$1, intToChar2, charToInt2, ANY_SLASH_REGEX, needsEscapeRegEx, quoteNewlineRegEx, backSlashRegEx, ABSOLUTE_PATH_REGEX, UnknownKey, UnknownNonAccessorKey, UnknownInteger, SymbolToStringTag, EMPTY_PATH, UNKNOWN_PATH, UNKNOWN_NON_ACCESSOR_PATH, UNKNOWN_INTEGER_PATH, EntitiesKey, PathTracker, SHARED_RECURSION_TRACKER, DiscriminatedPathTracker, UnknownValue, UnknownTruthyValue, ExpressionEntity, UNKNOWN_EXPRESSION, UNKNOWN_RETURN_EXPRESSION, deoptimizeInteraction, INTERACTION_ACCESSED, INTERACTION_ASSIGNED, INTERACTION_CALLED, NODE_INTERACTION_UNKNOWN_ACCESS, UNKNOWN_ARG, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, NO_ARGS, NODE_INTERACTION_UNKNOWN_CALL, Variable, BLANK, EMPTY_OBJECT, EMPTY_ARRAY, ILLEGAL_REASSIGNMENT, MODULE_LEVEL_DIRECTIVE, RESERVED_NAMES, RESERVED_NAMES$1, picomatchExports, picomatch$1, utils$3, path$1, WIN_SLASH, WIN_NO_SLASH, DOT_LITERAL, PLUS_LITERAL, QMARK_LITERAL, SLASH_LITERAL, ONE_CHAR, QMARK, END_ANCHOR, START_ANCHOR, DOTS_SLASH, NO_DOT, NO_DOTS, NO_DOT_SLASH, NO_DOTS_SLASH, QMARK_NO_DOT, STAR, POSIX_CHARS, WINDOWS_CHARS, POSIX_REGEX_SOURCE$1, constants$2, utils$2, CHAR_ASTERISK, CHAR_AT, CHAR_BACKWARD_SLASH, CHAR_COMMA, CHAR_DOT, CHAR_EXCLAMATION_MARK, CHAR_FORWARD_SLASH, CHAR_LEFT_CURLY_BRACE, CHAR_LEFT_PARENTHESES, CHAR_LEFT_SQUARE_BRACKET, CHAR_PLUS, CHAR_QUESTION_MARK, CHAR_RIGHT_CURLY_BRACE, CHAR_RIGHT_PARENTHESES, CHAR_RIGHT_SQUARE_BRACKET, isPathSeparator, depth, scan$1, scan_1, constants$1, utils$1, MAX_LENGTH, POSIX_REGEX_SOURCE, REGEX_NON_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS, expandRange, syntaxError, parse$2, parse_1, path2, scan, parse$1, utils, constants, isObject2, picomatch, picomatch_1, reservedWords$1, builtins, forbiddenIdentifiers, BROKEN_FLOW_NONE, UNDEFINED_EXPRESSION, returnsUnknown, UNKNOWN_LITERAL_BOOLEAN, returnsBoolean, UNKNOWN_LITERAL_NUMBER, returnsNumber, UNKNOWN_LITERAL_STRING, returnsString, stringReplace, objectMembers, literalBooleanMembers, literalNumberMembers, literalRegExpMembers, literalStringMembers, base$1, BlockStatement$1, CallExpression$1, ExpressionStatement$1, Program$1, ReturnStatement$1, SOURCEMAPPING_URL, whiteSpaceNoNewline, SOURCEMAPPING_URL_RE, ANNOTATION_KEY, INVALID_COMMENT_KEY, keys, NodeBase, SpreadElement, Method, METHOD_RETURNS_BOOLEAN, METHOD_RETURNS_STRING, METHOD_RETURNS_NUMBER, METHOD_RETURNS_UNKNOWN, INTEGER_REG_EXP, ObjectEntity, isInteger, OBJECT_PROTOTYPE_FALLBACK, OBJECT_PROTOTYPE, NEW_ARRAY_PROPERTIES, METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN, METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER, METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY, METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY, METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY, METHOD_MUTATES_SELF_RETURNS_NUMBER, METHOD_MUTATES_SELF_RETURNS_UNKNOWN, METHOD_DEOPTS_SELF_RETURNS_UNKNOWN, METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN, METHOD_MUTATES_SELF_RETURNS_SELF, METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF, ARRAY_PROTOTYPE, LocalVariable, ParameterVariable, chars2, base, Scope$1, ChildScope, ParameterScope, ReturnValueScope, PureFunctionKey, doNothing, ValueProperties, getTruthyLiteralValue, returnFalse, returnTrue, PURE, IMPURE, O, PF, MUTATES_ARG_WITHOUT_ACCESSOR, C2, PC, ARRAY_TYPE, INTL_MEMBER, knownGlobals, GlobalVariable, tdzVariableKinds, Identifier, NON_WHITESPACE, BlockScope, ExpressionStatement, BlockStatement, RestElement, FunctionBase, ArgumentsVariable, ThisVariable, FunctionScope, FunctionNode, MethodBase, MethodDefinition, ObjectMember, ClassNode, ClassDeclaration, ExportAllDeclaration, FunctionDeclaration, ExportDefaultDeclaration, ExportNamedDeclaration, unset, ImportDeclaration, INTEROP_DEFAULT_VARIABLE, INTEROP_DEFAULT_COMPAT_VARIABLE, INTEROP_NAMESPACE_VARIABLE, INTEROP_NAMESPACE_COMPAT_VARIABLE, INTEROP_NAMESPACE_DEFAULT_VARIABLE, INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE, MERGE_NAMESPACES_VARIABLE, HELPER_GENERATORS, getDefaultLiveBinding, getDefaultStatic, getIsCompatNamespace, createNamespaceObject, loopOverKeys, loopOverNamespaces, copyNonDefaultOwnPropertyLiveBinding, copyOwnPropertyLiveBinding, copyPropertyLiveBinding, copyPropertyStatic, getFrozen, getWithToStringTag, HELPER_NAMES, getResolveUrl, getGenericImportMetaMechanism, getFileUrlFromFullPath, getUrlFromDocument, importMetaMechanisms, SwitchCase, NamespaceVariable, BuildPhase, _staticExports, _static, require$$0, builtinModules, nodeBuiltins, hashPlaceholderLeft, hashPlaceholderRight, hashPlaceholderOverhead, maxHashSize, REPLACER_REGEX, lowercaseBundleKeys, astralIdentifierCodes, astralIdentifierStartCodes, nonASCIIidentifierChars, nonASCIIidentifierStartChars, reservedWords, ecma5AndLessKeywords, keywords$1, keywordRelationalOperator, nonASCIIidentifierStart, nonASCIIidentifier, TokenType, beforeExpr, startsExpr, keywords, types$1, lineBreak, lineBreakG, nonASCIIwhitespace, skipWhiteSpace, ref, hasOwnProperty, toString2, hasOwn, isArray, loneSurrogate, Position, SourceLocation, defaultOptions, warnedAboutEcmaVersion, SCOPE_TOP, SCOPE_FUNCTION, SCOPE_ASYNC, SCOPE_GENERATOR, SCOPE_ARROW, SCOPE_SIMPLE_CATCH, SCOPE_SUPER, SCOPE_DIRECT_SUPER, SCOPE_CLASS_STATIC_BLOCK, SCOPE_VAR, BIND_NONE, BIND_VAR, BIND_LEXICAL, BIND_FUNCTION, BIND_SIMPLE_CATCH, BIND_OUTSIDE, Parser, prototypeAccessors, pp$9, literal, DestructuringErrors, pp$8, loopLabel, switchLabel, empty$1, FUNC_STATEMENT$1, FUNC_HANGING_STATEMENT, FUNC_NULLABLE_ID$1, pp$7, TokContext, types, pp$6, pp$5, empty, pp$4, pp$3, Scope2, Node, pp$2, ecma9BinaryProperties, ecma10BinaryProperties, ecma11BinaryProperties, ecma12BinaryProperties, ecma13BinaryProperties, ecma14BinaryProperties, unicodeBinaryProperties, unicodeGeneralCategoryValues, ecma9ScriptValues, ecma10ScriptValues, ecma11ScriptValues, ecma12ScriptValues, ecma13ScriptValues, ecma14ScriptValues, unicodeScriptValues, data, ecmaVersion, i, list, pp$1, RegExpValidationState, Token, pp, INVALID_TEMPLATE_ESCAPE_ERROR, version2, inputHookNames, inputHooks, beforeExitEvent, beforeExitEmitter, leftCurlyBrace, space, SortingFileType, env, argv, platform, isDisabled, isForced, isWindows, isDumbTerminal, isCompatibleTerminal, isCI, isColorSupported, replaceClose, clearBleed, filterEmpty, init2, colors, createColors, bold, cyan, dim, gray, green, red, underline, yellow;
var init_node_entry = __esm({
  "node_modules/rollup/dist/es/shared/node-entry.js"() {
    import_node_path2 = require("path");
    import_path = __toESM(require("path"), 1);
    import_node_process = __toESM(require("process"), 1);
    import_node_perf_hooks = require("perf_hooks");
    import_node_crypto = require("crypto");
    import_promises = require("fs/promises");
    import_node_events = require("events");
    tty = __toESM(require("tty"), 1);
    comma2 = ",".charCodeAt(0);
    semicolon2 = ";".charCodeAt(0);
    chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    intToChar2 = new Uint8Array(64);
    charToInt2 = new Uint8Array(128);
    for (let i = 0; i < chars$1.length; i++) {
      const c = chars$1.charCodeAt(i);
      intToChar2[i] = c;
      charToInt2[c] = i;
    }
    ANY_SLASH_REGEX = /[/\\]/;
    needsEscapeRegEx = /[\n\r'\\\u2028\u2029]/;
    quoteNewlineRegEx = /([\n\r'\u2028\u2029])/g;
    backSlashRegEx = /\\/g;
    ABSOLUTE_PATH_REGEX = /^(?:\/|(?:[A-Za-z]:)?[/\\|])/;
    UnknownKey = Symbol("Unknown Key");
    UnknownNonAccessorKey = Symbol("Unknown Non-Accessor Key");
    UnknownInteger = Symbol("Unknown Integer");
    SymbolToStringTag = Symbol("Symbol.toStringTag");
    EMPTY_PATH = [];
    UNKNOWN_PATH = [UnknownKey];
    UNKNOWN_NON_ACCESSOR_PATH = [UnknownNonAccessorKey];
    UNKNOWN_INTEGER_PATH = [UnknownInteger];
    EntitiesKey = Symbol("Entities");
    PathTracker = class {
      constructor() {
        this.entityPaths = Object.create(null, {
          [EntitiesKey]: { value: /* @__PURE__ */ new Set() }
        });
      }
      trackEntityAtPathAndGetIfTracked(path4, entity) {
        const trackedEntities = this.getEntities(path4);
        if (trackedEntities.has(entity))
          return true;
        trackedEntities.add(entity);
        return false;
      }
      withTrackedEntityAtPath(path4, entity, onUntracked, returnIfTracked) {
        const trackedEntities = this.getEntities(path4);
        if (trackedEntities.has(entity))
          return returnIfTracked;
        trackedEntities.add(entity);
        const result = onUntracked();
        trackedEntities.delete(entity);
        return result;
      }
      getEntities(path4) {
        let currentPaths = this.entityPaths;
        for (const pathSegment of path4) {
          currentPaths = currentPaths[pathSegment] = currentPaths[pathSegment] || Object.create(null, { [EntitiesKey]: { value: /* @__PURE__ */ new Set() } });
        }
        return currentPaths[EntitiesKey];
      }
    };
    SHARED_RECURSION_TRACKER = new PathTracker();
    DiscriminatedPathTracker = class {
      constructor() {
        this.entityPaths = Object.create(null, {
          [EntitiesKey]: { value: /* @__PURE__ */ new Map() }
        });
      }
      trackEntityAtPathAndGetIfTracked(path4, discriminator, entity) {
        let currentPaths = this.entityPaths;
        for (const pathSegment of path4) {
          currentPaths = currentPaths[pathSegment] = currentPaths[pathSegment] || Object.create(null, { [EntitiesKey]: { value: /* @__PURE__ */ new Map() } });
        }
        const trackedEntities = getOrCreate(currentPaths[EntitiesKey], discriminator, getNewSet);
        if (trackedEntities.has(entity))
          return true;
        trackedEntities.add(entity);
        return false;
      }
    };
    UnknownValue = Symbol("Unknown Value");
    UnknownTruthyValue = Symbol("Unknown Truthy Value");
    ExpressionEntity = class {
      constructor() {
        this.included = false;
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, _path, _recursionTracker) {
        deoptimizeInteraction(interaction);
      }
      deoptimizePath(_path) {
      }
      /**
       * If possible it returns a stringifyable literal value for this node that
       * can be used for inlining or comparing values. Otherwise, it should return
       * UnknownValue.
       */
      getLiteralValueAtPath(_path, _recursionTracker, _origin) {
        return UnknownValue;
      }
      getReturnExpressionWhenCalledAtPath(_path, _interaction, _recursionTracker, _origin) {
        return UNKNOWN_RETURN_EXPRESSION;
      }
      hasEffectsOnInteractionAtPath(_path, _interaction, _context) {
        return true;
      }
      include(_context, _includeChildrenRecursively, _options) {
        this.included = true;
      }
      includeCallArguments(context, parameters) {
        for (const argument of parameters) {
          argument.include(context, false);
        }
      }
      shouldBeIncluded(_context) {
        return true;
      }
    };
    UNKNOWN_EXPRESSION = new class UnknownExpression extends ExpressionEntity {
    }();
    UNKNOWN_RETURN_EXPRESSION = [
      UNKNOWN_EXPRESSION,
      false
    ];
    deoptimizeInteraction = (interaction) => {
      interaction.thisArg?.deoptimizePath(UNKNOWN_PATH);
      if (interaction.args) {
        for (const argument of interaction.args) {
          argument.deoptimizePath(UNKNOWN_PATH);
        }
      }
    };
    INTERACTION_ACCESSED = 0;
    INTERACTION_ASSIGNED = 1;
    INTERACTION_CALLED = 2;
    NODE_INTERACTION_UNKNOWN_ACCESS = {
      args: null,
      thisArg: null,
      type: INTERACTION_ACCESSED
    };
    UNKNOWN_ARG = [UNKNOWN_EXPRESSION];
    NODE_INTERACTION_UNKNOWN_ASSIGNMENT = {
      args: UNKNOWN_ARG,
      thisArg: null,
      type: INTERACTION_ASSIGNED
    };
    NO_ARGS = [];
    NODE_INTERACTION_UNKNOWN_CALL = {
      args: NO_ARGS,
      thisArg: null,
      type: INTERACTION_CALLED,
      withNew: false
    };
    Variable = class extends ExpressionEntity {
      constructor(name2) {
        super();
        this.name = name2;
        this.alwaysRendered = false;
        this.forbiddenNames = null;
        this.initReached = false;
        this.isId = false;
        this.isReassigned = false;
        this.kind = null;
        this.renderBaseName = null;
        this.renderName = null;
      }
      /**
       * Binds identifiers that reference this variable to this variable.
       * Necessary to be able to change variable names.
       */
      addReference(_identifier) {
      }
      /**
       * Prevent this variable from being renamed to this name to avoid name
       * collisions
       */
      forbidName(name2) {
        (this.forbiddenNames || (this.forbiddenNames = /* @__PURE__ */ new Set())).add(name2);
      }
      getBaseVariableName() {
        return this.renderBaseName || this.renderName || this.name;
      }
      getName(getPropertyAccess, useOriginalName) {
        if (useOriginalName?.(this)) {
          return this.name;
        }
        const name2 = this.renderName || this.name;
        return this.renderBaseName ? `${this.renderBaseName}${getPropertyAccess(name2)}` : name2;
      }
      hasEffectsOnInteractionAtPath(path4, { type }, _context) {
        return type !== INTERACTION_ACCESSED || path4.length > 0;
      }
      /**
       * Marks this variable as being part of the bundle, which is usually the case when one of
       * its identifiers becomes part of the bundle. Returns true if it has not been included
       * previously.
       * Once a variable is included, it should take care all its declarations are included.
       */
      include() {
        this.included = true;
      }
      markCalledFromTryStatement() {
      }
      setRenderNames(baseName, name2) {
        this.renderBaseName = baseName;
        this.renderName = name2;
      }
    };
    BLANK = Object.freeze(/* @__PURE__ */ Object.create(null));
    EMPTY_OBJECT = Object.freeze({});
    EMPTY_ARRAY = Object.freeze([]);
    ILLEGAL_REASSIGNMENT = "ILLEGAL_REASSIGNMENT";
    MODULE_LEVEL_DIRECTIVE = "MODULE_LEVEL_DIRECTIVE";
    RESERVED_NAMES = /* @__PURE__ */ new Set([
      "await",
      "break",
      "case",
      "catch",
      "class",
      "const",
      "continue",
      "debugger",
      "default",
      "delete",
      "do",
      "else",
      "enum",
      "eval",
      "export",
      "extends",
      "false",
      "finally",
      "for",
      "function",
      "if",
      "implements",
      "import",
      "in",
      "instanceof",
      "interface",
      "let",
      "NaN",
      "new",
      "null",
      "package",
      "private",
      "protected",
      "public",
      "return",
      "static",
      "super",
      "switch",
      "this",
      "throw",
      "true",
      "try",
      "typeof",
      "undefined",
      "var",
      "void",
      "while",
      "with",
      "yield"
    ]);
    RESERVED_NAMES$1 = RESERVED_NAMES;
    picomatchExports = {};
    picomatch$1 = {
      get exports() {
        return picomatchExports;
      },
      set exports(v) {
        picomatchExports = v;
      }
    };
    utils$3 = {};
    path$1 = import_path.default;
    WIN_SLASH = "\\\\/";
    WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    DOT_LITERAL = "\\.";
    PLUS_LITERAL = "\\+";
    QMARK_LITERAL = "\\?";
    SLASH_LITERAL = "\\/";
    ONE_CHAR = "(?=.)";
    QMARK = "[^/]";
    END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    NO_DOT = `(?!${DOT_LITERAL})`;
    NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    STAR = `${QMARK}*?`;
    POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    POSIX_REGEX_SOURCE$1 = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    constants$2 = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path$1.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars4) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars4.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win323) {
        return win323 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
    (function(exports2) {
      const path4 = import_path.default;
      const win323 = process.platform === "win32";
      const {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL
      } = constants$2;
      exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
      exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
      exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
      exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
      exports2.removeBackslashes = (str) => {
        return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
          return match === "\\" ? "" : match;
        });
      };
      exports2.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split(".").map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
          return true;
        }
        return false;
      };
      exports2.isWindows = (options2) => {
        if (options2 && typeof options2.windows === "boolean") {
          return options2.windows;
        }
        return win323 === true || path4.sep === "\\";
      };
      exports2.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1)
          return input;
        if (input[idx - 1] === "\\")
          return exports2.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
      };
      exports2.removePrefix = (input, state = {}) => {
        let output = input;
        if (output.startsWith("./")) {
          output = output.slice(2);
          state.prefix = "./";
        }
        return output;
      };
      exports2.wrapOutput = (input, state = {}, options2 = {}) => {
        const prepend = options2.contains ? "" : "^";
        const append2 = options2.contains ? "" : "$";
        let output = `${prepend}(?:${input})${append2}`;
        if (state.negated === true) {
          output = `(?:^(?!${output}).*$)`;
        }
        return output;
      };
    })(utils$3);
    utils$2 = utils$3;
    ({
      CHAR_ASTERISK,
      CHAR_AT: (
        /* * */
        CHAR_AT
      ),
      CHAR_BACKWARD_SLASH: (
        /* @ */
        CHAR_BACKWARD_SLASH
      ),
      CHAR_COMMA: (
        /* \ */
        CHAR_COMMA
      ),
      CHAR_DOT: (
        /* , */
        CHAR_DOT
      ),
      CHAR_EXCLAMATION_MARK: (
        /* . */
        CHAR_EXCLAMATION_MARK
      ),
      CHAR_FORWARD_SLASH: (
        /* ! */
        CHAR_FORWARD_SLASH
      ),
      CHAR_LEFT_CURLY_BRACE: (
        /* / */
        CHAR_LEFT_CURLY_BRACE
      ),
      CHAR_LEFT_PARENTHESES: (
        /* { */
        CHAR_LEFT_PARENTHESES
      ),
      CHAR_LEFT_SQUARE_BRACKET: (
        /* ( */
        CHAR_LEFT_SQUARE_BRACKET
      ),
      CHAR_PLUS: (
        /* [ */
        CHAR_PLUS
      ),
      CHAR_QUESTION_MARK: (
        /* + */
        CHAR_QUESTION_MARK
      ),
      CHAR_RIGHT_CURLY_BRACE: (
        /* ? */
        CHAR_RIGHT_CURLY_BRACE
      ),
      CHAR_RIGHT_PARENTHESES: (
        /* } */
        CHAR_RIGHT_PARENTHESES
      ),
      CHAR_RIGHT_SQUARE_BRACKET: (
        /* ) */
        CHAR_RIGHT_SQUARE_BRACKET
      )
    } = constants$2);
    isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    scan$1 = (input, options2) => {
      const opts = options2 || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob3 = false;
      let isExtglob3 = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces2 = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance3 = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance3();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance3();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces2++;
          while (eos() !== true && (code = advance3())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance3();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces2++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance3()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob3 = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob3 = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces2--;
              if (braces2 === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob3 = token.isGlob = true;
            isExtglob3 = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance3())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance3();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob3 = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob3 = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob3 = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance3())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance3();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob3 = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob3 = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance3())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance3();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob3 === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob3 = false;
        isGlob3 = false;
      }
      let base3 = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base3 && isGlob3 === true && lastIndex > 0) {
        base3 = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob3 === true) {
        base3 = "";
        glob = str;
      } else {
        base3 = str;
      }
      if (base3 && base3 !== "" && base3 !== "/" && base3 !== str) {
        if (isPathSeparator(base3.charCodeAt(base3.length - 1))) {
          base3 = base3.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils$2.removeBackslashes(glob);
        if (base3 && backslashes === true) {
          base3 = utils$2.removeBackslashes(base3);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base: base3,
        glob,
        isBrace,
        isBracket,
        isGlob: isGlob3,
        isExtglob: isExtglob3,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n2 = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value2 = input.slice(n2, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value2;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value2 !== "") {
            parts.push(value2);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value2 = input.slice(prevIndex + 1);
          parts.push(value2);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value2;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    scan_1 = scan$1;
    constants$1 = constants$2;
    utils$1 = utils$3;
    ({
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants$1);
    expandRange = (args, options2) => {
      if (typeof options2.expandRange === "function") {
        return options2.expandRange(...args, options2);
      }
      args.sort();
      const value2 = `[${args.join("-")}]`;
      return value2;
    };
    syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    parse$2 = (input, options2) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options2 };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win323 = utils$1.isWindows(options2);
      const PLATFORM_CHARS = constants$1.globChars(win323);
      const EXTGLOB_CHARS = constants$1.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL: DOT_LITERAL3,
        PLUS_LITERAL: PLUS_LITERAL3,
        SLASH_LITERAL: SLASH_LITERAL3,
        ONE_CHAR: ONE_CHAR3,
        DOTS_SLASH: DOTS_SLASH3,
        NO_DOT: NO_DOT3,
        NO_DOT_SLASH: NO_DOT_SLASH3,
        NO_DOTS_SLASH: NO_DOTS_SLASH3,
        QMARK: QMARK3,
        QMARK_NO_DOT: QMARK_NO_DOT3,
        STAR: STAR3,
        START_ANCHOR: START_ANCHOR3
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR3}${opts2.dot ? DOTS_SLASH3 : DOT_LITERAL3}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT3;
      const qmarkNoDot = opts.dot ? QMARK3 : QMARK_NO_DOT3;
      let star2 = opts.bash === true ? globstar(opts) : STAR3;
      if (opts.capture) {
        star2 = `(${star2})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils$1.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces2 = [];
      const stack = [];
      let prev = bos;
      let value2;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n2 = 1) => input[state.index + n2];
      const advance3 = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value3 = "", num = 0) => {
        state.consumed += value3;
        state.index += num;
      };
      const append2 = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance3();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push2 = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob3 = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob3) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star2;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append2(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value3) => {
        const token = { ...EXTGLOB_CHARS[value3], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push2({ type, value: value3, output: state.output ? "" : ONE_CHAR3 });
        push2({ type: "paren", extglob: true, value: advance3(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star2;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star2 || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse$2(rest, { ...options2, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push2({ type: "paren", extglob: true, value: value2, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars4, first2, rest, index) => {
          if (first2 === "\\") {
            backslashes = true;
            return m;
          }
          if (first2 === "?") {
            if (esc) {
              return esc + first2 + (rest ? QMARK3.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK3.repeat(rest.length) : "");
            }
            return QMARK3.repeat(chars4.length);
          }
          if (first2 === ".") {
            return DOT_LITERAL3.repeat(chars4.length);
          }
          if (first2 === "*") {
            if (esc) {
              return esc + first2 + (rest ? star2 : "");
            }
            return star2;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils$1.wrapOutput(output, state, options2);
        return state;
      }
      while (!eos()) {
        value2 = advance3();
        if (value2 === "\0") {
          continue;
        }
        if (value2 === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value2 += "\\";
            push2({ type: "text", value: value2 });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value2 += "\\";
            }
          }
          if (opts.unescape === true) {
            value2 = advance3();
          } else {
            value2 += advance3();
          }
          if (state.brackets === 0) {
            push2({ type: "text", value: value2 });
            continue;
          }
        }
        if (state.brackets > 0 && (value2 !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value2 === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix3 = POSIX_REGEX_SOURCE[rest2];
                if (posix3) {
                  prev.value = pre + posix3;
                  state.backtrack = true;
                  advance3();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR3;
                  }
                  continue;
                }
              }
            }
          }
          if (value2 === "[" && peek() !== ":" || value2 === "-" && peek() === "]") {
            value2 = `\\${value2}`;
          }
          if (value2 === "]" && (prev.value === "[" || prev.value === "[^")) {
            value2 = `\\${value2}`;
          }
          if (opts.posix === true && value2 === "!" && prev.value === "[") {
            value2 = "^";
          }
          prev.value += value2;
          append2({ value: value2 });
          continue;
        }
        if (state.quotes === 1 && value2 !== '"') {
          value2 = utils$1.escapeRegex(value2);
          prev.value += value2;
          append2({ value: value2 });
          continue;
        }
        if (value2 === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push2({ type: "text", value: value2 });
          }
          continue;
        }
        if (value2 === "(") {
          increment("parens");
          push2({ type: "paren", value: value2 });
          continue;
        }
        if (value2 === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push2({ type: "paren", value: value2, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value2 === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value2 = `\\${value2}`;
          } else {
            increment("brackets");
          }
          push2({ type: "bracket", value: value2 });
          continue;
        }
        if (value2 === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push2({ type: "text", value: value2, output: `\\${value2}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push2({ type: "text", value: value2, output: `\\${value2}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value2 = `/${value2}`;
          }
          prev.value += value2;
          append2({ value: value2 });
          if (opts.literalBrackets === false || utils$1.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped2 = utils$1.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped2;
            prev.value = escaped2;
            continue;
          }
          prev.value = `(${capture}${escaped2}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value2 === "{" && opts.nobrace !== true) {
          increment("braces");
          const open2 = {
            type: "brace",
            value: value2,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces2.push(open2);
          push2(open2);
          continue;
        }
        if (value2 === "}") {
          const brace = braces2[braces2.length - 1];
          if (opts.nobrace === true || !brace) {
            push2({ type: "text", value: value2, output: value2 });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value2 = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push2({ type: "brace", value: value2, output });
          decrement("braces");
          braces2.pop();
          continue;
        }
        if (value2 === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === ",") {
          let output = value2;
          const brace = braces2[braces2.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push2({ type: "comma", value: value2, output });
          continue;
        }
        if (value2 === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push2({ type: "slash", value: value2, output: SLASH_LITERAL3 });
          continue;
        }
        if (value2 === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL3;
            const brace = braces2[braces2.length - 1];
            prev.type = "dots";
            prev.output += value2;
            prev.value += value2;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push2({ type: "text", value: value2, output: DOT_LITERAL3 });
            continue;
          }
          push2({ type: "dot", value: value2, output: DOT_LITERAL3 });
          continue;
        }
        if (value2 === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value2);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value2;
            if (next === "<" && !utils$1.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value2}`;
            }
            push2({ type: "text", value: value2, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push2({ type: "qmark", value: value2, output: QMARK_NO_DOT3 });
            continue;
          }
          push2({ type: "qmark", value: value2, output: QMARK3 });
          continue;
        }
        if (value2 === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value2);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value2 === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value2);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push2({ type: "plus", value: value2, output: PLUS_LITERAL3 });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push2({ type: "plus", value: value2 });
            continue;
          }
          push2({ type: "plus", value: PLUS_LITERAL3 });
          continue;
        }
        if (value2 === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push2({ type: "at", extglob: true, value: value2, output: "" });
            continue;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 !== "*") {
          if (value2 === "$" || value2 === "^") {
            value2 = `\\${value2}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value2 += match[0];
            state.index += match[0].length;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value2;
          prev.output = star2;
          state.backtrack = true;
          state.globstar = true;
          consume(value2);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value2);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value2);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push2({ type: "star", value: value2, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob3 = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob3) {
            push2({ type: "star", value: value2, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value2;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value2);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value2;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value2);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL3}|${SLASH_LITERAL3}${end})`;
            prev.value += value2;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value2 + advance3());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value2;
            prev.output = `(?:^|${SLASH_LITERAL3}|${globstar(opts)}${SLASH_LITERAL3})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value2 + advance3());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value2;
          state.output += prev.output;
          state.globstar = true;
          consume(value2);
          continue;
        }
        const token = { type: "star", value: value2, output: star2 };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push2(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value2;
          push2(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH3;
            prev.output += NO_DOT_SLASH3;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH3;
            prev.output += NO_DOTS_SLASH3;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR3;
            prev.output += ONE_CHAR3;
          }
        }
        push2(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils$1.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils$1.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils$1.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL3}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse$2.fastpaths = (input, options2) => {
      const opts = { ...options2 };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win323 = utils$1.isWindows(options2);
      const {
        DOT_LITERAL: DOT_LITERAL3,
        SLASH_LITERAL: SLASH_LITERAL3,
        ONE_CHAR: ONE_CHAR3,
        DOTS_SLASH: DOTS_SLASH3,
        NO_DOT: NO_DOT3,
        NO_DOTS: NO_DOTS3,
        NO_DOTS_SLASH: NO_DOTS_SLASH3,
        STAR: STAR3,
        START_ANCHOR: START_ANCHOR3
      } = constants$1.globChars(win323);
      const nodot = opts.dot ? NO_DOTS3 : NO_DOT3;
      const slashDot = opts.dot ? NO_DOTS_SLASH3 : NO_DOT3;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star2 = opts.bash === true ? ".*?" : STAR3;
      if (opts.capture) {
        star2 = `(${star2})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star2;
        return `(${capture}(?:(?!${START_ANCHOR3}${opts2.dot ? DOTS_SLASH3 : DOT_LITERAL3}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR3}${star2}`;
          case ".*":
            return `${DOT_LITERAL3}${ONE_CHAR3}${star2}`;
          case "*.*":
            return `${nodot}${star2}${DOT_LITERAL3}${ONE_CHAR3}${star2}`;
          case "*/*":
            return `${nodot}${star2}${SLASH_LITERAL3}${ONE_CHAR3}${slashDot}${star2}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL3})?${slashDot}${ONE_CHAR3}${star2}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL3})?${slashDot}${star2}${DOT_LITERAL3}${ONE_CHAR3}${star2}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL3})?${DOT_LITERAL3}${ONE_CHAR3}${star2}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL3 + match[2];
          }
        }
      };
      const output = utils$1.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL3}?`;
      }
      return source;
    };
    parse_1 = parse$2;
    path2 = import_path.default;
    scan = scan_1;
    parse$1 = parse_1;
    utils = utils$3;
    constants = constants$2;
    isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
    picomatch = (glob, options2, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options2, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject2(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options2 || {};
      const posix3 = utils.isWindows(options2);
      const regex = isState ? picomatch.compileRe(glob, options2) : picomatch.makeRe(glob, options2, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored2 = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options2, ignore: null, onMatch: null, onResult: null };
        isIgnored2 = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher2 = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options2, { glob, posix: posix3 });
        const result = { glob, state, regex, posix: posix3, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored2(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher2.state = state;
      }
      return matcher2;
    };
    picomatch.test = (input, regex, options2, { glob, posix: posix3 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options2 || {};
      const format2 = opts.format || (posix3 ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format2 ? format2(input) : input;
      if (match === false) {
        output = format2 ? format2(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options2, posix3);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options2, posix3 = utils.isWindows(options2)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options2);
      return regex.test(path2.basename(input));
    };
    picomatch.isMatch = (str, patterns2, options2) => picomatch(patterns2, options2)(str);
    picomatch.parse = (pattern2, options2) => {
      if (Array.isArray(pattern2))
        return pattern2.map((p) => picomatch.parse(p, options2));
      return parse$1(pattern2, { ...options2, fastpaths: false });
    };
    picomatch.scan = (input, options2) => scan(input, options2);
    picomatch.compileRe = (state, options2, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options2 || {};
      const prepend = opts.contains ? "" : "^";
      const append2 = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append2}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options2);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options2 = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options2.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse$1.fastpaths(input, options2);
      }
      if (!parsed.output) {
        parsed = parse$1(input, options2);
      }
      return picomatch.compileRe(parsed, options2, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options2) => {
      try {
        const opts = options2 || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options2 && options2.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    picomatch_1 = picomatch;
    (function(module2) {
      module2.exports = picomatch_1;
    })(picomatch$1);
    reservedWords$1 = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
    builtins = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
    forbiddenIdentifiers = new Set(`${reservedWords$1} ${builtins}`.split(" "));
    forbiddenIdentifiers.add("");
    BROKEN_FLOW_NONE = 0;
    UNDEFINED_EXPRESSION = new class UndefinedExpression extends ExpressionEntity {
      getLiteralValueAtPath() {
        return void 0;
      }
    }();
    returnsUnknown = {
      value: {
        hasEffectsWhenCalled: null,
        returns: UNKNOWN_EXPRESSION
      }
    };
    UNKNOWN_LITERAL_BOOLEAN = new class UnknownBoolean extends ExpressionEntity {
      getReturnExpressionWhenCalledAtPath(path4) {
        if (path4.length === 1) {
          return getMemberReturnExpressionWhenCalled(literalBooleanMembers, path4[0]);
        }
        return UNKNOWN_RETURN_EXPRESSION;
      }
      hasEffectsOnInteractionAtPath(path4, interaction, context) {
        if (interaction.type === INTERACTION_ACCESSED) {
          return path4.length > 1;
        }
        if (interaction.type === INTERACTION_CALLED && path4.length === 1) {
          return hasMemberEffectWhenCalled(literalBooleanMembers, path4[0], interaction, context);
        }
        return true;
      }
    }();
    returnsBoolean = {
      value: {
        hasEffectsWhenCalled: null,
        returns: UNKNOWN_LITERAL_BOOLEAN
      }
    };
    UNKNOWN_LITERAL_NUMBER = new class UnknownNumber extends ExpressionEntity {
      getReturnExpressionWhenCalledAtPath(path4) {
        if (path4.length === 1) {
          return getMemberReturnExpressionWhenCalled(literalNumberMembers, path4[0]);
        }
        return UNKNOWN_RETURN_EXPRESSION;
      }
      hasEffectsOnInteractionAtPath(path4, interaction, context) {
        if (interaction.type === INTERACTION_ACCESSED) {
          return path4.length > 1;
        }
        if (interaction.type === INTERACTION_CALLED && path4.length === 1) {
          return hasMemberEffectWhenCalled(literalNumberMembers, path4[0], interaction, context);
        }
        return true;
      }
    }();
    returnsNumber = {
      value: {
        hasEffectsWhenCalled: null,
        returns: UNKNOWN_LITERAL_NUMBER
      }
    };
    UNKNOWN_LITERAL_STRING = new class UnknownString extends ExpressionEntity {
      getReturnExpressionWhenCalledAtPath(path4) {
        if (path4.length === 1) {
          return getMemberReturnExpressionWhenCalled(literalStringMembers, path4[0]);
        }
        return UNKNOWN_RETURN_EXPRESSION;
      }
      hasEffectsOnInteractionAtPath(path4, interaction, context) {
        if (interaction.type === INTERACTION_ACCESSED) {
          return path4.length > 1;
        }
        if (interaction.type === INTERACTION_CALLED && path4.length === 1) {
          return hasMemberEffectWhenCalled(literalStringMembers, path4[0], interaction, context);
        }
        return true;
      }
    }();
    returnsString = {
      value: {
        hasEffectsWhenCalled: null,
        returns: UNKNOWN_LITERAL_STRING
      }
    };
    stringReplace = {
      value: {
        hasEffectsWhenCalled({ args }, context) {
          const argument1 = args[1];
          return args.length < 2 || typeof argument1.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, {
            deoptimizeCache() {
            }
          }) === "symbol" && argument1.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, context);
        },
        returns: UNKNOWN_LITERAL_STRING
      }
    };
    objectMembers = assembleMemberDescriptions({
      hasOwnProperty: returnsBoolean,
      isPrototypeOf: returnsBoolean,
      propertyIsEnumerable: returnsBoolean,
      toLocaleString: returnsString,
      toString: returnsString,
      valueOf: returnsUnknown
    });
    literalBooleanMembers = assembleMemberDescriptions({
      valueOf: returnsBoolean
    }, objectMembers);
    literalNumberMembers = assembleMemberDescriptions({
      toExponential: returnsString,
      toFixed: returnsString,
      toLocaleString: returnsString,
      toPrecision: returnsString,
      valueOf: returnsNumber
    }, objectMembers);
    literalRegExpMembers = assembleMemberDescriptions({
      exec: returnsUnknown,
      test: returnsBoolean
    }, objectMembers);
    literalStringMembers = assembleMemberDescriptions({
      anchor: returnsString,
      at: returnsUnknown,
      big: returnsString,
      blink: returnsString,
      bold: returnsString,
      charAt: returnsString,
      charCodeAt: returnsNumber,
      codePointAt: returnsUnknown,
      concat: returnsString,
      endsWith: returnsBoolean,
      fixed: returnsString,
      fontcolor: returnsString,
      fontsize: returnsString,
      includes: returnsBoolean,
      indexOf: returnsNumber,
      italics: returnsString,
      lastIndexOf: returnsNumber,
      link: returnsString,
      localeCompare: returnsNumber,
      match: returnsUnknown,
      matchAll: returnsUnknown,
      normalize: returnsString,
      padEnd: returnsString,
      padStart: returnsString,
      repeat: returnsString,
      replace: stringReplace,
      replaceAll: stringReplace,
      search: returnsNumber,
      slice: returnsString,
      small: returnsString,
      split: returnsUnknown,
      startsWith: returnsBoolean,
      strike: returnsString,
      sub: returnsString,
      substr: returnsString,
      substring: returnsString,
      sup: returnsString,
      toLocaleLowerCase: returnsString,
      toLocaleUpperCase: returnsString,
      toLowerCase: returnsString,
      toString: returnsString,
      toUpperCase: returnsString,
      trim: returnsString,
      trimEnd: returnsString,
      trimLeft: returnsString,
      trimRight: returnsString,
      trimStart: returnsString,
      valueOf: returnsString
    }, objectMembers);
    base$1 = {};
    base$1.Program = base$1.BlockStatement = base$1.StaticBlock = function(node2, st, c) {
      for (var i = 0, list = node2.body; i < list.length; i += 1) {
        var stmt = list[i];
        c(stmt, st, "Statement");
      }
    };
    base$1.Statement = skipThrough;
    base$1.EmptyStatement = ignore;
    base$1.ExpressionStatement = base$1.ParenthesizedExpression = base$1.ChainExpression = function(node2, st, c) {
      return c(node2.expression, st, "Expression");
    };
    base$1.IfStatement = function(node2, st, c) {
      c(node2.test, st, "Expression");
      c(node2.consequent, st, "Statement");
      if (node2.alternate) {
        c(node2.alternate, st, "Statement");
      }
    };
    base$1.LabeledStatement = function(node2, st, c) {
      return c(node2.body, st, "Statement");
    };
    base$1.BreakStatement = base$1.ContinueStatement = ignore;
    base$1.WithStatement = function(node2, st, c) {
      c(node2.object, st, "Expression");
      c(node2.body, st, "Statement");
    };
    base$1.SwitchStatement = function(node2, st, c) {
      c(node2.discriminant, st, "Expression");
      for (var i$1 = 0, list$1 = node2.cases; i$1 < list$1.length; i$1 += 1) {
        var cs = list$1[i$1];
        if (cs.test) {
          c(cs.test, st, "Expression");
        }
        for (var i = 0, list = cs.consequent; i < list.length; i += 1) {
          var cons = list[i];
          c(cons, st, "Statement");
        }
      }
    };
    base$1.SwitchCase = function(node2, st, c) {
      if (node2.test) {
        c(node2.test, st, "Expression");
      }
      for (var i = 0, list = node2.consequent; i < list.length; i += 1) {
        var cons = list[i];
        c(cons, st, "Statement");
      }
    };
    base$1.ReturnStatement = base$1.YieldExpression = base$1.AwaitExpression = function(node2, st, c) {
      if (node2.argument) {
        c(node2.argument, st, "Expression");
      }
    };
    base$1.ThrowStatement = base$1.SpreadElement = function(node2, st, c) {
      return c(node2.argument, st, "Expression");
    };
    base$1.TryStatement = function(node2, st, c) {
      c(node2.block, st, "Statement");
      if (node2.handler) {
        c(node2.handler, st);
      }
      if (node2.finalizer) {
        c(node2.finalizer, st, "Statement");
      }
    };
    base$1.CatchClause = function(node2, st, c) {
      if (node2.param) {
        c(node2.param, st, "Pattern");
      }
      c(node2.body, st, "Statement");
    };
    base$1.WhileStatement = base$1.DoWhileStatement = function(node2, st, c) {
      c(node2.test, st, "Expression");
      c(node2.body, st, "Statement");
    };
    base$1.ForStatement = function(node2, st, c) {
      if (node2.init) {
        c(node2.init, st, "ForInit");
      }
      if (node2.test) {
        c(node2.test, st, "Expression");
      }
      if (node2.update) {
        c(node2.update, st, "Expression");
      }
      c(node2.body, st, "Statement");
    };
    base$1.ForInStatement = base$1.ForOfStatement = function(node2, st, c) {
      c(node2.left, st, "ForInit");
      c(node2.right, st, "Expression");
      c(node2.body, st, "Statement");
    };
    base$1.ForInit = function(node2, st, c) {
      if (node2.type === "VariableDeclaration") {
        c(node2, st);
      } else {
        c(node2, st, "Expression");
      }
    };
    base$1.DebuggerStatement = ignore;
    base$1.FunctionDeclaration = function(node2, st, c) {
      return c(node2, st, "Function");
    };
    base$1.VariableDeclaration = function(node2, st, c) {
      for (var i = 0, list = node2.declarations; i < list.length; i += 1) {
        var decl = list[i];
        c(decl, st);
      }
    };
    base$1.VariableDeclarator = function(node2, st, c) {
      c(node2.id, st, "Pattern");
      if (node2.init) {
        c(node2.init, st, "Expression");
      }
    };
    base$1.Function = function(node2, st, c) {
      if (node2.id) {
        c(node2.id, st, "Pattern");
      }
      for (var i = 0, list = node2.params; i < list.length; i += 1) {
        var param = list[i];
        c(param, st, "Pattern");
      }
      c(node2.body, st, node2.expression ? "Expression" : "Statement");
    };
    base$1.Pattern = function(node2, st, c) {
      if (node2.type === "Identifier") {
        c(node2, st, "VariablePattern");
      } else if (node2.type === "MemberExpression") {
        c(node2, st, "MemberPattern");
      } else {
        c(node2, st);
      }
    };
    base$1.VariablePattern = ignore;
    base$1.MemberPattern = skipThrough;
    base$1.RestElement = function(node2, st, c) {
      return c(node2.argument, st, "Pattern");
    };
    base$1.ArrayPattern = function(node2, st, c) {
      for (var i = 0, list = node2.elements; i < list.length; i += 1) {
        var elt = list[i];
        if (elt) {
          c(elt, st, "Pattern");
        }
      }
    };
    base$1.ObjectPattern = function(node2, st, c) {
      for (var i = 0, list = node2.properties; i < list.length; i += 1) {
        var prop = list[i];
        if (prop.type === "Property") {
          if (prop.computed) {
            c(prop.key, st, "Expression");
          }
          c(prop.value, st, "Pattern");
        } else if (prop.type === "RestElement") {
          c(prop.argument, st, "Pattern");
        }
      }
    };
    base$1.Expression = skipThrough;
    base$1.ThisExpression = base$1.Super = base$1.MetaProperty = ignore;
    base$1.ArrayExpression = function(node2, st, c) {
      for (var i = 0, list = node2.elements; i < list.length; i += 1) {
        var elt = list[i];
        if (elt) {
          c(elt, st, "Expression");
        }
      }
    };
    base$1.ObjectExpression = function(node2, st, c) {
      for (var i = 0, list = node2.properties; i < list.length; i += 1) {
        var prop = list[i];
        c(prop, st);
      }
    };
    base$1.FunctionExpression = base$1.ArrowFunctionExpression = base$1.FunctionDeclaration;
    base$1.SequenceExpression = function(node2, st, c) {
      for (var i = 0, list = node2.expressions; i < list.length; i += 1) {
        var expr = list[i];
        c(expr, st, "Expression");
      }
    };
    base$1.TemplateLiteral = function(node2, st, c) {
      for (var i = 0, list = node2.quasis; i < list.length; i += 1) {
        var quasi = list[i];
        c(quasi, st);
      }
      for (var i$1 = 0, list$1 = node2.expressions; i$1 < list$1.length; i$1 += 1) {
        var expr = list$1[i$1];
        c(expr, st, "Expression");
      }
    };
    base$1.TemplateElement = ignore;
    base$1.UnaryExpression = base$1.UpdateExpression = function(node2, st, c) {
      c(node2.argument, st, "Expression");
    };
    base$1.BinaryExpression = base$1.LogicalExpression = function(node2, st, c) {
      c(node2.left, st, "Expression");
      c(node2.right, st, "Expression");
    };
    base$1.AssignmentExpression = base$1.AssignmentPattern = function(node2, st, c) {
      c(node2.left, st, "Pattern");
      c(node2.right, st, "Expression");
    };
    base$1.ConditionalExpression = function(node2, st, c) {
      c(node2.test, st, "Expression");
      c(node2.consequent, st, "Expression");
      c(node2.alternate, st, "Expression");
    };
    base$1.NewExpression = base$1.CallExpression = function(node2, st, c) {
      c(node2.callee, st, "Expression");
      if (node2.arguments) {
        for (var i = 0, list = node2.arguments; i < list.length; i += 1) {
          var arg = list[i];
          c(arg, st, "Expression");
        }
      }
    };
    base$1.MemberExpression = function(node2, st, c) {
      c(node2.object, st, "Expression");
      if (node2.computed) {
        c(node2.property, st, "Expression");
      }
    };
    base$1.ExportNamedDeclaration = base$1.ExportDefaultDeclaration = function(node2, st, c) {
      if (node2.declaration) {
        c(node2.declaration, st, node2.type === "ExportNamedDeclaration" || node2.declaration.id ? "Statement" : "Expression");
      }
      if (node2.source) {
        c(node2.source, st, "Expression");
      }
    };
    base$1.ExportAllDeclaration = function(node2, st, c) {
      if (node2.exported) {
        c(node2.exported, st);
      }
      c(node2.source, st, "Expression");
    };
    base$1.ImportDeclaration = function(node2, st, c) {
      for (var i = 0, list = node2.specifiers; i < list.length; i += 1) {
        var spec = list[i];
        c(spec, st);
      }
      c(node2.source, st, "Expression");
    };
    base$1.ImportExpression = function(node2, st, c) {
      c(node2.source, st, "Expression");
    };
    base$1.ImportSpecifier = base$1.ImportDefaultSpecifier = base$1.ImportNamespaceSpecifier = base$1.Identifier = base$1.PrivateIdentifier = base$1.Literal = ignore;
    base$1.TaggedTemplateExpression = function(node2, st, c) {
      c(node2.tag, st, "Expression");
      c(node2.quasi, st, "Expression");
    };
    base$1.ClassDeclaration = base$1.ClassExpression = function(node2, st, c) {
      return c(node2, st, "Class");
    };
    base$1.Class = function(node2, st, c) {
      if (node2.id) {
        c(node2.id, st, "Pattern");
      }
      if (node2.superClass) {
        c(node2.superClass, st, "Expression");
      }
      c(node2.body, st);
    };
    base$1.ClassBody = function(node2, st, c) {
      for (var i = 0, list = node2.body; i < list.length; i += 1) {
        var elt = list[i];
        c(elt, st);
      }
    };
    base$1.MethodDefinition = base$1.PropertyDefinition = base$1.Property = function(node2, st, c) {
      if (node2.computed) {
        c(node2.key, st, "Expression");
      }
      if (node2.value) {
        c(node2.value, st, "Expression");
      }
    };
    BlockStatement$1 = "BlockStatement";
    CallExpression$1 = "CallExpression";
    ExpressionStatement$1 = "ExpressionStatement";
    Program$1 = "Program";
    ReturnStatement$1 = "ReturnStatement";
    SOURCEMAPPING_URL = "sourceMa";
    SOURCEMAPPING_URL += "ppingURL";
    whiteSpaceNoNewline = "[ \\f\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]";
    SOURCEMAPPING_URL_RE = new RegExp(`^#${whiteSpaceNoNewline}+${SOURCEMAPPING_URL}=.+`);
    ANNOTATION_KEY = "_rollupAnnotations";
    INVALID_COMMENT_KEY = "_rollupRemoved";
    keys = {
      // TODO this should be removed once ImportExpression follows official ESTree
      //  specs with "null" as default
      ImportExpression: ["arguments"],
      Literal: [],
      Program: ["body"]
    };
    NodeBase = class extends ExpressionEntity {
      constructor(esTreeNode, parent, parentScope, keepEsTreeNode = false) {
        super();
        this.deoptimized = false;
        this.esTreeNode = keepEsTreeNode ? esTreeNode : null;
        this.keys = keys[esTreeNode.type] || getAndCreateKeys(esTreeNode);
        this.parent = parent;
        this.context = parent.context;
        this.createScope(parentScope);
        this.parseNode(esTreeNode);
        this.initialise();
        this.context.magicString.addSourcemapLocation(this.start);
        this.context.magicString.addSourcemapLocation(this.end);
      }
      addExportedVariables(_variables, _exportNamesByVariable) {
      }
      /**
       * Override this to bind assignments to variables and do any initialisations
       * that require the scopes to be populated with variables.
       */
      bind() {
        for (const key of this.keys) {
          const value2 = this[key];
          if (Array.isArray(value2)) {
            for (const child of value2) {
              child?.bind();
            }
          } else if (value2) {
            value2.bind();
          }
        }
      }
      /**
       * Override if this node should receive a different scope than the parent
       * scope.
       */
      createScope(parentScope) {
        this.scope = parentScope;
      }
      hasEffects(context) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        for (const key of this.keys) {
          const value2 = this[key];
          if (value2 === null)
            continue;
          if (Array.isArray(value2)) {
            for (const child of value2) {
              if (child?.hasEffects(context))
                return true;
            }
          } else if (value2.hasEffects(context))
            return true;
        }
        return false;
      }
      hasEffectsAsAssignmentTarget(context, _checkAccess) {
        return this.hasEffects(context) || this.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.assignmentInteraction, context);
      }
      include(context, includeChildrenRecursively, _options) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.included = true;
        for (const key of this.keys) {
          const value2 = this[key];
          if (value2 === null)
            continue;
          if (Array.isArray(value2)) {
            for (const child of value2) {
              child?.include(context, includeChildrenRecursively);
            }
          } else {
            value2.include(context, includeChildrenRecursively);
          }
        }
      }
      includeAsAssignmentTarget(context, includeChildrenRecursively, _deoptimizeAccess) {
        this.include(context, includeChildrenRecursively);
      }
      /**
       * Override to perform special initialisation steps after the scope is
       * initialised
       */
      initialise() {
      }
      insertSemicolon(code) {
        if (code.original[this.end - 1] !== ";") {
          code.appendLeft(this.end, ";");
        }
      }
      parseNode(esTreeNode, keepEsTreeNodeKeys) {
        for (const [key, value2] of Object.entries(esTreeNode)) {
          if (this.hasOwnProperty(key))
            continue;
          if (key.charCodeAt(0) === 95) {
            if (key === ANNOTATION_KEY) {
              this.annotations = value2;
            } else if (key === INVALID_COMMENT_KEY) {
              for (const { start, end } of value2)
                this.context.magicString.remove(start, end);
            }
          } else if (typeof value2 !== "object" || value2 === null) {
            this[key] = value2;
          } else if (Array.isArray(value2)) {
            this[key] = [];
            for (const child of value2) {
              this[key].push(child === null ? null : new (this.context.getNodeConstructor(child.type))(child, this, this.scope, keepEsTreeNodeKeys?.includes(key)));
            }
          } else {
            this[key] = new (this.context.getNodeConstructor(value2.type))(value2, this, this.scope, keepEsTreeNodeKeys?.includes(key));
          }
        }
      }
      render(code, options2) {
        for (const key of this.keys) {
          const value2 = this[key];
          if (value2 === null)
            continue;
          if (Array.isArray(value2)) {
            for (const child of value2) {
              child?.render(code, options2);
            }
          } else {
            value2.render(code, options2);
          }
        }
      }
      setAssignedValue(value2) {
        this.assignmentInteraction = { args: [value2], thisArg: null, type: INTERACTION_ASSIGNED };
      }
      shouldBeIncluded(context) {
        return this.included || !context.brokenFlow && this.hasEffects(createHasEffectsContext());
      }
      /**
       * Just deoptimize everything by default so that when e.g. we do not track
       * something properly, it is deoptimized.
       * @protected
       */
      applyDeoptimizations() {
        this.deoptimized = true;
        for (const key of this.keys) {
          const value2 = this[key];
          if (value2 === null)
            continue;
          if (Array.isArray(value2)) {
            for (const child of value2) {
              child?.deoptimizePath(UNKNOWN_PATH);
            }
          } else {
            value2.deoptimizePath(UNKNOWN_PATH);
          }
        }
        this.context.requestTreeshakingPass();
      }
    };
    SpreadElement = class extends NodeBase {
      deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker) {
        if (path4.length > 0) {
          this.argument.deoptimizeArgumentsOnInteractionAtPath(interaction, [UnknownKey, ...path4], recursionTracker);
        }
      }
      hasEffects(context) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        const { propertyReadSideEffects } = this.context.options.treeshake;
        return this.argument.hasEffects(context) || propertyReadSideEffects && (propertyReadSideEffects === "always" || this.argument.hasEffectsOnInteractionAtPath(UNKNOWN_PATH, NODE_INTERACTION_UNKNOWN_ACCESS, context));
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        this.argument.deoptimizePath([UnknownKey, UnknownKey]);
        this.context.requestTreeshakingPass();
      }
    };
    Method = class extends ExpressionEntity {
      constructor(description2) {
        super();
        this.description = description2;
      }
      deoptimizeArgumentsOnInteractionAtPath({ type, thisArg }, path4) {
        if (type === INTERACTION_CALLED && path4.length === 0 && this.description.mutatesSelfAsArray) {
          thisArg?.deoptimizePath(UNKNOWN_INTEGER_PATH);
        }
      }
      getReturnExpressionWhenCalledAtPath(path4, { thisArg }) {
        if (path4.length > 0) {
          return UNKNOWN_RETURN_EXPRESSION;
        }
        return [
          this.description.returnsPrimitive || (this.description.returns === "self" ? thisArg || UNKNOWN_EXPRESSION : this.description.returns()),
          false
        ];
      }
      hasEffectsOnInteractionAtPath(path4, interaction, context) {
        const { type } = interaction;
        if (path4.length > (type === INTERACTION_ACCESSED ? 1 : 0)) {
          return true;
        }
        if (type === INTERACTION_CALLED) {
          const { args, thisArg } = interaction;
          if (this.description.mutatesSelfAsArray === true && thisArg?.hasEffectsOnInteractionAtPath(UNKNOWN_INTEGER_PATH, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, context)) {
            return true;
          }
          if (this.description.callsArgs) {
            for (const argumentIndex of this.description.callsArgs) {
              if (args[argumentIndex]?.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, context)) {
                return true;
              }
            }
          }
        }
        return false;
      }
    };
    METHOD_RETURNS_BOOLEAN = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: false,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
      })
    ];
    METHOD_RETURNS_STRING = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: false,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_STRING
      })
    ];
    METHOD_RETURNS_NUMBER = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: false,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
      })
    ];
    METHOD_RETURNS_UNKNOWN = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: false,
        returns: null,
        returnsPrimitive: UNKNOWN_EXPRESSION
      })
    ];
    INTEGER_REG_EXP = /^\d+$/;
    ObjectEntity = class extends ExpressionEntity {
      // If a PropertyMap is used, this will be taken as propertiesAndGettersByKey
      // and we assume there are no setters or getters
      constructor(properties, prototypeExpression, immutable = false) {
        super();
        this.prototypeExpression = prototypeExpression;
        this.immutable = immutable;
        this.additionalExpressionsToBeDeoptimized = /* @__PURE__ */ new Set();
        this.allProperties = [];
        this.deoptimizedPaths = /* @__PURE__ */ Object.create(null);
        this.expressionsToBeDeoptimizedByKey = /* @__PURE__ */ Object.create(null);
        this.gettersByKey = /* @__PURE__ */ Object.create(null);
        this.hasLostTrack = false;
        this.hasUnknownDeoptimizedInteger = false;
        this.hasUnknownDeoptimizedProperty = false;
        this.propertiesAndGettersByKey = /* @__PURE__ */ Object.create(null);
        this.propertiesAndSettersByKey = /* @__PURE__ */ Object.create(null);
        this.settersByKey = /* @__PURE__ */ Object.create(null);
        this.unknownIntegerProps = [];
        this.unmatchableGetters = [];
        this.unmatchablePropertiesAndGetters = [];
        this.unmatchableSetters = [];
        if (Array.isArray(properties)) {
          this.buildPropertyMaps(properties);
        } else {
          this.propertiesAndGettersByKey = this.propertiesAndSettersByKey = properties;
          for (const propertiesForKey of Object.values(properties)) {
            this.allProperties.push(...propertiesForKey);
          }
        }
      }
      deoptimizeAllProperties(noAccessors) {
        const isDeoptimized = this.hasLostTrack || this.hasUnknownDeoptimizedProperty;
        if (noAccessors) {
          this.hasUnknownDeoptimizedProperty = true;
        } else {
          this.hasLostTrack = true;
        }
        if (isDeoptimized) {
          return;
        }
        for (const properties of [
          ...Object.values(this.propertiesAndGettersByKey),
          ...Object.values(this.settersByKey)
        ]) {
          for (const property of properties) {
            property.deoptimizePath(UNKNOWN_PATH);
          }
        }
        this.prototypeExpression?.deoptimizePath([UnknownKey, UnknownKey]);
        this.deoptimizeCachedEntities();
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker) {
        const [key, ...subPath] = path4;
        const { args, thisArg, type } = interaction;
        if (this.hasLostTrack || // single paths that are deoptimized will not become getters or setters
        (type === INTERACTION_CALLED || path4.length > 1) && (this.hasUnknownDeoptimizedProperty || typeof key === "string" && this.deoptimizedPaths[key])) {
          thisArg?.deoptimizePath(UNKNOWN_PATH);
          if (args) {
            for (const argument of args) {
              argument.deoptimizePath(UNKNOWN_PATH);
            }
          }
          return;
        }
        const [propertiesForExactMatchByKey, relevantPropertiesByKey, relevantUnmatchableProperties] = type === INTERACTION_CALLED || path4.length > 1 ? [
          this.propertiesAndGettersByKey,
          this.propertiesAndGettersByKey,
          this.unmatchablePropertiesAndGetters
        ] : type === INTERACTION_ACCESSED ? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters] : [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters];
        if (typeof key === "string") {
          if (propertiesForExactMatchByKey[key]) {
            const properties = relevantPropertiesByKey[key];
            if (properties) {
              for (const property of properties) {
                property.deoptimizeArgumentsOnInteractionAtPath(interaction, subPath, recursionTracker);
              }
            }
            if (!this.immutable) {
              if (thisArg) {
                this.additionalExpressionsToBeDeoptimized.add(thisArg);
              }
              if (args) {
                for (const argument of args) {
                  this.additionalExpressionsToBeDeoptimized.add(argument);
                }
              }
            }
            return;
          }
          for (const property of relevantUnmatchableProperties) {
            property.deoptimizeArgumentsOnInteractionAtPath(interaction, subPath, recursionTracker);
          }
          if (INTEGER_REG_EXP.test(key)) {
            for (const property of this.unknownIntegerProps) {
              property.deoptimizeArgumentsOnInteractionAtPath(interaction, subPath, recursionTracker);
            }
          }
        } else {
          for (const properties of [
            ...Object.values(relevantPropertiesByKey),
            relevantUnmatchableProperties
          ]) {
            for (const property of properties) {
              property.deoptimizeArgumentsOnInteractionAtPath(interaction, subPath, recursionTracker);
            }
          }
          for (const property of this.unknownIntegerProps) {
            property.deoptimizeArgumentsOnInteractionAtPath(interaction, subPath, recursionTracker);
          }
        }
        if (!this.immutable) {
          if (thisArg) {
            this.additionalExpressionsToBeDeoptimized.add(thisArg);
          }
          if (args) {
            for (const argument of args) {
              this.additionalExpressionsToBeDeoptimized.add(argument);
            }
          }
        }
        this.prototypeExpression?.deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker);
      }
      deoptimizeIntegerProperties() {
        if (this.hasLostTrack || this.hasUnknownDeoptimizedProperty || this.hasUnknownDeoptimizedInteger) {
          return;
        }
        this.hasUnknownDeoptimizedInteger = true;
        for (const [key, propertiesAndGetters] of Object.entries(this.propertiesAndGettersByKey)) {
          if (INTEGER_REG_EXP.test(key)) {
            for (const property of propertiesAndGetters) {
              property.deoptimizePath(UNKNOWN_PATH);
            }
          }
        }
        this.deoptimizeCachedIntegerEntities();
      }
      // Assumption: If only a specific path is deoptimized, no accessors are created
      deoptimizePath(path4) {
        if (this.hasLostTrack || this.immutable) {
          return;
        }
        const key = path4[0];
        if (path4.length === 1) {
          if (typeof key !== "string") {
            if (key === UnknownInteger) {
              return this.deoptimizeIntegerProperties();
            }
            return this.deoptimizeAllProperties(key === UnknownNonAccessorKey);
          }
          if (!this.deoptimizedPaths[key]) {
            this.deoptimizedPaths[key] = true;
            const expressionsToBeDeoptimized = this.expressionsToBeDeoptimizedByKey[key];
            if (expressionsToBeDeoptimized) {
              for (const expression of expressionsToBeDeoptimized) {
                expression.deoptimizeCache();
              }
            }
          }
        }
        const subPath = path4.length === 1 ? UNKNOWN_PATH : path4.slice(1);
        for (const property of typeof key === "string" ? [
          ...this.propertiesAndGettersByKey[key] || this.unmatchablePropertiesAndGetters,
          ...this.settersByKey[key] || this.unmatchableSetters
        ] : this.allProperties) {
          property.deoptimizePath(subPath);
        }
        this.prototypeExpression?.deoptimizePath(path4.length === 1 ? [...path4, UnknownKey] : path4);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        if (path4.length === 0) {
          return UnknownTruthyValue;
        }
        const key = path4[0];
        const expressionAtPath = this.getMemberExpressionAndTrackDeopt(key, origin);
        if (expressionAtPath) {
          return expressionAtPath.getLiteralValueAtPath(path4.slice(1), recursionTracker, origin);
        }
        if (this.prototypeExpression) {
          return this.prototypeExpression.getLiteralValueAtPath(path4, recursionTracker, origin);
        }
        if (path4.length === 1) {
          return void 0;
        }
        return UnknownValue;
      }
      getReturnExpressionWhenCalledAtPath(path4, interaction, recursionTracker, origin) {
        if (path4.length === 0) {
          return UNKNOWN_RETURN_EXPRESSION;
        }
        const [key, ...subPath] = path4;
        const expressionAtPath = this.getMemberExpressionAndTrackDeopt(key, origin);
        if (expressionAtPath) {
          return expressionAtPath.getReturnExpressionWhenCalledAtPath(subPath, interaction, recursionTracker, origin);
        }
        if (this.prototypeExpression) {
          return this.prototypeExpression.getReturnExpressionWhenCalledAtPath(path4, interaction, recursionTracker, origin);
        }
        return UNKNOWN_RETURN_EXPRESSION;
      }
      hasEffectsOnInteractionAtPath(path4, interaction, context) {
        const [key, ...subPath] = path4;
        if (subPath.length > 0 || interaction.type === INTERACTION_CALLED) {
          const expressionAtPath = this.getMemberExpression(key);
          if (expressionAtPath) {
            return expressionAtPath.hasEffectsOnInteractionAtPath(subPath, interaction, context);
          }
          if (this.prototypeExpression) {
            return this.prototypeExpression.hasEffectsOnInteractionAtPath(path4, interaction, context);
          }
          return true;
        }
        if (key === UnknownNonAccessorKey)
          return false;
        if (this.hasLostTrack)
          return true;
        const [propertiesAndAccessorsByKey, accessorsByKey, unmatchableAccessors] = interaction.type === INTERACTION_ACCESSED ? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters] : [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters];
        if (typeof key === "string") {
          if (propertiesAndAccessorsByKey[key]) {
            const accessors = accessorsByKey[key];
            if (accessors) {
              for (const accessor of accessors) {
                if (accessor.hasEffectsOnInteractionAtPath(subPath, interaction, context))
                  return true;
              }
            }
            return false;
          }
          for (const accessor of unmatchableAccessors) {
            if (accessor.hasEffectsOnInteractionAtPath(subPath, interaction, context)) {
              return true;
            }
          }
        } else {
          for (const accessors of [...Object.values(accessorsByKey), unmatchableAccessors]) {
            for (const accessor of accessors) {
              if (accessor.hasEffectsOnInteractionAtPath(subPath, interaction, context))
                return true;
            }
          }
        }
        if (this.prototypeExpression) {
          return this.prototypeExpression.hasEffectsOnInteractionAtPath(path4, interaction, context);
        }
        return false;
      }
      buildPropertyMaps(properties) {
        const { allProperties, propertiesAndGettersByKey, propertiesAndSettersByKey, settersByKey, gettersByKey, unknownIntegerProps, unmatchablePropertiesAndGetters, unmatchableGetters, unmatchableSetters } = this;
        const unmatchablePropertiesAndSetters = [];
        for (let index = properties.length - 1; index >= 0; index--) {
          const { key, kind, property } = properties[index];
          allProperties.push(property);
          if (typeof key === "string") {
            if (kind === "set") {
              if (!propertiesAndSettersByKey[key]) {
                propertiesAndSettersByKey[key] = [property, ...unmatchablePropertiesAndSetters];
                settersByKey[key] = [property, ...unmatchableSetters];
              }
            } else if (kind === "get") {
              if (!propertiesAndGettersByKey[key]) {
                propertiesAndGettersByKey[key] = [property, ...unmatchablePropertiesAndGetters];
                gettersByKey[key] = [property, ...unmatchableGetters];
              }
            } else {
              if (!propertiesAndSettersByKey[key]) {
                propertiesAndSettersByKey[key] = [property, ...unmatchablePropertiesAndSetters];
              }
              if (!propertiesAndGettersByKey[key]) {
                propertiesAndGettersByKey[key] = [property, ...unmatchablePropertiesAndGetters];
              }
            }
          } else {
            if (key === UnknownInteger) {
              unknownIntegerProps.push(property);
              continue;
            }
            if (kind === "set")
              unmatchableSetters.push(property);
            if (kind === "get")
              unmatchableGetters.push(property);
            if (kind !== "get")
              unmatchablePropertiesAndSetters.push(property);
            if (kind !== "set")
              unmatchablePropertiesAndGetters.push(property);
          }
        }
      }
      deoptimizeCachedEntities() {
        for (const expressionsToBeDeoptimized of Object.values(this.expressionsToBeDeoptimizedByKey)) {
          for (const expression of expressionsToBeDeoptimized) {
            expression.deoptimizeCache();
          }
        }
        for (const expression of this.additionalExpressionsToBeDeoptimized) {
          expression.deoptimizePath(UNKNOWN_PATH);
        }
      }
      deoptimizeCachedIntegerEntities() {
        for (const [key, expressionsToBeDeoptimized] of Object.entries(this.expressionsToBeDeoptimizedByKey)) {
          if (INTEGER_REG_EXP.test(key)) {
            for (const expression of expressionsToBeDeoptimized) {
              expression.deoptimizeCache();
            }
          }
        }
        for (const expression of this.additionalExpressionsToBeDeoptimized) {
          expression.deoptimizePath(UNKNOWN_INTEGER_PATH);
        }
      }
      getMemberExpression(key) {
        if (this.hasLostTrack || this.hasUnknownDeoptimizedProperty || typeof key !== "string" || this.hasUnknownDeoptimizedInteger && INTEGER_REG_EXP.test(key) || this.deoptimizedPaths[key]) {
          return UNKNOWN_EXPRESSION;
        }
        const properties = this.propertiesAndGettersByKey[key];
        if (properties?.length === 1) {
          return properties[0];
        }
        if (properties || this.unmatchablePropertiesAndGetters.length > 0 || this.unknownIntegerProps.length > 0 && INTEGER_REG_EXP.test(key)) {
          return UNKNOWN_EXPRESSION;
        }
        return null;
      }
      getMemberExpressionAndTrackDeopt(key, origin) {
        if (typeof key !== "string") {
          return UNKNOWN_EXPRESSION;
        }
        const expression = this.getMemberExpression(key);
        if (!(expression === UNKNOWN_EXPRESSION || this.immutable)) {
          const expressionsToBeDeoptimized = this.expressionsToBeDeoptimizedByKey[key] = this.expressionsToBeDeoptimizedByKey[key] || [];
          expressionsToBeDeoptimized.push(origin);
        }
        return expression;
      }
    };
    isInteger = (property) => typeof property === "string" && /^\d+$/.test(property);
    OBJECT_PROTOTYPE_FALLBACK = new class ObjectPrototypeFallbackExpression extends ExpressionEntity {
      deoptimizeArgumentsOnInteractionAtPath(interaction, path4) {
        if (interaction.type === INTERACTION_CALLED && path4.length === 1 && !isInteger(path4[0])) {
          deoptimizeInteraction(interaction);
        }
      }
      getLiteralValueAtPath(path4) {
        return path4.length === 1 && isInteger(path4[0]) ? void 0 : UnknownValue;
      }
      hasEffectsOnInteractionAtPath(path4, { type }) {
        return path4.length > 1 || type === INTERACTION_CALLED;
      }
    }();
    OBJECT_PROTOTYPE = new ObjectEntity({
      __proto__: null,
      hasOwnProperty: METHOD_RETURNS_BOOLEAN,
      isPrototypeOf: METHOD_RETURNS_BOOLEAN,
      propertyIsEnumerable: METHOD_RETURNS_BOOLEAN,
      toLocaleString: METHOD_RETURNS_STRING,
      toString: METHOD_RETURNS_STRING,
      valueOf: METHOD_RETURNS_UNKNOWN
    }, OBJECT_PROTOTYPE_FALLBACK, true);
    NEW_ARRAY_PROPERTIES = [
      { key: UnknownInteger, kind: "init", property: UNKNOWN_EXPRESSION },
      { key: "length", kind: "init", property: UNKNOWN_LITERAL_NUMBER }
    ];
    METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN = [
      new Method({
        callsArgs: [0],
        mutatesSelfAsArray: "deopt-only",
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN
      })
    ];
    METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER = [
      new Method({
        callsArgs: [0],
        mutatesSelfAsArray: "deopt-only",
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
      })
    ];
    METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: true,
        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
        returnsPrimitive: null
      })
    ];
    METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: "deopt-only",
        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
        returnsPrimitive: null
      })
    ];
    METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY = [
      new Method({
        callsArgs: [0],
        mutatesSelfAsArray: "deopt-only",
        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),
        returnsPrimitive: null
      })
    ];
    METHOD_MUTATES_SELF_RETURNS_NUMBER = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: true,
        returns: null,
        returnsPrimitive: UNKNOWN_LITERAL_NUMBER
      })
    ];
    METHOD_MUTATES_SELF_RETURNS_UNKNOWN = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: true,
        returns: null,
        returnsPrimitive: UNKNOWN_EXPRESSION
      })
    ];
    METHOD_DEOPTS_SELF_RETURNS_UNKNOWN = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: "deopt-only",
        returns: null,
        returnsPrimitive: UNKNOWN_EXPRESSION
      })
    ];
    METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN = [
      new Method({
        callsArgs: [0],
        mutatesSelfAsArray: "deopt-only",
        returns: null,
        returnsPrimitive: UNKNOWN_EXPRESSION
      })
    ];
    METHOD_MUTATES_SELF_RETURNS_SELF = [
      new Method({
        callsArgs: null,
        mutatesSelfAsArray: true,
        returns: "self",
        returnsPrimitive: null
      })
    ];
    METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF = [
      new Method({
        callsArgs: [0],
        mutatesSelfAsArray: true,
        returns: "self",
        returnsPrimitive: null
      })
    ];
    ARRAY_PROTOTYPE = new ObjectEntity({
      __proto__: null,
      // We assume that accessors have effects as we do not track the accessed value afterwards
      at: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN,
      concat: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      copyWithin: METHOD_MUTATES_SELF_RETURNS_SELF,
      entries: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      every: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN,
      fill: METHOD_MUTATES_SELF_RETURNS_SELF,
      filter: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      find: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      findIndex: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER,
      findLast: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      findLastIndex: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER,
      flat: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      flatMap: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      forEach: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      includes: METHOD_RETURNS_BOOLEAN,
      indexOf: METHOD_RETURNS_NUMBER,
      join: METHOD_RETURNS_STRING,
      keys: METHOD_RETURNS_UNKNOWN,
      lastIndexOf: METHOD_RETURNS_NUMBER,
      map: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      pop: METHOD_MUTATES_SELF_RETURNS_UNKNOWN,
      push: METHOD_MUTATES_SELF_RETURNS_NUMBER,
      reduce: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      reduceRight: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,
      reverse: METHOD_MUTATES_SELF_RETURNS_SELF,
      shift: METHOD_MUTATES_SELF_RETURNS_UNKNOWN,
      slice: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,
      some: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN,
      sort: METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF,
      splice: METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY,
      toLocaleString: METHOD_RETURNS_STRING,
      toString: METHOD_RETURNS_STRING,
      unshift: METHOD_MUTATES_SELF_RETURNS_NUMBER,
      values: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN
    }, OBJECT_PROTOTYPE, true);
    LocalVariable = class extends Variable {
      constructor(name2, declarator, init4, context) {
        super(name2);
        this.init = init4;
        this.calledFromTryStatement = false;
        this.additionalInitializers = null;
        this.expressionsToBeDeoptimized = [];
        this.declarations = declarator ? [declarator] : [];
        this.deoptimizationTracker = context.deoptimizationTracker;
        this.module = context.module;
      }
      addDeclaration(identifier, init4) {
        this.declarations.push(identifier);
        this.markInitializersForDeoptimization().push(init4);
      }
      consolidateInitializers() {
        if (this.additionalInitializers) {
          for (const initializer of this.additionalInitializers) {
            initializer.deoptimizePath(UNKNOWN_PATH);
          }
          this.additionalInitializers = null;
        }
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker) {
        if (this.isReassigned) {
          deoptimizeInteraction(interaction);
          return;
        }
        recursionTracker.withTrackedEntityAtPath(path4, this.init, () => this.init.deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker), void 0);
      }
      deoptimizePath(path4) {
        if (this.isReassigned || this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path4, this)) {
          return;
        }
        if (path4.length === 0) {
          if (!this.isReassigned) {
            this.isReassigned = true;
            const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;
            this.expressionsToBeDeoptimized = [];
            for (const expression of expressionsToBeDeoptimized) {
              expression.deoptimizeCache();
            }
            this.init.deoptimizePath(UNKNOWN_PATH);
          }
        } else {
          this.init.deoptimizePath(path4);
        }
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        if (this.isReassigned) {
          return UnknownValue;
        }
        return recursionTracker.withTrackedEntityAtPath(path4, this.init, () => {
          this.expressionsToBeDeoptimized.push(origin);
          return this.init.getLiteralValueAtPath(path4, recursionTracker, origin);
        }, UnknownValue);
      }
      getReturnExpressionWhenCalledAtPath(path4, interaction, recursionTracker, origin) {
        if (this.isReassigned) {
          return UNKNOWN_RETURN_EXPRESSION;
        }
        return recursionTracker.withTrackedEntityAtPath(path4, this.init, () => {
          this.expressionsToBeDeoptimized.push(origin);
          return this.init.getReturnExpressionWhenCalledAtPath(path4, interaction, recursionTracker, origin);
        }, UNKNOWN_RETURN_EXPRESSION);
      }
      hasEffectsOnInteractionAtPath(path4, interaction, context) {
        switch (interaction.type) {
          case INTERACTION_ACCESSED: {
            if (this.isReassigned)
              return true;
            return !context.accessed.trackEntityAtPathAndGetIfTracked(path4, this) && this.init.hasEffectsOnInteractionAtPath(path4, interaction, context);
          }
          case INTERACTION_ASSIGNED: {
            if (this.included)
              return true;
            if (path4.length === 0)
              return false;
            if (this.isReassigned)
              return true;
            return !context.assigned.trackEntityAtPathAndGetIfTracked(path4, this) && this.init.hasEffectsOnInteractionAtPath(path4, interaction, context);
          }
          case INTERACTION_CALLED: {
            if (this.isReassigned)
              return true;
            return !(interaction.withNew ? context.instantiated : context.called).trackEntityAtPathAndGetIfTracked(path4, interaction.args, this) && this.init.hasEffectsOnInteractionAtPath(path4, interaction, context);
          }
        }
      }
      include() {
        if (!this.included) {
          this.included = true;
          for (const declaration of this.declarations) {
            if (!declaration.included)
              declaration.include(createInclusionContext(), false);
            let node2 = declaration.parent;
            while (!node2.included) {
              node2.included = true;
              if (node2.type === Program$1)
                break;
              node2 = node2.parent;
            }
          }
        }
      }
      includeCallArguments(context, parameters) {
        if (this.isReassigned || context.includedCallArguments.has(this.init)) {
          for (const argument of parameters) {
            argument.include(context, false);
          }
        } else {
          context.includedCallArguments.add(this.init);
          this.init.includeCallArguments(context, parameters);
          context.includedCallArguments.delete(this.init);
        }
      }
      markCalledFromTryStatement() {
        this.calledFromTryStatement = true;
      }
      markInitializersForDeoptimization() {
        if (this.additionalInitializers === null) {
          this.additionalInitializers = [this.init];
          this.init = UNKNOWN_EXPRESSION;
          this.isReassigned = true;
        }
        return this.additionalInitializers;
      }
      mergeDeclarations(variable) {
        const { declarations } = this;
        for (const declaration of variable.declarations) {
          declarations.push(declaration);
        }
        const additionalInitializers = this.markInitializersForDeoptimization();
        additionalInitializers.push(variable.init);
        if (variable.additionalInitializers) {
          for (const initializer of variable.additionalInitializers) {
            additionalInitializers.push(initializer);
          }
        }
      }
    };
    ParameterVariable = class extends LocalVariable {
      constructor(name2, declarator, context) {
        super(name2, declarator, UNKNOWN_EXPRESSION, context);
        this.deoptimizationInteractions = [];
        this.deoptimizations = new DiscriminatedPathTracker();
        this.deoptimizedFields = /* @__PURE__ */ new Set();
        this.entitiesToBeDeoptimized = /* @__PURE__ */ new Set();
      }
      addEntityToBeDeoptimized(entity) {
        if (this.deoptimizedFields.has(UnknownKey)) {
          entity.deoptimizePath(UNKNOWN_PATH);
        } else {
          for (const field of this.deoptimizedFields) {
            entity.deoptimizePath([field]);
          }
        }
        for (const { interaction, path: path4 } of this.deoptimizationInteractions) {
          entity.deoptimizeArgumentsOnInteractionAtPath(interaction, path4, SHARED_RECURSION_TRACKER);
        }
        this.entitiesToBeDeoptimized.add(entity);
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path4) {
        if (path4.length >= 2) {
          deoptimizeInteraction(interaction);
          return;
        }
        if (interaction.thisArg && !this.deoptimizations.trackEntityAtPathAndGetIfTracked(path4, interaction.args, interaction.thisArg)) {
          for (const entity of this.entitiesToBeDeoptimized) {
            entity.deoptimizeArgumentsOnInteractionAtPath(interaction, path4, SHARED_RECURSION_TRACKER);
          }
          this.deoptimizationInteractions.push({
            interaction,
            path: path4
          });
        }
      }
      deoptimizePath(path4) {
        if (path4.length === 0 || this.deoptimizedFields.has(UnknownKey)) {
          return;
        }
        const key = path4[0];
        if (this.deoptimizedFields.has(key)) {
          return;
        }
        this.deoptimizedFields.add(key);
        for (const entity of this.entitiesToBeDeoptimized) {
          entity.deoptimizePath(path4);
        }
      }
      getReturnExpressionWhenCalledAtPath(path4) {
        if (path4.length === 0) {
          this.deoptimizePath(UNKNOWN_PATH);
        } else if (!this.deoptimizedFields.has(path4[0])) {
          this.deoptimizePath(path4.slice(0, 1));
        }
        return UNKNOWN_RETURN_EXPRESSION;
      }
    };
    chars2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
    base = 64;
    Scope$1 = class Scope {
      constructor() {
        this.children = [];
        this.variables = /* @__PURE__ */ new Map();
      }
      addDeclaration(identifier, context, init4, _isHoisted) {
        const name2 = identifier.name;
        let variable = this.variables.get(name2);
        if (variable) {
          variable.addDeclaration(identifier, init4);
        } else {
          variable = new LocalVariable(identifier.name, identifier, init4 || UNDEFINED_EXPRESSION, context);
          this.variables.set(name2, variable);
        }
        return variable;
      }
      contains(name2) {
        return this.variables.has(name2);
      }
      findVariable(_name) {
        throw new Error("Internal Error: findVariable needs to be implemented by a subclass");
      }
    };
    ChildScope = class extends Scope$1 {
      constructor(parent) {
        super();
        this.accessedOutsideVariables = /* @__PURE__ */ new Map();
        this.parent = parent;
        parent.children.push(this);
      }
      addAccessedDynamicImport(importExpression) {
        (this.accessedDynamicImports || (this.accessedDynamicImports = /* @__PURE__ */ new Set())).add(importExpression);
        if (this.parent instanceof ChildScope) {
          this.parent.addAccessedDynamicImport(importExpression);
        }
      }
      addAccessedGlobals(globals, accessedGlobalsByScope) {
        const accessedGlobals = accessedGlobalsByScope.get(this) || /* @__PURE__ */ new Set();
        for (const name2 of globals) {
          accessedGlobals.add(name2);
        }
        accessedGlobalsByScope.set(this, accessedGlobals);
        if (this.parent instanceof ChildScope) {
          this.parent.addAccessedGlobals(globals, accessedGlobalsByScope);
        }
      }
      addNamespaceMemberAccess(name2, variable) {
        this.accessedOutsideVariables.set(name2, variable);
        this.parent.addNamespaceMemberAccess(name2, variable);
      }
      addReturnExpression(expression) {
        this.parent instanceof ChildScope && this.parent.addReturnExpression(expression);
      }
      addUsedOutsideNames(usedNames, format2, exportNamesByVariable, accessedGlobalsByScope) {
        for (const variable of this.accessedOutsideVariables.values()) {
          if (variable.included) {
            usedNames.add(variable.getBaseVariableName());
            if (format2 === "system" && exportNamesByVariable.has(variable)) {
              usedNames.add("exports");
            }
          }
        }
        const accessedGlobals = accessedGlobalsByScope.get(this);
        if (accessedGlobals) {
          for (const name2 of accessedGlobals) {
            usedNames.add(name2);
          }
        }
      }
      contains(name2) {
        return this.variables.has(name2) || this.parent.contains(name2);
      }
      deconflict(format2, exportNamesByVariable, accessedGlobalsByScope) {
        const usedNames = /* @__PURE__ */ new Set();
        this.addUsedOutsideNames(usedNames, format2, exportNamesByVariable, accessedGlobalsByScope);
        if (this.accessedDynamicImports) {
          for (const importExpression of this.accessedDynamicImports) {
            if (importExpression.inlineNamespace) {
              usedNames.add(importExpression.inlineNamespace.getBaseVariableName());
            }
          }
        }
        for (const [name2, variable] of this.variables) {
          if (variable.included || variable.alwaysRendered) {
            variable.setRenderNames(null, getSafeName(name2, usedNames, variable.forbiddenNames));
          }
        }
        for (const scope of this.children) {
          scope.deconflict(format2, exportNamesByVariable, accessedGlobalsByScope);
        }
      }
      findLexicalBoundary() {
        return this.parent.findLexicalBoundary();
      }
      findVariable(name2) {
        const knownVariable = this.variables.get(name2) || this.accessedOutsideVariables.get(name2);
        if (knownVariable) {
          return knownVariable;
        }
        const variable = this.parent.findVariable(name2);
        this.accessedOutsideVariables.set(name2, variable);
        return variable;
      }
    };
    ParameterScope = class extends ChildScope {
      constructor(parent, context) {
        super(parent);
        this.parameters = [];
        this.hasRest = false;
        this.context = context;
        this.hoistedBodyVarScope = new ChildScope(this);
      }
      /**
       * Adds a parameter to this scope. Parameters must be added in the correct
       * order, i.e. from left to right.
       */
      addParameterDeclaration(identifier) {
        const { name: name2 } = identifier;
        const variable = new ParameterVariable(name2, identifier, this.context);
        const localVariable = this.hoistedBodyVarScope.variables.get(name2);
        if (localVariable) {
          this.hoistedBodyVarScope.variables.set(name2, variable);
          variable.mergeDeclarations(localVariable);
        }
        this.variables.set(name2, variable);
        return variable;
      }
      addParameterVariables(parameters, hasRest) {
        this.parameters = parameters;
        for (const parameterList of parameters) {
          for (const parameter of parameterList) {
            parameter.alwaysRendered = true;
          }
        }
        this.hasRest = hasRest;
      }
      includeCallArguments(context, parameters) {
        let calledFromTryStatement = false;
        let argumentIncluded = false;
        const restParameter = this.hasRest && this.parameters[this.parameters.length - 1];
        for (const checkedArgument of parameters) {
          if (checkedArgument instanceof SpreadElement) {
            for (const argument of parameters) {
              argument.include(context, false);
            }
            break;
          }
        }
        for (let index = parameters.length - 1; index >= 0; index--) {
          const parameterVariables = this.parameters[index] || restParameter;
          const argument = parameters[index];
          if (parameterVariables) {
            calledFromTryStatement = false;
            if (parameterVariables.length === 0) {
              argumentIncluded = true;
            } else {
              for (const variable of parameterVariables) {
                if (variable.included) {
                  argumentIncluded = true;
                }
                if (variable.calledFromTryStatement) {
                  calledFromTryStatement = true;
                }
              }
            }
          }
          if (!argumentIncluded && argument.shouldBeIncluded(context)) {
            argumentIncluded = true;
          }
          if (argumentIncluded) {
            argument.include(context, calledFromTryStatement);
          }
        }
      }
    };
    ReturnValueScope = class extends ParameterScope {
      constructor() {
        super(...arguments);
        this.returnExpression = null;
        this.returnExpressions = [];
      }
      addReturnExpression(expression) {
        this.returnExpressions.push(expression);
      }
      getReturnExpression() {
        if (this.returnExpression === null)
          this.updateReturnExpression();
        return this.returnExpression;
      }
      updateReturnExpression() {
        if (this.returnExpressions.length === 1) {
          this.returnExpression = this.returnExpressions[0];
        } else {
          this.returnExpression = UNKNOWN_EXPRESSION;
          for (const expression of this.returnExpressions) {
            expression.deoptimizePath(UNKNOWN_PATH);
          }
        }
      }
    };
    PureFunctionKey = Symbol("PureFunction");
    doNothing = () => {
    };
    ValueProperties = Symbol("Value Properties");
    getTruthyLiteralValue = () => UnknownTruthyValue;
    returnFalse = () => false;
    returnTrue = () => true;
    PURE = {
      deoptimizeArgumentsOnCall: doNothing,
      getLiteralValue: getTruthyLiteralValue,
      hasEffectsWhenCalled: returnFalse
    };
    IMPURE = {
      deoptimizeArgumentsOnCall: doNothing,
      getLiteralValue: getTruthyLiteralValue,
      hasEffectsWhenCalled: returnTrue
    };
    O = {
      __proto__: null,
      [ValueProperties]: IMPURE
    };
    PF = {
      __proto__: null,
      [ValueProperties]: PURE
    };
    MUTATES_ARG_WITHOUT_ACCESSOR = {
      __proto__: null,
      [ValueProperties]: {
        deoptimizeArgumentsOnCall({ args: [firstArgument] }) {
          firstArgument?.deoptimizePath(UNKNOWN_PATH);
        },
        getLiteralValue: getTruthyLiteralValue,
        hasEffectsWhenCalled({ args }, context) {
          return args.length === 0 || args[0].hasEffectsOnInteractionAtPath(UNKNOWN_NON_ACCESSOR_PATH, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, context);
        }
      }
    };
    C2 = {
      __proto__: null,
      [ValueProperties]: IMPURE,
      prototype: O
    };
    PC = {
      __proto__: null,
      [ValueProperties]: PURE,
      prototype: O
    };
    ARRAY_TYPE = {
      __proto__: null,
      [ValueProperties]: PURE,
      from: PF,
      of: PF,
      prototype: O
    };
    INTL_MEMBER = {
      __proto__: null,
      [ValueProperties]: PURE,
      supportedLocalesOf: PC
    };
    knownGlobals = {
      // Placeholders for global objects to avoid shape mutations
      global: O,
      globalThis: O,
      self: O,
      window: O,
      // Common globals
      __proto__: null,
      [ValueProperties]: IMPURE,
      Array: {
        __proto__: null,
        [ValueProperties]: IMPURE,
        from: O,
        isArray: PF,
        of: PF,
        prototype: O
      },
      ArrayBuffer: {
        __proto__: null,
        [ValueProperties]: PURE,
        isView: PF,
        prototype: O
      },
      Atomics: O,
      BigInt: C2,
      BigInt64Array: C2,
      BigUint64Array: C2,
      Boolean: PC,
      constructor: C2,
      DataView: PC,
      Date: {
        __proto__: null,
        [ValueProperties]: PURE,
        now: PF,
        parse: PF,
        prototype: O,
        UTC: PF
      },
      decodeURI: PF,
      decodeURIComponent: PF,
      encodeURI: PF,
      encodeURIComponent: PF,
      Error: PC,
      escape: PF,
      eval: O,
      EvalError: PC,
      Float32Array: ARRAY_TYPE,
      Float64Array: ARRAY_TYPE,
      Function: C2,
      hasOwnProperty: O,
      Infinity: O,
      Int16Array: ARRAY_TYPE,
      Int32Array: ARRAY_TYPE,
      Int8Array: ARRAY_TYPE,
      isFinite: PF,
      isNaN: PF,
      isPrototypeOf: O,
      JSON: O,
      Map: PC,
      Math: {
        __proto__: null,
        [ValueProperties]: IMPURE,
        abs: PF,
        acos: PF,
        acosh: PF,
        asin: PF,
        asinh: PF,
        atan: PF,
        atan2: PF,
        atanh: PF,
        cbrt: PF,
        ceil: PF,
        clz32: PF,
        cos: PF,
        cosh: PF,
        exp: PF,
        expm1: PF,
        floor: PF,
        fround: PF,
        hypot: PF,
        imul: PF,
        log: PF,
        log10: PF,
        log1p: PF,
        log2: PF,
        max: PF,
        min: PF,
        pow: PF,
        random: PF,
        round: PF,
        sign: PF,
        sin: PF,
        sinh: PF,
        sqrt: PF,
        tan: PF,
        tanh: PF,
        trunc: PF
      },
      NaN: O,
      Number: {
        __proto__: null,
        [ValueProperties]: PURE,
        isFinite: PF,
        isInteger: PF,
        isNaN: PF,
        isSafeInteger: PF,
        parseFloat: PF,
        parseInt: PF,
        prototype: O
      },
      Object: {
        __proto__: null,
        [ValueProperties]: PURE,
        create: PF,
        // Technically those can throw in certain situations, but we ignore this as
        // code that relies on this will hopefully wrap this in a try-catch, which
        // deoptimizes everything anyway
        defineProperty: MUTATES_ARG_WITHOUT_ACCESSOR,
        defineProperties: MUTATES_ARG_WITHOUT_ACCESSOR,
        freeze: MUTATES_ARG_WITHOUT_ACCESSOR,
        getOwnPropertyDescriptor: PF,
        getOwnPropertyDescriptors: PF,
        getOwnPropertyNames: PF,
        getOwnPropertySymbols: PF,
        getPrototypeOf: PF,
        hasOwn: PF,
        is: PF,
        isExtensible: PF,
        isFrozen: PF,
        isSealed: PF,
        keys: PF,
        fromEntries: PF,
        entries: PF,
        prototype: O
      },
      parseFloat: PF,
      parseInt: PF,
      Promise: {
        __proto__: null,
        [ValueProperties]: IMPURE,
        all: O,
        allSettled: O,
        any: O,
        prototype: O,
        race: O,
        reject: O,
        resolve: O
      },
      propertyIsEnumerable: O,
      Proxy: O,
      RangeError: PC,
      ReferenceError: PC,
      Reflect: O,
      RegExp: PC,
      Set: PC,
      SharedArrayBuffer: C2,
      String: {
        __proto__: null,
        [ValueProperties]: PURE,
        fromCharCode: PF,
        fromCodePoint: PF,
        prototype: O,
        raw: PF
      },
      Symbol: {
        __proto__: null,
        [ValueProperties]: PURE,
        for: PF,
        keyFor: PF,
        prototype: O,
        toStringTag: {
          __proto__: null,
          [ValueProperties]: {
            deoptimizeArgumentsOnCall: doNothing,
            getLiteralValue() {
              return SymbolToStringTag;
            },
            hasEffectsWhenCalled: returnTrue
          }
        }
      },
      SyntaxError: PC,
      toLocaleString: O,
      toString: O,
      TypeError: PC,
      Uint16Array: ARRAY_TYPE,
      Uint32Array: ARRAY_TYPE,
      Uint8Array: ARRAY_TYPE,
      Uint8ClampedArray: ARRAY_TYPE,
      // Technically, this is a global, but it needs special handling
      // undefined: ?,
      unescape: PF,
      URIError: PC,
      valueOf: O,
      WeakMap: PC,
      WeakSet: PC,
      // Additional globals shared by Node and Browser that are not strictly part of the language
      clearInterval: C2,
      clearTimeout: C2,
      console: {
        __proto__: null,
        [ValueProperties]: IMPURE,
        assert: C2,
        clear: C2,
        count: C2,
        countReset: C2,
        debug: C2,
        dir: C2,
        dirxml: C2,
        error: C2,
        exception: C2,
        group: C2,
        groupCollapsed: C2,
        groupEnd: C2,
        info: C2,
        log: C2,
        table: C2,
        time: C2,
        timeEnd: C2,
        timeLog: C2,
        trace: C2,
        warn: C2
      },
      Intl: {
        __proto__: null,
        [ValueProperties]: IMPURE,
        Collator: INTL_MEMBER,
        DateTimeFormat: INTL_MEMBER,
        ListFormat: INTL_MEMBER,
        NumberFormat: INTL_MEMBER,
        PluralRules: INTL_MEMBER,
        RelativeTimeFormat: INTL_MEMBER
      },
      setInterval: C2,
      setTimeout: C2,
      TextDecoder: C2,
      TextEncoder: C2,
      URL: C2,
      URLSearchParams: C2,
      // Browser specific globals
      AbortController: C2,
      AbortSignal: C2,
      addEventListener: O,
      alert: O,
      AnalyserNode: C2,
      Animation: C2,
      AnimationEvent: C2,
      applicationCache: O,
      ApplicationCache: C2,
      ApplicationCacheErrorEvent: C2,
      atob: O,
      Attr: C2,
      Audio: C2,
      AudioBuffer: C2,
      AudioBufferSourceNode: C2,
      AudioContext: C2,
      AudioDestinationNode: C2,
      AudioListener: C2,
      AudioNode: C2,
      AudioParam: C2,
      AudioProcessingEvent: C2,
      AudioScheduledSourceNode: C2,
      AudioWorkletNode: C2,
      BarProp: C2,
      BaseAudioContext: C2,
      BatteryManager: C2,
      BeforeUnloadEvent: C2,
      BiquadFilterNode: C2,
      Blob: C2,
      BlobEvent: C2,
      blur: O,
      BroadcastChannel: C2,
      btoa: O,
      ByteLengthQueuingStrategy: C2,
      Cache: C2,
      caches: O,
      CacheStorage: C2,
      cancelAnimationFrame: O,
      cancelIdleCallback: O,
      CanvasCaptureMediaStreamTrack: C2,
      CanvasGradient: C2,
      CanvasPattern: C2,
      CanvasRenderingContext2D: C2,
      ChannelMergerNode: C2,
      ChannelSplitterNode: C2,
      CharacterData: C2,
      clientInformation: O,
      ClipboardEvent: C2,
      close: O,
      closed: O,
      CloseEvent: C2,
      Comment: C2,
      CompositionEvent: C2,
      confirm: O,
      ConstantSourceNode: C2,
      ConvolverNode: C2,
      CountQueuingStrategy: C2,
      createImageBitmap: O,
      Credential: C2,
      CredentialsContainer: C2,
      crypto: O,
      Crypto: C2,
      CryptoKey: C2,
      CSS: C2,
      CSSConditionRule: C2,
      CSSFontFaceRule: C2,
      CSSGroupingRule: C2,
      CSSImportRule: C2,
      CSSKeyframeRule: C2,
      CSSKeyframesRule: C2,
      CSSMediaRule: C2,
      CSSNamespaceRule: C2,
      CSSPageRule: C2,
      CSSRule: C2,
      CSSRuleList: C2,
      CSSStyleDeclaration: C2,
      CSSStyleRule: C2,
      CSSStyleSheet: C2,
      CSSSupportsRule: C2,
      CustomElementRegistry: C2,
      customElements: O,
      CustomEvent: C2,
      DataTransfer: C2,
      DataTransferItem: C2,
      DataTransferItemList: C2,
      defaultstatus: O,
      defaultStatus: O,
      DelayNode: C2,
      DeviceMotionEvent: C2,
      DeviceOrientationEvent: C2,
      devicePixelRatio: O,
      dispatchEvent: O,
      document: O,
      Document: C2,
      DocumentFragment: C2,
      DocumentType: C2,
      DOMError: C2,
      DOMException: C2,
      DOMImplementation: C2,
      DOMMatrix: C2,
      DOMMatrixReadOnly: C2,
      DOMParser: C2,
      DOMPoint: C2,
      DOMPointReadOnly: C2,
      DOMQuad: C2,
      DOMRect: C2,
      DOMRectReadOnly: C2,
      DOMStringList: C2,
      DOMStringMap: C2,
      DOMTokenList: C2,
      DragEvent: C2,
      DynamicsCompressorNode: C2,
      Element: C2,
      ErrorEvent: C2,
      Event: C2,
      EventSource: C2,
      EventTarget: C2,
      external: O,
      fetch: O,
      File: C2,
      FileList: C2,
      FileReader: C2,
      find: O,
      focus: O,
      FocusEvent: C2,
      FontFace: C2,
      FontFaceSetLoadEvent: C2,
      FormData: C2,
      frames: O,
      GainNode: C2,
      Gamepad: C2,
      GamepadButton: C2,
      GamepadEvent: C2,
      getComputedStyle: O,
      getSelection: O,
      HashChangeEvent: C2,
      Headers: C2,
      history: O,
      History: C2,
      HTMLAllCollection: C2,
      HTMLAnchorElement: C2,
      HTMLAreaElement: C2,
      HTMLAudioElement: C2,
      HTMLBaseElement: C2,
      HTMLBodyElement: C2,
      HTMLBRElement: C2,
      HTMLButtonElement: C2,
      HTMLCanvasElement: C2,
      HTMLCollection: C2,
      HTMLContentElement: C2,
      HTMLDataElement: C2,
      HTMLDataListElement: C2,
      HTMLDetailsElement: C2,
      HTMLDialogElement: C2,
      HTMLDirectoryElement: C2,
      HTMLDivElement: C2,
      HTMLDListElement: C2,
      HTMLDocument: C2,
      HTMLElement: C2,
      HTMLEmbedElement: C2,
      HTMLFieldSetElement: C2,
      HTMLFontElement: C2,
      HTMLFormControlsCollection: C2,
      HTMLFormElement: C2,
      HTMLFrameElement: C2,
      HTMLFrameSetElement: C2,
      HTMLHeadElement: C2,
      HTMLHeadingElement: C2,
      HTMLHRElement: C2,
      HTMLHtmlElement: C2,
      HTMLIFrameElement: C2,
      HTMLImageElement: C2,
      HTMLInputElement: C2,
      HTMLLabelElement: C2,
      HTMLLegendElement: C2,
      HTMLLIElement: C2,
      HTMLLinkElement: C2,
      HTMLMapElement: C2,
      HTMLMarqueeElement: C2,
      HTMLMediaElement: C2,
      HTMLMenuElement: C2,
      HTMLMetaElement: C2,
      HTMLMeterElement: C2,
      HTMLModElement: C2,
      HTMLObjectElement: C2,
      HTMLOListElement: C2,
      HTMLOptGroupElement: C2,
      HTMLOptionElement: C2,
      HTMLOptionsCollection: C2,
      HTMLOutputElement: C2,
      HTMLParagraphElement: C2,
      HTMLParamElement: C2,
      HTMLPictureElement: C2,
      HTMLPreElement: C2,
      HTMLProgressElement: C2,
      HTMLQuoteElement: C2,
      HTMLScriptElement: C2,
      HTMLSelectElement: C2,
      HTMLShadowElement: C2,
      HTMLSlotElement: C2,
      HTMLSourceElement: C2,
      HTMLSpanElement: C2,
      HTMLStyleElement: C2,
      HTMLTableCaptionElement: C2,
      HTMLTableCellElement: C2,
      HTMLTableColElement: C2,
      HTMLTableElement: C2,
      HTMLTableRowElement: C2,
      HTMLTableSectionElement: C2,
      HTMLTemplateElement: C2,
      HTMLTextAreaElement: C2,
      HTMLTimeElement: C2,
      HTMLTitleElement: C2,
      HTMLTrackElement: C2,
      HTMLUListElement: C2,
      HTMLUnknownElement: C2,
      HTMLVideoElement: C2,
      IDBCursor: C2,
      IDBCursorWithValue: C2,
      IDBDatabase: C2,
      IDBFactory: C2,
      IDBIndex: C2,
      IDBKeyRange: C2,
      IDBObjectStore: C2,
      IDBOpenDBRequest: C2,
      IDBRequest: C2,
      IDBTransaction: C2,
      IDBVersionChangeEvent: C2,
      IdleDeadline: C2,
      IIRFilterNode: C2,
      Image: C2,
      ImageBitmap: C2,
      ImageBitmapRenderingContext: C2,
      ImageCapture: C2,
      ImageData: C2,
      indexedDB: O,
      innerHeight: O,
      innerWidth: O,
      InputEvent: C2,
      IntersectionObserver: C2,
      IntersectionObserverEntry: C2,
      isSecureContext: O,
      KeyboardEvent: C2,
      KeyframeEffect: C2,
      length: O,
      localStorage: O,
      location: O,
      Location: C2,
      locationbar: O,
      matchMedia: O,
      MediaDeviceInfo: C2,
      MediaDevices: C2,
      MediaElementAudioSourceNode: C2,
      MediaEncryptedEvent: C2,
      MediaError: C2,
      MediaKeyMessageEvent: C2,
      MediaKeySession: C2,
      MediaKeyStatusMap: C2,
      MediaKeySystemAccess: C2,
      MediaList: C2,
      MediaQueryList: C2,
      MediaQueryListEvent: C2,
      MediaRecorder: C2,
      MediaSettingsRange: C2,
      MediaSource: C2,
      MediaStream: C2,
      MediaStreamAudioDestinationNode: C2,
      MediaStreamAudioSourceNode: C2,
      MediaStreamEvent: C2,
      MediaStreamTrack: C2,
      MediaStreamTrackEvent: C2,
      menubar: O,
      MessageChannel: C2,
      MessageEvent: C2,
      MessagePort: C2,
      MIDIAccess: C2,
      MIDIConnectionEvent: C2,
      MIDIInput: C2,
      MIDIInputMap: C2,
      MIDIMessageEvent: C2,
      MIDIOutput: C2,
      MIDIOutputMap: C2,
      MIDIPort: C2,
      MimeType: C2,
      MimeTypeArray: C2,
      MouseEvent: C2,
      moveBy: O,
      moveTo: O,
      MutationEvent: C2,
      MutationObserver: C2,
      MutationRecord: C2,
      name: O,
      NamedNodeMap: C2,
      NavigationPreloadManager: C2,
      navigator: O,
      Navigator: C2,
      NetworkInformation: C2,
      Node: C2,
      NodeFilter: O,
      NodeIterator: C2,
      NodeList: C2,
      Notification: C2,
      OfflineAudioCompletionEvent: C2,
      OfflineAudioContext: C2,
      offscreenBuffering: O,
      OffscreenCanvas: C2,
      open: O,
      openDatabase: O,
      Option: C2,
      origin: O,
      OscillatorNode: C2,
      outerHeight: O,
      outerWidth: O,
      PageTransitionEvent: C2,
      pageXOffset: O,
      pageYOffset: O,
      PannerNode: C2,
      parent: O,
      Path2D: C2,
      PaymentAddress: C2,
      PaymentRequest: C2,
      PaymentRequestUpdateEvent: C2,
      PaymentResponse: C2,
      performance: O,
      Performance: C2,
      PerformanceEntry: C2,
      PerformanceLongTaskTiming: C2,
      PerformanceMark: C2,
      PerformanceMeasure: C2,
      PerformanceNavigation: C2,
      PerformanceNavigationTiming: C2,
      PerformanceObserver: C2,
      PerformanceObserverEntryList: C2,
      PerformancePaintTiming: C2,
      PerformanceResourceTiming: C2,
      PerformanceTiming: C2,
      PeriodicWave: C2,
      Permissions: C2,
      PermissionStatus: C2,
      personalbar: O,
      PhotoCapabilities: C2,
      Plugin: C2,
      PluginArray: C2,
      PointerEvent: C2,
      PopStateEvent: C2,
      postMessage: O,
      Presentation: C2,
      PresentationAvailability: C2,
      PresentationConnection: C2,
      PresentationConnectionAvailableEvent: C2,
      PresentationConnectionCloseEvent: C2,
      PresentationConnectionList: C2,
      PresentationReceiver: C2,
      PresentationRequest: C2,
      print: O,
      ProcessingInstruction: C2,
      ProgressEvent: C2,
      PromiseRejectionEvent: C2,
      prompt: O,
      PushManager: C2,
      PushSubscription: C2,
      PushSubscriptionOptions: C2,
      queueMicrotask: O,
      RadioNodeList: C2,
      Range: C2,
      ReadableStream: C2,
      RemotePlayback: C2,
      removeEventListener: O,
      Request: C2,
      requestAnimationFrame: O,
      requestIdleCallback: O,
      resizeBy: O,
      ResizeObserver: C2,
      ResizeObserverEntry: C2,
      resizeTo: O,
      Response: C2,
      RTCCertificate: C2,
      RTCDataChannel: C2,
      RTCDataChannelEvent: C2,
      RTCDtlsTransport: C2,
      RTCIceCandidate: C2,
      RTCIceTransport: C2,
      RTCPeerConnection: C2,
      RTCPeerConnectionIceEvent: C2,
      RTCRtpReceiver: C2,
      RTCRtpSender: C2,
      RTCSctpTransport: C2,
      RTCSessionDescription: C2,
      RTCStatsReport: C2,
      RTCTrackEvent: C2,
      screen: O,
      Screen: C2,
      screenLeft: O,
      ScreenOrientation: C2,
      screenTop: O,
      screenX: O,
      screenY: O,
      ScriptProcessorNode: C2,
      scroll: O,
      scrollbars: O,
      scrollBy: O,
      scrollTo: O,
      scrollX: O,
      scrollY: O,
      SecurityPolicyViolationEvent: C2,
      Selection: C2,
      ServiceWorker: C2,
      ServiceWorkerContainer: C2,
      ServiceWorkerRegistration: C2,
      sessionStorage: O,
      ShadowRoot: C2,
      SharedWorker: C2,
      SourceBuffer: C2,
      SourceBufferList: C2,
      speechSynthesis: O,
      SpeechSynthesisEvent: C2,
      SpeechSynthesisUtterance: C2,
      StaticRange: C2,
      status: O,
      statusbar: O,
      StereoPannerNode: C2,
      stop: O,
      Storage: C2,
      StorageEvent: C2,
      StorageManager: C2,
      styleMedia: O,
      StyleSheet: C2,
      StyleSheetList: C2,
      SubtleCrypto: C2,
      SVGAElement: C2,
      SVGAngle: C2,
      SVGAnimatedAngle: C2,
      SVGAnimatedBoolean: C2,
      SVGAnimatedEnumeration: C2,
      SVGAnimatedInteger: C2,
      SVGAnimatedLength: C2,
      SVGAnimatedLengthList: C2,
      SVGAnimatedNumber: C2,
      SVGAnimatedNumberList: C2,
      SVGAnimatedPreserveAspectRatio: C2,
      SVGAnimatedRect: C2,
      SVGAnimatedString: C2,
      SVGAnimatedTransformList: C2,
      SVGAnimateElement: C2,
      SVGAnimateMotionElement: C2,
      SVGAnimateTransformElement: C2,
      SVGAnimationElement: C2,
      SVGCircleElement: C2,
      SVGClipPathElement: C2,
      SVGComponentTransferFunctionElement: C2,
      SVGDefsElement: C2,
      SVGDescElement: C2,
      SVGDiscardElement: C2,
      SVGElement: C2,
      SVGEllipseElement: C2,
      SVGFEBlendElement: C2,
      SVGFEColorMatrixElement: C2,
      SVGFEComponentTransferElement: C2,
      SVGFECompositeElement: C2,
      SVGFEConvolveMatrixElement: C2,
      SVGFEDiffuseLightingElement: C2,
      SVGFEDisplacementMapElement: C2,
      SVGFEDistantLightElement: C2,
      SVGFEDropShadowElement: C2,
      SVGFEFloodElement: C2,
      SVGFEFuncAElement: C2,
      SVGFEFuncBElement: C2,
      SVGFEFuncGElement: C2,
      SVGFEFuncRElement: C2,
      SVGFEGaussianBlurElement: C2,
      SVGFEImageElement: C2,
      SVGFEMergeElement: C2,
      SVGFEMergeNodeElement: C2,
      SVGFEMorphologyElement: C2,
      SVGFEOffsetElement: C2,
      SVGFEPointLightElement: C2,
      SVGFESpecularLightingElement: C2,
      SVGFESpotLightElement: C2,
      SVGFETileElement: C2,
      SVGFETurbulenceElement: C2,
      SVGFilterElement: C2,
      SVGForeignObjectElement: C2,
      SVGGElement: C2,
      SVGGeometryElement: C2,
      SVGGradientElement: C2,
      SVGGraphicsElement: C2,
      SVGImageElement: C2,
      SVGLength: C2,
      SVGLengthList: C2,
      SVGLinearGradientElement: C2,
      SVGLineElement: C2,
      SVGMarkerElement: C2,
      SVGMaskElement: C2,
      SVGMatrix: C2,
      SVGMetadataElement: C2,
      SVGMPathElement: C2,
      SVGNumber: C2,
      SVGNumberList: C2,
      SVGPathElement: C2,
      SVGPatternElement: C2,
      SVGPoint: C2,
      SVGPointList: C2,
      SVGPolygonElement: C2,
      SVGPolylineElement: C2,
      SVGPreserveAspectRatio: C2,
      SVGRadialGradientElement: C2,
      SVGRect: C2,
      SVGRectElement: C2,
      SVGScriptElement: C2,
      SVGSetElement: C2,
      SVGStopElement: C2,
      SVGStringList: C2,
      SVGStyleElement: C2,
      SVGSVGElement: C2,
      SVGSwitchElement: C2,
      SVGSymbolElement: C2,
      SVGTextContentElement: C2,
      SVGTextElement: C2,
      SVGTextPathElement: C2,
      SVGTextPositioningElement: C2,
      SVGTitleElement: C2,
      SVGTransform: C2,
      SVGTransformList: C2,
      SVGTSpanElement: C2,
      SVGUnitTypes: C2,
      SVGUseElement: C2,
      SVGViewElement: C2,
      TaskAttributionTiming: C2,
      Text: C2,
      TextEvent: C2,
      TextMetrics: C2,
      TextTrack: C2,
      TextTrackCue: C2,
      TextTrackCueList: C2,
      TextTrackList: C2,
      TimeRanges: C2,
      toolbar: O,
      top: O,
      Touch: C2,
      TouchEvent: C2,
      TouchList: C2,
      TrackEvent: C2,
      TransitionEvent: C2,
      TreeWalker: C2,
      UIEvent: C2,
      ValidityState: C2,
      visualViewport: O,
      VisualViewport: C2,
      VTTCue: C2,
      WaveShaperNode: C2,
      WebAssembly: O,
      WebGL2RenderingContext: C2,
      WebGLActiveInfo: C2,
      WebGLBuffer: C2,
      WebGLContextEvent: C2,
      WebGLFramebuffer: C2,
      WebGLProgram: C2,
      WebGLQuery: C2,
      WebGLRenderbuffer: C2,
      WebGLRenderingContext: C2,
      WebGLSampler: C2,
      WebGLShader: C2,
      WebGLShaderPrecisionFormat: C2,
      WebGLSync: C2,
      WebGLTexture: C2,
      WebGLTransformFeedback: C2,
      WebGLUniformLocation: C2,
      WebGLVertexArrayObject: C2,
      WebSocket: C2,
      WheelEvent: C2,
      Window: C2,
      Worker: C2,
      WritableStream: C2,
      XMLDocument: C2,
      XMLHttpRequest: C2,
      XMLHttpRequestEventTarget: C2,
      XMLHttpRequestUpload: C2,
      XMLSerializer: C2,
      XPathEvaluator: C2,
      XPathExpression: C2,
      XPathResult: C2,
      XSLTProcessor: C2
    };
    for (const global2 of ["window", "global", "self", "globalThis"]) {
      knownGlobals[global2] = knownGlobals;
    }
    GlobalVariable = class extends Variable {
      constructor() {
        super(...arguments);
        this.isReassigned = true;
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker) {
        switch (interaction.type) {
          case INTERACTION_ACCESSED:
          case INTERACTION_ASSIGNED: {
            if (!getGlobalAtPath([this.name, ...path4].slice(0, -1))) {
              super.deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker);
            }
            return;
          }
          case INTERACTION_CALLED: {
            const globalAtPath = getGlobalAtPath([this.name, ...path4]);
            if (globalAtPath) {
              globalAtPath.deoptimizeArgumentsOnCall(interaction);
            } else {
              super.deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker);
            }
            return;
          }
        }
      }
      getLiteralValueAtPath(path4, _recursionTracker, _origin) {
        const globalAtPath = getGlobalAtPath([this.name, ...path4]);
        return globalAtPath ? globalAtPath.getLiteralValue() : UnknownValue;
      }
      hasEffectsOnInteractionAtPath(path4, interaction, context) {
        switch (interaction.type) {
          case INTERACTION_ACCESSED: {
            if (path4.length === 0) {
              return this.name !== "undefined" && !getGlobalAtPath([this.name]);
            }
            return !getGlobalAtPath([this.name, ...path4].slice(0, -1));
          }
          case INTERACTION_ASSIGNED: {
            return true;
          }
          case INTERACTION_CALLED: {
            const globalAtPath = getGlobalAtPath([this.name, ...path4]);
            return !globalAtPath || globalAtPath.hasEffectsWhenCalled(interaction, context);
          }
        }
      }
    };
    tdzVariableKinds = {
      __proto__: null,
      class: true,
      const: true,
      let: true,
      var: true
    };
    Identifier = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.variable = null;
        this.isTDZAccess = null;
      }
      addExportedVariables(variables, exportNamesByVariable) {
        if (exportNamesByVariable.has(this.variable)) {
          variables.push(this.variable);
        }
      }
      bind() {
        if (!this.variable && is_reference(this, this.parent)) {
          this.variable = this.scope.findVariable(this.name);
          this.variable.addReference(this);
        }
      }
      declare(kind, init4) {
        let variable;
        const { treeshake } = this.context.options;
        switch (kind) {
          case "var": {
            variable = this.scope.addDeclaration(this, this.context, init4, true);
            if (treeshake && treeshake.correctVarValueBeforeDeclaration) {
              variable.markInitializersForDeoptimization();
            }
            break;
          }
          case "function": {
            variable = this.scope.addDeclaration(this, this.context, init4, false);
            break;
          }
          case "let":
          case "const":
          case "class": {
            variable = this.scope.addDeclaration(this, this.context, init4, false);
            break;
          }
          case "parameter": {
            variable = this.scope.addParameterDeclaration(this);
            break;
          }
          default: {
            throw new Error(`Internal Error: Unexpected identifier kind ${kind}.`);
          }
        }
        variable.kind = kind;
        return [this.variable = variable];
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker) {
        this.variable.deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker);
      }
      deoptimizePath(path4) {
        if (path4.length === 0 && !this.scope.contains(this.name)) {
          this.disallowImportReassignment();
        }
        this.variable?.deoptimizePath(path4);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        return this.getVariableRespectingTDZ().getLiteralValueAtPath(path4, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path4, interaction, recursionTracker, origin) {
        const [expression, isPure] = this.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(path4, interaction, recursionTracker, origin);
        return [expression, isPure || this.isPureFunction(path4)];
      }
      hasEffects(context) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        if (this.isPossibleTDZ() && this.variable.kind !== "var") {
          return true;
        }
        return this.context.options.treeshake.unknownGlobalSideEffects && this.variable instanceof GlobalVariable && !this.isPureFunction(EMPTY_PATH) && this.variable.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_ACCESS, context);
      }
      hasEffectsOnInteractionAtPath(path4, interaction, context) {
        switch (interaction.type) {
          case INTERACTION_ACCESSED: {
            return this.variable !== null && !this.isPureFunction(path4) && this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(path4, interaction, context);
          }
          case INTERACTION_ASSIGNED: {
            return (path4.length > 0 ? this.getVariableRespectingTDZ() : this.variable).hasEffectsOnInteractionAtPath(path4, interaction, context);
          }
          case INTERACTION_CALLED: {
            return !this.isPureFunction(path4) && this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(path4, interaction, context);
          }
        }
      }
      include() {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        if (!this.included) {
          this.included = true;
          if (this.variable !== null) {
            this.context.includeVariableInModule(this.variable);
          }
        }
      }
      includeCallArguments(context, parameters) {
        this.variable.includeCallArguments(context, parameters);
      }
      isPossibleTDZ() {
        if (this.isTDZAccess !== null)
          return this.isTDZAccess;
        if (!(this.variable instanceof LocalVariable && this.variable.kind && this.variable.kind in tdzVariableKinds && // we ignore possible TDZs due to circular module dependencies as
        // otherwise we get many false positives
        this.variable.module === this.context.module)) {
          return this.isTDZAccess = false;
        }
        let decl_id;
        if (this.variable.declarations && this.variable.declarations.length === 1 && (decl_id = this.variable.declarations[0]) && this.start < decl_id.start && closestParentFunctionOrProgram(this) === closestParentFunctionOrProgram(decl_id)) {
          return this.isTDZAccess = true;
        }
        if (!this.variable.initReached) {
          return this.isTDZAccess = true;
        }
        return this.isTDZAccess = false;
      }
      markDeclarationReached() {
        this.variable.initReached = true;
      }
      render(code, { snippets: { getPropertyAccess }, useOriginalName }, { renderedParentType, isCalleeOfRenderedParent, isShorthandProperty } = BLANK) {
        if (this.variable) {
          const name2 = this.variable.getName(getPropertyAccess, useOriginalName);
          if (name2 !== this.name) {
            code.overwrite(this.start, this.end, name2, {
              contentOnly: true,
              storeName: true
            });
            if (isShorthandProperty) {
              code.prependRight(this.start, `${this.name}: `);
            }
          }
          if (name2 === "eval" && renderedParentType === CallExpression$1 && isCalleeOfRenderedParent) {
            code.appendRight(this.start, "0, ");
          }
        }
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        if (this.variable instanceof LocalVariable) {
          this.variable.consolidateInitializers();
          this.context.requestTreeshakingPass();
        }
      }
      disallowImportReassignment() {
        return this.context.error(errorIllegalImportReassignment(this.name, this.context.module.id), this.start);
      }
      getVariableRespectingTDZ() {
        if (this.isPossibleTDZ()) {
          return UNKNOWN_EXPRESSION;
        }
        return this.variable;
      }
      isPureFunction(path4) {
        let currentPureFunction = this.context.manualPureFunctions[this.name];
        for (const segment of path4) {
          if (currentPureFunction) {
            if (currentPureFunction[PureFunctionKey]) {
              return true;
            }
            currentPureFunction = currentPureFunction[segment];
          } else {
            return false;
          }
        }
        return currentPureFunction?.[PureFunctionKey];
      }
    };
    NON_WHITESPACE = /\S/g;
    BlockScope = class extends ChildScope {
      addDeclaration(identifier, context, init4, isHoisted) {
        if (isHoisted) {
          const variable = this.parent.addDeclaration(identifier, context, init4, isHoisted);
          variable.markInitializersForDeoptimization();
          return variable;
        } else {
          return super.addDeclaration(identifier, context, init4, false);
        }
      }
    };
    ExpressionStatement = class extends NodeBase {
      initialise() {
        if (this.directive && this.directive !== "use strict" && this.parent.type === Program$1) {
          this.context.warn(
            // This is necessary, because either way (deleting or not) can lead to errors.
            errorModuleLevelDirective(this.directive, this.context.module.id),
            this.start
          );
        }
      }
      render(code, options2) {
        super.render(code, options2);
        if (this.included)
          this.insertSemicolon(code);
      }
      shouldBeIncluded(context) {
        if (this.directive && this.directive !== "use strict")
          return this.parent.type !== Program$1;
        return super.shouldBeIncluded(context);
      }
      applyDeoptimizations() {
      }
    };
    BlockStatement = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.directlyIncluded = false;
      }
      addImplicitReturnExpressionToScope() {
        const lastStatement = this.body[this.body.length - 1];
        if (!lastStatement || lastStatement.type !== ReturnStatement$1) {
          this.scope.addReturnExpression(UNKNOWN_EXPRESSION);
        }
      }
      createScope(parentScope) {
        this.scope = this.parent.preventChildBlockScope ? parentScope : new BlockScope(parentScope);
      }
      hasEffects(context) {
        if (this.deoptimizeBody)
          return true;
        for (const node2 of this.body) {
          if (context.brokenFlow)
            break;
          if (node2.hasEffects(context))
            return true;
        }
        return false;
      }
      include(context, includeChildrenRecursively) {
        if (!(this.deoptimizeBody && this.directlyIncluded)) {
          this.included = true;
          this.directlyIncluded = true;
          if (this.deoptimizeBody)
            includeChildrenRecursively = true;
          for (const node2 of this.body) {
            if (includeChildrenRecursively || node2.shouldBeIncluded(context))
              node2.include(context, includeChildrenRecursively);
          }
        }
      }
      initialise() {
        const firstBodyStatement = this.body[0];
        this.deoptimizeBody = firstBodyStatement instanceof ExpressionStatement && firstBodyStatement.directive === "use asm";
      }
      render(code, options2) {
        if (this.body.length > 0) {
          renderStatementList(this.body, code, this.start + 1, this.end - 1, options2);
        } else {
          super.render(code, options2);
        }
      }
    };
    RestElement = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.declarationInit = null;
      }
      addExportedVariables(variables, exportNamesByVariable) {
        this.argument.addExportedVariables(variables, exportNamesByVariable);
      }
      declare(kind, init4) {
        this.declarationInit = init4;
        return this.argument.declare(kind, UNKNOWN_EXPRESSION);
      }
      deoptimizePath(path4) {
        path4.length === 0 && this.argument.deoptimizePath(EMPTY_PATH);
      }
      hasEffectsOnInteractionAtPath(path4, interaction, context) {
        return path4.length > 0 || this.argument.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context);
      }
      markDeclarationReached() {
        this.argument.markDeclarationReached();
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        if (this.declarationInit !== null) {
          this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);
          this.context.requestTreeshakingPass();
        }
      }
    };
    FunctionBase = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.objectEntity = null;
        this.deoptimizedReturn = false;
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker) {
        if (interaction.type === INTERACTION_CALLED) {
          const { parameters } = this.scope;
          const { args } = interaction;
          let hasRest = false;
          for (let position = 0; position < args.length; position++) {
            const parameter = this.params[position];
            if (hasRest || parameter instanceof RestElement) {
              hasRest = true;
              args[position].deoptimizePath(UNKNOWN_PATH);
            } else if (parameter instanceof Identifier) {
              parameters[position][0].addEntityToBeDeoptimized(args[position]);
            } else if (parameter) {
              args[position].deoptimizePath(UNKNOWN_PATH);
            }
          }
        } else {
          this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker);
        }
      }
      deoptimizePath(path4) {
        this.getObjectEntity().deoptimizePath(path4);
        if (path4.length === 1 && path4[0] === UnknownKey) {
          this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
        }
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        return this.getObjectEntity().getLiteralValueAtPath(path4, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path4, interaction, recursionTracker, origin) {
        if (path4.length > 0) {
          return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path4, interaction, recursionTracker, origin);
        }
        if (this.async) {
          if (!this.deoptimizedReturn) {
            this.deoptimizedReturn = true;
            this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);
            this.context.requestTreeshakingPass();
          }
          return UNKNOWN_RETURN_EXPRESSION;
        }
        return [this.scope.getReturnExpression(), false];
      }
      hasEffectsOnInteractionAtPath(path4, interaction, context) {
        if (path4.length > 0 || interaction.type !== INTERACTION_CALLED) {
          return this.getObjectEntity().hasEffectsOnInteractionAtPath(path4, interaction, context);
        }
        if (this.async) {
          const { propertyReadSideEffects } = this.context.options.treeshake;
          const returnExpression = this.scope.getReturnExpression();
          if (returnExpression.hasEffectsOnInteractionAtPath(["then"], NODE_INTERACTION_UNKNOWN_CALL, context) || propertyReadSideEffects && (propertyReadSideEffects === "always" || returnExpression.hasEffectsOnInteractionAtPath(["then"], NODE_INTERACTION_UNKNOWN_ACCESS, context))) {
            return true;
          }
        }
        for (const parameter of this.params) {
          if (parameter.hasEffects(context))
            return true;
        }
        return false;
      }
      include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.included = true;
        const { brokenFlow } = context;
        context.brokenFlow = BROKEN_FLOW_NONE;
        this.body.include(context, includeChildrenRecursively);
        context.brokenFlow = brokenFlow;
      }
      includeCallArguments(context, parameters) {
        this.scope.includeCallArguments(context, parameters);
      }
      initialise() {
        this.scope.addParameterVariables(this.params.map((parameter) => parameter.declare("parameter", UNKNOWN_EXPRESSION)), this.params[this.params.length - 1] instanceof RestElement);
        if (this.body instanceof BlockStatement) {
          this.body.addImplicitReturnExpressionToScope();
        } else {
          this.scope.addReturnExpression(this.body);
        }
      }
      parseNode(esTreeNode) {
        if (esTreeNode.body.type === BlockStatement$1) {
          this.body = new BlockStatement(esTreeNode.body, this, this.scope.hoistedBodyVarScope);
        }
        super.parseNode(esTreeNode);
      }
      applyDeoptimizations() {
      }
    };
    FunctionBase.prototype.preventChildBlockScope = true;
    ArgumentsVariable = class extends LocalVariable {
      constructor(context) {
        super("arguments", null, UNKNOWN_EXPRESSION, context);
      }
      hasEffectsOnInteractionAtPath(path4, { type }) {
        return type !== INTERACTION_ACCESSED || path4.length > 1;
      }
    };
    ThisVariable = class extends ParameterVariable {
      constructor(context) {
        super("this", null, context);
      }
      hasEffectsOnInteractionAtPath(path4, interaction, context) {
        return (context.replacedVariableInits.get(this) || UNKNOWN_EXPRESSION).hasEffectsOnInteractionAtPath(path4, interaction, context);
      }
    };
    FunctionScope = class extends ReturnValueScope {
      constructor(parent, context) {
        super(parent, context);
        this.variables.set("arguments", this.argumentsVariable = new ArgumentsVariable(context));
        this.variables.set("this", this.thisVariable = new ThisVariable(context));
      }
      findLexicalBoundary() {
        return this;
      }
      includeCallArguments(context, parameters) {
        super.includeCallArguments(context, parameters);
        if (this.argumentsVariable.included) {
          for (const argument of parameters) {
            if (!argument.included) {
              argument.include(context, false);
            }
          }
        }
      }
    };
    FunctionNode = class extends FunctionBase {
      constructor() {
        super(...arguments);
        this.objectEntity = null;
      }
      createScope(parentScope) {
        this.scope = new FunctionScope(parentScope, this.context);
        this.constructedEntity = new ObjectEntity(/* @__PURE__ */ Object.create(null), OBJECT_PROTOTYPE);
        this.scope.thisVariable.addEntityToBeDeoptimized(this.constructedEntity);
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker) {
        super.deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker);
        if (interaction.type === INTERACTION_CALLED && path4.length === 0 && interaction.thisArg) {
          this.scope.thisVariable.addEntityToBeDeoptimized(interaction.thisArg);
        }
      }
      hasEffects(context) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        return !!this.id?.hasEffects(context);
      }
      hasEffectsOnInteractionAtPath(path4, interaction, context) {
        if (super.hasEffectsOnInteractionAtPath(path4, interaction, context))
          return true;
        if (interaction.type === INTERACTION_CALLED) {
          const thisInit = context.replacedVariableInits.get(this.scope.thisVariable);
          context.replacedVariableInits.set(this.scope.thisVariable, interaction.withNew ? this.constructedEntity : UNKNOWN_EXPRESSION);
          const { brokenFlow, ignore: ignore3, replacedVariableInits } = context;
          context.ignore = {
            breaks: false,
            continues: false,
            labels: /* @__PURE__ */ new Set(),
            returnYield: true,
            this: interaction.withNew
          };
          if (this.body.hasEffects(context))
            return true;
          context.brokenFlow = brokenFlow;
          if (thisInit) {
            replacedVariableInits.set(this.scope.thisVariable, thisInit);
          } else {
            replacedVariableInits.delete(this.scope.thisVariable);
          }
          context.ignore = ignore3;
        }
        return false;
      }
      include(context, includeChildrenRecursively) {
        super.include(context, includeChildrenRecursively);
        this.id?.include();
        const hasArguments = this.scope.argumentsVariable.included;
        for (const parameter of this.params) {
          if (!(parameter instanceof Identifier) || hasArguments) {
            parameter.include(context, includeChildrenRecursively);
          }
        }
      }
      initialise() {
        super.initialise();
        this.id?.declare("function", this);
      }
      getObjectEntity() {
        if (this.objectEntity !== null) {
          return this.objectEntity;
        }
        return this.objectEntity = new ObjectEntity([
          {
            key: "prototype",
            kind: "init",
            property: new ObjectEntity([], OBJECT_PROTOTYPE)
          }
        ], OBJECT_PROTOTYPE);
      }
    };
    MethodBase = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.accessedValue = null;
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker) {
        if (interaction.type === INTERACTION_ACCESSED && this.kind === "get" && path4.length === 0) {
          return this.value.deoptimizeArgumentsOnInteractionAtPath({
            args: NO_ARGS,
            thisArg: interaction.thisArg,
            type: INTERACTION_CALLED,
            withNew: false
          }, EMPTY_PATH, recursionTracker);
        }
        if (interaction.type === INTERACTION_ASSIGNED && this.kind === "set" && path4.length === 0) {
          return this.value.deoptimizeArgumentsOnInteractionAtPath({
            args: interaction.args,
            thisArg: interaction.thisArg,
            type: INTERACTION_CALLED,
            withNew: false
          }, EMPTY_PATH, recursionTracker);
        }
        this.getAccessedValue()[0].deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker);
      }
      // As getter properties directly receive their values from fixed function
      // expressions, there is no known situation where a getter is deoptimized.
      deoptimizeCache() {
      }
      deoptimizePath(path4) {
        this.getAccessedValue()[0].deoptimizePath(path4);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        return this.getAccessedValue()[0].getLiteralValueAtPath(path4, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path4, interaction, recursionTracker, origin) {
        return this.getAccessedValue()[0].getReturnExpressionWhenCalledAtPath(path4, interaction, recursionTracker, origin);
      }
      hasEffects(context) {
        return this.key.hasEffects(context);
      }
      hasEffectsOnInteractionAtPath(path4, interaction, context) {
        if (this.kind === "get" && interaction.type === INTERACTION_ACCESSED && path4.length === 0) {
          return this.value.hasEffectsOnInteractionAtPath(EMPTY_PATH, {
            args: NO_ARGS,
            thisArg: interaction.thisArg,
            type: INTERACTION_CALLED,
            withNew: false
          }, context);
        }
        if (this.kind === "set" && interaction.type === INTERACTION_ASSIGNED) {
          return this.value.hasEffectsOnInteractionAtPath(EMPTY_PATH, {
            args: interaction.args,
            thisArg: interaction.thisArg,
            type: INTERACTION_CALLED,
            withNew: false
          }, context);
        }
        return this.getAccessedValue()[0].hasEffectsOnInteractionAtPath(path4, interaction, context);
      }
      applyDeoptimizations() {
      }
      getAccessedValue() {
        if (this.accessedValue === null) {
          if (this.kind === "get") {
            this.accessedValue = UNKNOWN_RETURN_EXPRESSION;
            return this.accessedValue = this.value.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, SHARED_RECURSION_TRACKER, this);
          } else {
            return this.accessedValue = [this.value, false];
          }
        }
        return this.accessedValue;
      }
    };
    MethodDefinition = class extends MethodBase {
      applyDeoptimizations() {
      }
    };
    ObjectMember = class extends ExpressionEntity {
      constructor(object, key) {
        super();
        this.object = object;
        this.key = key;
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker) {
        this.object.deoptimizeArgumentsOnInteractionAtPath(interaction, [this.key, ...path4], recursionTracker);
      }
      deoptimizePath(path4) {
        this.object.deoptimizePath([this.key, ...path4]);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        return this.object.getLiteralValueAtPath([this.key, ...path4], recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path4, interaction, recursionTracker, origin) {
        return this.object.getReturnExpressionWhenCalledAtPath([this.key, ...path4], interaction, recursionTracker, origin);
      }
      hasEffectsOnInteractionAtPath(path4, interaction, context) {
        return this.object.hasEffectsOnInteractionAtPath([this.key, ...path4], interaction, context);
      }
    };
    ClassNode = class extends NodeBase {
      constructor() {
        super(...arguments);
        this.objectEntity = null;
      }
      createScope(parentScope) {
        this.scope = new ChildScope(parentScope);
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker) {
        this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker);
      }
      deoptimizeCache() {
        this.getObjectEntity().deoptimizeAllProperties();
      }
      deoptimizePath(path4) {
        this.getObjectEntity().deoptimizePath(path4);
      }
      getLiteralValueAtPath(path4, recursionTracker, origin) {
        return this.getObjectEntity().getLiteralValueAtPath(path4, recursionTracker, origin);
      }
      getReturnExpressionWhenCalledAtPath(path4, interaction, recursionTracker, origin) {
        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path4, interaction, recursionTracker, origin);
      }
      hasEffects(context) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        const initEffect = this.superClass?.hasEffects(context) || this.body.hasEffects(context);
        this.id?.markDeclarationReached();
        return initEffect || super.hasEffects(context);
      }
      hasEffectsOnInteractionAtPath(path4, interaction, context) {
        return interaction.type === INTERACTION_CALLED && path4.length === 0 ? !interaction.withNew || (this.classConstructor === null ? this.superClass?.hasEffectsOnInteractionAtPath(path4, interaction, context) : this.classConstructor.hasEffectsOnInteractionAtPath(path4, interaction, context)) || false : this.getObjectEntity().hasEffectsOnInteractionAtPath(path4, interaction, context);
      }
      include(context, includeChildrenRecursively) {
        if (!this.deoptimized)
          this.applyDeoptimizations();
        this.included = true;
        this.superClass?.include(context, includeChildrenRecursively);
        this.body.include(context, includeChildrenRecursively);
        if (this.id) {
          this.id.markDeclarationReached();
          this.id.include();
        }
      }
      initialise() {
        this.id?.declare("class", this);
        for (const method of this.body.body) {
          if (method instanceof MethodDefinition && method.kind === "constructor") {
            this.classConstructor = method;
            return;
          }
        }
        this.classConstructor = null;
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        for (const definition of this.body.body) {
          if (!(definition.static || definition instanceof MethodDefinition && definition.kind === "constructor")) {
            definition.deoptimizePath(UNKNOWN_PATH);
          }
        }
        this.context.requestTreeshakingPass();
      }
      getObjectEntity() {
        if (this.objectEntity !== null) {
          return this.objectEntity;
        }
        const staticProperties = [];
        const dynamicMethods = [];
        for (const definition of this.body.body) {
          const properties = definition.static ? staticProperties : dynamicMethods;
          const definitionKind = definition.kind;
          if (properties === dynamicMethods && !definitionKind)
            continue;
          const kind = definitionKind === "set" || definitionKind === "get" ? definitionKind : "init";
          let key;
          if (definition.computed) {
            const keyValue = definition.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);
            if (typeof keyValue === "symbol") {
              properties.push({ key: UnknownKey, kind, property: definition });
              continue;
            } else {
              key = String(keyValue);
            }
          } else {
            key = definition.key instanceof Identifier ? definition.key.name : String(definition.key.value);
          }
          properties.push({ key, kind, property: definition });
        }
        staticProperties.unshift({
          key: "prototype",
          kind: "init",
          property: new ObjectEntity(dynamicMethods, this.superClass ? new ObjectMember(this.superClass, "prototype") : OBJECT_PROTOTYPE)
        });
        return this.objectEntity = new ObjectEntity(staticProperties, this.superClass || OBJECT_PROTOTYPE);
      }
    };
    ClassDeclaration = class extends ClassNode {
      initialise() {
        super.initialise();
        if (this.id !== null) {
          this.id.variable.isId = true;
        }
      }
      parseNode(esTreeNode) {
        if (esTreeNode.id !== null) {
          this.id = new Identifier(esTreeNode.id, this, this.scope.parent);
        }
        super.parseNode(esTreeNode);
      }
      render(code, options2) {
        const { exportNamesByVariable, format: format2, snippets: { _, getPropertyAccess } } = options2;
        if (this.id) {
          const { variable, name: name2 } = this.id;
          if (format2 === "system" && exportNamesByVariable.has(variable)) {
            code.appendLeft(this.end, `${_}${getSystemExportStatement([variable], options2)};`);
          }
          const renderedVariable = variable.getName(getPropertyAccess);
          if (renderedVariable !== name2) {
            this.superClass?.render(code, options2);
            this.body.render(code, {
              ...options2,
              useOriginalName: (_variable) => _variable === variable
            });
            code.prependRight(this.start, `let ${renderedVariable}${_}=${_}`);
            code.prependLeft(this.end, ";");
            return;
          }
        }
        super.render(code, options2);
      }
      applyDeoptimizations() {
        super.applyDeoptimizations();
        const { id, scope } = this;
        if (id) {
          const { name: name2, variable } = id;
          for (const accessedVariable of scope.accessedOutsideVariables.values()) {
            if (accessedVariable !== variable) {
              accessedVariable.forbidName(name2);
            }
          }
        }
      }
    };
    ExportAllDeclaration = class extends NodeBase {
      hasEffects() {
        return false;
      }
      initialise() {
        this.context.addExport(this);
      }
      render(code, _options, nodeRenderOptions) {
        code.remove(nodeRenderOptions.start, nodeRenderOptions.end);
      }
      applyDeoptimizations() {
      }
    };
    ExportAllDeclaration.prototype.needsBoundaries = true;
    FunctionDeclaration = class extends FunctionNode {
      initialise() {
        super.initialise();
        if (this.id !== null) {
          this.id.variable.isId = true;
        }
      }
      parseNode(esTreeNode) {
        if (esTreeNode.id !== null) {
          this.id = new Identifier(esTreeNode.id, this, this.scope.parent);
        }
        super.parseNode(esTreeNode);
      }
    };
    ExportDefaultDeclaration = class extends NodeBase {
      include(context, includeChildrenRecursively) {
        super.include(context, includeChildrenRecursively);
        if (includeChildrenRecursively) {
          this.context.includeVariableInModule(this.variable);
        }
      }
      initialise() {
        const declaration = this.declaration;
        this.declarationName = declaration.id && declaration.id.name || this.declaration.name;
        this.variable = this.scope.addExportDefaultDeclaration(this.declarationName || this.context.getModuleName(), this, this.context);
        this.context.addExport(this);
      }
      render(code, options2, nodeRenderOptions) {
        const { start, end } = nodeRenderOptions;
        const declarationStart = getDeclarationStart(code.original, this.start);
        if (this.declaration instanceof FunctionDeclaration) {
          this.renderNamedDeclaration(code, declarationStart, "function", "(", this.declaration.id === null, options2);
        } else if (this.declaration instanceof ClassDeclaration) {
          this.renderNamedDeclaration(code, declarationStart, "class", "{", this.declaration.id === null, options2);
        } else if (this.variable.getOriginalVariable() !== this.variable) {
          treeshakeNode(this, code, start, end);
          return;
        } else if (this.variable.included) {
          this.renderVariableDeclaration(code, declarationStart, options2);
        } else {
          code.remove(this.start, declarationStart);
          this.declaration.render(code, options2, {
            renderedSurroundingElement: ExpressionStatement$1
          });
          if (code.original[this.end - 1] !== ";") {
            code.appendLeft(this.end, ";");
          }
          return;
        }
        this.declaration.render(code, options2);
      }
      applyDeoptimizations() {
      }
      renderNamedDeclaration(code, declarationStart, declarationKeyword, endMarker, needsId, options2) {
        const { exportNamesByVariable, format: format2, snippets: { getPropertyAccess } } = options2;
        const name2 = this.variable.getName(getPropertyAccess);
        code.remove(this.start, declarationStart);
        if (needsId) {
          code.appendLeft(getIdInsertPosition(code.original, declarationKeyword, endMarker, declarationStart), ` ${name2}`);
        }
        if (format2 === "system" && this.declaration instanceof ClassDeclaration && exportNamesByVariable.has(this.variable)) {
          code.appendLeft(this.end, ` ${getSystemExportStatement([this.variable], options2)};`);
        }
      }
      renderVariableDeclaration(code, declarationStart, { format: format2, exportNamesByVariable, snippets: { cnst, getPropertyAccess } }) {
        const hasTrailingSemicolon = code.original.charCodeAt(this.end - 1) === 59;
        const systemExportNames = format2 === "system" && exportNamesByVariable.get(this.variable);
        if (systemExportNames) {
          code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = exports('${systemExportNames[0]}', `);
          code.appendRight(hasTrailingSemicolon ? this.end - 1 : this.end, ")" + (hasTrailingSemicolon ? "" : ";"));
        } else {
          code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = `);
          if (!hasTrailingSemicolon) {
            code.appendLeft(this.end, ";");
          }
        }
      }
    };
    ExportDefaultDeclaration.prototype.needsBoundaries = true;
    ExportNamedDeclaration = class extends NodeBase {
      bind() {
        this.declaration?.bind();
      }
      hasEffects(context) {
        return !!this.declaration?.hasEffects(context);
      }
      initialise() {
        this.context.addExport(this);
      }
      render(code, options2, nodeRenderOptions) {
        const { start, end } = nodeRenderOptions;
        if (this.declaration === null) {
          code.remove(start, end);
        } else {
          code.remove(this.start, this.declaration.start);
          this.declaration.render(code, options2, { end, start });
        }
      }
      applyDeoptimizations() {
      }
    };
    ExportNamedDeclaration.prototype.needsBoundaries = true;
    unset = Symbol("unset");
    ImportDeclaration = class extends NodeBase {
      // Do not bind specifiers or assertions
      bind() {
      }
      hasEffects() {
        return false;
      }
      initialise() {
        this.context.addImport(this);
      }
      render(code, _options, nodeRenderOptions) {
        code.remove(nodeRenderOptions.start, nodeRenderOptions.end);
      }
      applyDeoptimizations() {
      }
    };
    ImportDeclaration.prototype.needsBoundaries = true;
    INTEROP_DEFAULT_VARIABLE = "_interopDefault";
    INTEROP_DEFAULT_COMPAT_VARIABLE = "_interopDefaultCompat";
    INTEROP_NAMESPACE_VARIABLE = "_interopNamespace";
    INTEROP_NAMESPACE_COMPAT_VARIABLE = "_interopNamespaceCompat";
    INTEROP_NAMESPACE_DEFAULT_VARIABLE = "_interopNamespaceDefault";
    INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE = "_interopNamespaceDefaultOnly";
    MERGE_NAMESPACES_VARIABLE = "_mergeNamespaces";
    HELPER_GENERATORS = {
      [INTEROP_DEFAULT_COMPAT_VARIABLE](_t, snippets, liveBindings) {
        const { _, getDirectReturnFunction, n: n2 } = snippets;
        const [left, right] = getDirectReturnFunction(["e"], {
          functionReturn: true,
          lineBreakIndent: null,
          name: INTEROP_DEFAULT_COMPAT_VARIABLE
        });
        return `${left}${getIsCompatNamespace(snippets)}${_}?${_}${liveBindings ? getDefaultLiveBinding(snippets) : getDefaultStatic(snippets)}${right}${n2}${n2}`;
      },
      [INTEROP_DEFAULT_VARIABLE](_t, snippets, liveBindings) {
        const { _, getDirectReturnFunction, n: n2 } = snippets;
        const [left, right] = getDirectReturnFunction(["e"], {
          functionReturn: true,
          lineBreakIndent: null,
          name: INTEROP_DEFAULT_VARIABLE
        });
        return `${left}e${_}&&${_}e.__esModule${_}?${_}${liveBindings ? getDefaultLiveBinding(snippets) : getDefaultStatic(snippets)}${right}${n2}${n2}`;
      },
      [INTEROP_NAMESPACE_COMPAT_VARIABLE](t, snippets, liveBindings, freeze, namespaceToStringTag, usedHelpers) {
        const { _, getDirectReturnFunction, n: n2 } = snippets;
        if (usedHelpers.has(INTEROP_NAMESPACE_DEFAULT_VARIABLE)) {
          const [left, right] = getDirectReturnFunction(["e"], {
            functionReturn: true,
            lineBreakIndent: null,
            name: INTEROP_NAMESPACE_COMPAT_VARIABLE
          });
          return `${left}${getIsCompatNamespace(snippets)}${_}?${_}e${_}:${_}${INTEROP_NAMESPACE_DEFAULT_VARIABLE}(e)${right}${n2}${n2}`;
        }
        return `function ${INTEROP_NAMESPACE_COMPAT_VARIABLE}(e)${_}{${n2}${t}if${_}(${getIsCompatNamespace(snippets)})${_}return e;${n2}` + createNamespaceObject(t, t, snippets, liveBindings, freeze, namespaceToStringTag) + `}${n2}${n2}`;
      },
      [INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE](_t, snippets, _liveBindings, freeze, namespaceToStringTag) {
        const { getDirectReturnFunction, getObject, n: n2 } = snippets;
        const [left, right] = getDirectReturnFunction(["e"], {
          functionReturn: true,
          lineBreakIndent: null,
          name: INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE
        });
        return `${left}${getFrozen(freeze, getWithToStringTag(namespaceToStringTag, getObject([
          ["__proto__", "null"],
          ["default", "e"]
        ], { lineBreakIndent: null }), snippets))}${right}${n2}${n2}`;
      },
      [INTEROP_NAMESPACE_DEFAULT_VARIABLE](t, snippets, liveBindings, freeze, namespaceToStringTag) {
        const { _, n: n2 } = snippets;
        return `function ${INTEROP_NAMESPACE_DEFAULT_VARIABLE}(e)${_}{${n2}` + createNamespaceObject(t, t, snippets, liveBindings, freeze, namespaceToStringTag) + `}${n2}${n2}`;
      },
      [INTEROP_NAMESPACE_VARIABLE](t, snippets, liveBindings, freeze, namespaceToStringTag, usedHelpers) {
        const { _, getDirectReturnFunction, n: n2 } = snippets;
        if (usedHelpers.has(INTEROP_NAMESPACE_DEFAULT_VARIABLE)) {
          const [left, right] = getDirectReturnFunction(["e"], {
            functionReturn: true,
            lineBreakIndent: null,
            name: INTEROP_NAMESPACE_VARIABLE
          });
          return `${left}e${_}&&${_}e.__esModule${_}?${_}e${_}:${_}${INTEROP_NAMESPACE_DEFAULT_VARIABLE}(e)${right}${n2}${n2}`;
        }
        return `function ${INTEROP_NAMESPACE_VARIABLE}(e)${_}{${n2}${t}if${_}(e${_}&&${_}e.__esModule)${_}return e;${n2}` + createNamespaceObject(t, t, snippets, liveBindings, freeze, namespaceToStringTag) + `}${n2}${n2}`;
      },
      [MERGE_NAMESPACES_VARIABLE](t, snippets, liveBindings, freeze, namespaceToStringTag) {
        const { _, cnst, n: n2 } = snippets;
        const useForEach = cnst === "var" && liveBindings;
        return `function ${MERGE_NAMESPACES_VARIABLE}(n, m)${_}{${n2}${t}${loopOverNamespaces(`{${n2}${t}${t}${t}if${_}(k${_}!==${_}'default'${_}&&${_}!(k in n))${_}{${n2}` + (liveBindings ? useForEach ? copyOwnPropertyLiveBinding : copyPropertyLiveBinding : copyPropertyStatic)(t, t + t + t + t, snippets) + `${t}${t}${t}}${n2}${t}${t}}`, useForEach, t, snippets)}${n2}${t}return ${getFrozen(freeze, getWithToStringTag(namespaceToStringTag, "n", snippets))};${n2}}${n2}${n2}`;
      }
    };
    getDefaultLiveBinding = ({ _, getObject }) => `e${_}:${_}${getObject([["default", "e"]], { lineBreakIndent: null })}`;
    getDefaultStatic = ({ _, getPropertyAccess }) => `e${getPropertyAccess("default")}${_}:${_}e`;
    getIsCompatNamespace = ({ _ }) => `e${_}&&${_}typeof e${_}===${_}'object'${_}&&${_}'default'${_}in e`;
    createNamespaceObject = (t, index, snippets, liveBindings, freeze, namespaceToStringTag) => {
      const { _, cnst, getObject, getPropertyAccess, n: n2, s } = snippets;
      const copyProperty = `{${n2}` + (liveBindings ? copyNonDefaultOwnPropertyLiveBinding : copyPropertyStatic)(t, index + t + t, snippets) + `${index}${t}}`;
      return `${index}${cnst} n${_}=${_}Object.create(null${namespaceToStringTag ? `,${_}{${_}[Symbol.toStringTag]:${_}${getToStringTagValue(getObject)}${_}}` : ""});${n2}${index}if${_}(e)${_}{${n2}${index}${t}${loopOverKeys(copyProperty, !liveBindings, snippets)}${n2}${index}}${n2}${index}n${getPropertyAccess("default")}${_}=${_}e;${n2}${index}return ${getFrozen(freeze, "n")}${s}${n2}`;
    };
    loopOverKeys = (body, allowVariableLoopVariable, { _, cnst, getFunctionIntro, s }) => cnst !== "var" || allowVariableLoopVariable ? `for${_}(${cnst} k in e)${_}${body}` : `Object.keys(e).forEach(${getFunctionIntro(["k"], {
      isAsync: false,
      name: null
    })}${body})${s}`;
    loopOverNamespaces = (body, useForEach, t, { _, cnst, getDirectReturnFunction, getFunctionIntro, n: n2 }) => {
      if (useForEach) {
        const [left, right] = getDirectReturnFunction(["e"], {
          functionReturn: false,
          lineBreakIndent: { base: t, t },
          name: null
        });
        return `m.forEach(${left}e${_}&&${_}typeof e${_}!==${_}'string'${_}&&${_}!Array.isArray(e)${_}&&${_}Object.keys(e).forEach(${getFunctionIntro(["k"], {
          isAsync: false,
          name: null
        })}${body})${right});`;
      }
      return `for${_}(var i${_}=${_}0;${_}i${_}<${_}m.length;${_}i++)${_}{${n2}${t}${t}${cnst} e${_}=${_}m[i];${n2}${t}${t}if${_}(typeof e${_}!==${_}'string'${_}&&${_}!Array.isArray(e))${_}{${_}for${_}(${cnst} k in e)${_}${body}${_}}${n2}${t}}`;
    };
    copyNonDefaultOwnPropertyLiveBinding = (t, index, snippets) => {
      const { _, n: n2 } = snippets;
      return `${index}if${_}(k${_}!==${_}'default')${_}{${n2}` + copyOwnPropertyLiveBinding(t, index + t, snippets) + `${index}}${n2}`;
    };
    copyOwnPropertyLiveBinding = (t, index, { _, cnst, getDirectReturnFunction, n: n2 }) => {
      const [left, right] = getDirectReturnFunction([], {
        functionReturn: true,
        lineBreakIndent: null,
        name: null
      });
      return `${index}${cnst} d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n2}${index}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n2}${index}${t}enumerable:${_}true,${n2}${index}${t}get:${_}${left}e[k]${right}${n2}${index}});${n2}`;
    };
    copyPropertyLiveBinding = (t, index, { _, cnst, getDirectReturnFunction, n: n2 }) => {
      const [left, right] = getDirectReturnFunction([], {
        functionReturn: true,
        lineBreakIndent: null,
        name: null
      });
      return `${index}${cnst} d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n2}${index}if${_}(d)${_}{${n2}${index}${t}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n2}${index}${t}${t}enumerable:${_}true,${n2}${index}${t}${t}get:${_}${left}e[k]${right}${n2}${index}${t}});${n2}${index}}${n2}`;
    };
    copyPropertyStatic = (_t, index, { _, n: n2 }) => `${index}n[k]${_}=${_}e[k];${n2}`;
    getFrozen = (freeze, fragment) => freeze ? `Object.freeze(${fragment})` : fragment;
    getWithToStringTag = (namespaceToStringTag, fragment, { _, getObject }) => namespaceToStringTag ? `Object.defineProperty(${fragment},${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)})` : fragment;
    HELPER_NAMES = Object.keys(HELPER_GENERATORS);
    getResolveUrl = (path4, URL2 = "URL") => `new ${URL2}(${path4}).href`;
    getGenericImportMetaMechanism = (getUrl) => (property, { chunkId }) => {
      const urlMechanism = getUrl(chunkId);
      return property === null ? `({ url: ${urlMechanism} })` : property === "url" ? urlMechanism : "undefined";
    };
    getFileUrlFromFullPath = (path4) => `require('u' + 'rl').pathToFileURL(${path4}).href`;
    getUrlFromDocument = (chunkId, umd = false) => `${umd ? `typeof document === 'undefined' ? location.href : ` : ""}(document.currentScript && document.currentScript.src || new URL('${escapeId(chunkId)}', document.baseURI).href)`;
    importMetaMechanisms = {
      amd: getGenericImportMetaMechanism(() => getResolveUrl(`module.uri, document.baseURI`)),
      cjs: getGenericImportMetaMechanism((chunkId) => `(typeof document === 'undefined' ? ${getFileUrlFromFullPath("__filename")} : ${getUrlFromDocument(chunkId)})`),
      iife: getGenericImportMetaMechanism((chunkId) => getUrlFromDocument(chunkId)),
      system: (property, { snippets: { getPropertyAccess } }) => property === null ? `module.meta` : `module.meta${getPropertyAccess(property)}`,
      umd: getGenericImportMetaMechanism((chunkId) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getFileUrlFromFullPath("__filename")} : ${getUrlFromDocument(chunkId, true)})`)
    };
    SwitchCase = class extends NodeBase {
      hasEffects(context) {
        if (this.test?.hasEffects(context))
          return true;
        for (const node2 of this.consequent) {
          if (context.brokenFlow)
            break;
          if (node2.hasEffects(context))
            return true;
        }
        return false;
      }
      include(context, includeChildrenRecursively) {
        this.included = true;
        this.test?.include(context, includeChildrenRecursively);
        for (const node2 of this.consequent) {
          if (includeChildrenRecursively || node2.shouldBeIncluded(context))
            node2.include(context, includeChildrenRecursively);
        }
      }
      render(code, options2, nodeRenderOptions) {
        if (this.consequent.length > 0) {
          this.test && this.test.render(code, options2);
          const testEnd = this.test ? this.test.end : findFirstOccurrenceOutsideComment(code.original, "default", this.start) + 7;
          const consequentStart = findFirstOccurrenceOutsideComment(code.original, ":", testEnd) + 1;
          renderStatementList(this.consequent, code, consequentStart, nodeRenderOptions.end, options2);
        } else {
          super.render(code, options2);
        }
      }
    };
    SwitchCase.prototype.needsBoundaries = true;
    NamespaceVariable = class extends Variable {
      constructor(context) {
        super(context.getModuleName());
        this.memberVariables = null;
        this.mergedNamespaces = [];
        this.referencedEarly = false;
        this.references = [];
        this.context = context;
        this.module = context.module;
      }
      addReference(identifier) {
        this.references.push(identifier);
        this.name = identifier.name;
      }
      deoptimizeArgumentsOnInteractionAtPath(interaction, path4, recursionTracker) {
        if (path4.length > 1 || path4.length === 1 && interaction.type === INTERACTION_CALLED) {
          const key = path4[0];
          if (typeof key === "string") {
            this.getMemberVariables()[key]?.deoptimizeArgumentsOnInteractionAtPath(interaction, path4.slice(1), recursionTracker);
          } else {
            deoptimizeInteraction(interaction);
          }
        }
      }
      deoptimizePath(path4) {
        if (path4.length > 1) {
          const key = path4[0];
          if (typeof key === "string") {
            this.getMemberVariables()[key]?.deoptimizePath(path4.slice(1));
          }
        }
      }
      getLiteralValueAtPath(path4) {
        if (path4[0] === SymbolToStringTag) {
          return "Module";
        }
        return UnknownValue;
      }
      getMemberVariables() {
        if (this.memberVariables) {
          return this.memberVariables;
        }
        const memberVariables = /* @__PURE__ */ Object.create(null);
        const sortedExports = [...this.context.getExports(), ...this.context.getReexports()].sort();
        for (const name2 of sortedExports) {
          if (name2[0] !== "*" && name2 !== this.module.info.syntheticNamedExports) {
            const exportedVariable = this.context.traceExport(name2);
            if (exportedVariable) {
              memberVariables[name2] = exportedVariable;
            }
          }
        }
        return this.memberVariables = memberVariables;
      }
      hasEffectsOnInteractionAtPath(path4, interaction, context) {
        const { type } = interaction;
        if (path4.length === 0) {
          return true;
        }
        if (path4.length === 1 && type !== INTERACTION_CALLED) {
          return type === INTERACTION_ASSIGNED;
        }
        const key = path4[0];
        if (typeof key !== "string") {
          return true;
        }
        const memberVariable = this.getMemberVariables()[key];
        return !memberVariable || memberVariable.hasEffectsOnInteractionAtPath(path4.slice(1), interaction, context);
      }
      include() {
        this.included = true;
        this.context.includeAllExports();
      }
      prepare(accessedGlobalsByScope) {
        if (this.mergedNamespaces.length > 0) {
          this.module.scope.addAccessedGlobals([MERGE_NAMESPACES_VARIABLE], accessedGlobalsByScope);
        }
      }
      renderBlock(options2) {
        const { exportNamesByVariable, format: format2, freeze, indent: t, namespaceToStringTag, snippets: { _, cnst, getObject, getPropertyAccess, n: n2, s } } = options2;
        const memberVariables = this.getMemberVariables();
        const members = Object.entries(memberVariables).map(([name3, original]) => {
          if (this.referencedEarly || original.isReassigned) {
            return [
              null,
              `get ${name3}${_}()${_}{${_}return ${original.getName(getPropertyAccess)}${s}${_}}`
            ];
          }
          return [name3, original.getName(getPropertyAccess)];
        });
        members.unshift([null, `__proto__:${_}null`]);
        let output = getObject(members, { lineBreakIndent: { base: "", t } });
        if (this.mergedNamespaces.length > 0) {
          const assignmentArguments = this.mergedNamespaces.map((variable) => variable.getName(getPropertyAccess));
          output = `/*#__PURE__*/${MERGE_NAMESPACES_VARIABLE}(${output},${_}[${assignmentArguments.join(`,${_}`)}])`;
        } else {
          if (namespaceToStringTag) {
            output = `/*#__PURE__*/Object.defineProperty(${output},${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)})`;
          }
          if (freeze) {
            output = `/*#__PURE__*/Object.freeze(${output})`;
          }
        }
        const name2 = this.getName(getPropertyAccess);
        output = `${cnst} ${name2}${_}=${_}${output};`;
        if (format2 === "system" && exportNamesByVariable.has(this)) {
          output += `${n2}${getSystemExportStatement([this], options2)};`;
        }
        return output;
      }
      renderFirst() {
        return this.referencedEarly;
      }
      setMergedNamespaces(mergedNamespaces) {
        this.mergedNamespaces = mergedNamespaces;
        const moduleExecIndex = this.context.getModuleExecIndex();
        for (const identifier of this.references) {
          if (identifier.context.getModuleExecIndex() <= moduleExecIndex) {
            this.referencedEarly = true;
            break;
          }
        }
      }
    };
    NamespaceVariable.prototype.isNamespace = true;
    (function(BuildPhase2) {
      BuildPhase2[BuildPhase2["LOAD_AND_PARSE"] = 0] = "LOAD_AND_PARSE";
      BuildPhase2[BuildPhase2["ANALYSE"] = 1] = "ANALYSE";
      BuildPhase2[BuildPhase2["GENERATE"] = 2] = "GENERATE";
    })(BuildPhase || (BuildPhase = {}));
    _staticExports = {};
    _static = {
      get exports() {
        return _staticExports;
      },
      set exports(v) {
        _staticExports = v;
      }
    };
    require$$0 = [
      "assert",
      "async_hooks",
      "buffer",
      "child_process",
      "cluster",
      "console",
      "constants",
      "crypto",
      "dgram",
      "diagnostics_channel",
      "dns",
      "domain",
      "events",
      "fs",
      "http",
      "http2",
      "https",
      "inspector",
      "module",
      "net",
      "os",
      "path",
      "perf_hooks",
      "process",
      "punycode",
      "querystring",
      "readline",
      "repl",
      "stream",
      "string_decoder",
      "timers",
      "tls",
      "trace_events",
      "tty",
      "url",
      "util",
      "v8",
      "vm",
      "wasi",
      "worker_threads",
      "zlib"
    ];
    (function(module2) {
      module2.exports = require$$0;
    })(_static);
    builtinModules = /* @__PURE__ */ getDefaultExportFromCjs(_staticExports);
    nodeBuiltins = /* @__PURE__ */ new Set([
      ...builtinModules,
      // TODO
      // remove once builtin-modules includes PR: https://github.com/sindresorhus/builtin-modules/pull/17
      "assert/strict",
      "dns/promises",
      "fs/promises",
      "path/posix",
      "path/win32",
      "readline/promises",
      "stream/consumers",
      "stream/promises",
      "stream/web",
      "timers/promises",
      "util/types"
    ]);
    hashPlaceholderLeft = "!~{";
    hashPlaceholderRight = "}~";
    hashPlaceholderOverhead = hashPlaceholderLeft.length + hashPlaceholderRight.length;
    maxHashSize = 64;
    REPLACER_REGEX = new RegExp(`${hashPlaceholderLeft}[0-9a-zA-Z_$]{1,${maxHashSize - hashPlaceholderOverhead}}${hashPlaceholderRight}`, "g");
    lowercaseBundleKeys = Symbol("bundleKeys");
    astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
    nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    reservedWords = {
      3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
      5: "class enum extends super const export import",
      6: "enum",
      strict: "implements interface let package private protected public static yield",
      strictBind: "eval arguments"
    };
    ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    keywords$1 = {
      5: ecma5AndLessKeywords,
      "5module": ecma5AndLessKeywords + " export import",
      6: ecma5AndLessKeywords + " const class extends export import super"
    };
    keywordRelationalOperator = /^in(stanceof)?$/;
    nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    TokenType = function TokenType2(label, conf) {
      if (conf === void 0)
        conf = {};
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    };
    beforeExpr = { beforeExpr: true };
    startsExpr = { startsExpr: true };
    keywords = {};
    types$1 = {
      num: new TokenType("num", startsExpr),
      regexp: new TokenType("regexp", startsExpr),
      string: new TokenType("string", startsExpr),
      name: new TokenType("name", startsExpr),
      privateId: new TokenType("privateId", startsExpr),
      eof: new TokenType("eof"),
      // Punctuation token types.
      bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
      bracketR: new TokenType("]"),
      braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
      braceR: new TokenType("}"),
      parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
      parenR: new TokenType(")"),
      comma: new TokenType(",", beforeExpr),
      semi: new TokenType(";", beforeExpr),
      colon: new TokenType(":", beforeExpr),
      dot: new TokenType("."),
      question: new TokenType("?", beforeExpr),
      questionDot: new TokenType("?."),
      arrow: new TokenType("=>", beforeExpr),
      template: new TokenType("template"),
      invalidTemplate: new TokenType("invalidTemplate"),
      ellipsis: new TokenType("...", beforeExpr),
      backQuote: new TokenType("`", startsExpr),
      dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
      // Operators. These carry several kinds of properties to help the
      // parser use them properly (the presence of these properties is
      // what categorizes them as operators).
      //
      // `binop`, when present, specifies that this operator is a binary
      // operator, and will refer to its precedence.
      //
      // `prefix` and `postfix` mark the operator as a prefix or postfix
      // unary operator.
      //
      // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
      // binary operators with a very low precedence, that should result
      // in AssignmentExpression nodes.
      eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
      assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
      incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
      prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
      logicalOR: binop("||", 1),
      logicalAND: binop("&&", 2),
      bitwiseOR: binop("|", 3),
      bitwiseXOR: binop("^", 4),
      bitwiseAND: binop("&", 5),
      equality: binop("==/!=/===/!==", 6),
      relational: binop("</>/<=/>=", 7),
      bitShift: binop("<</>>/>>>", 8),
      plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
      modulo: binop("%", 10),
      star: binop("*", 10),
      slash: binop("/", 10),
      starstar: new TokenType("**", { beforeExpr: true }),
      coalesce: binop("??", 1),
      // Keyword token types.
      _break: kw("break"),
      _case: kw("case", beforeExpr),
      _catch: kw("catch"),
      _continue: kw("continue"),
      _debugger: kw("debugger"),
      _default: kw("default", beforeExpr),
      _do: kw("do", { isLoop: true, beforeExpr: true }),
      _else: kw("else", beforeExpr),
      _finally: kw("finally"),
      _for: kw("for", { isLoop: true }),
      _function: kw("function", startsExpr),
      _if: kw("if"),
      _return: kw("return", beforeExpr),
      _switch: kw("switch"),
      _throw: kw("throw", beforeExpr),
      _try: kw("try"),
      _var: kw("var"),
      _const: kw("const"),
      _while: kw("while", { isLoop: true }),
      _with: kw("with"),
      _new: kw("new", { beforeExpr: true, startsExpr: true }),
      _this: kw("this", startsExpr),
      _super: kw("super", startsExpr),
      _class: kw("class", startsExpr),
      _extends: kw("extends", beforeExpr),
      _export: kw("export"),
      _import: kw("import", startsExpr),
      _null: kw("null", startsExpr),
      _true: kw("true", startsExpr),
      _false: kw("false", startsExpr),
      _in: kw("in", { beforeExpr: true, binop: 7 }),
      _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
      _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
      _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
      _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
    };
    lineBreak = /\r\n?|\n|\u2028|\u2029/;
    lineBreakG = new RegExp(lineBreak.source, "g");
    nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    ref = Object.prototype;
    hasOwnProperty = ref.hasOwnProperty;
    toString2 = ref.toString;
    hasOwn = Object.hasOwn || function(obj, propName) {
      return hasOwnProperty.call(obj, propName);
    };
    isArray = Array.isArray || function(obj) {
      return toString2.call(obj) === "[object Array]";
    };
    loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
    Position = function Position2(line, col) {
      this.line = line;
      this.column = col;
    };
    Position.prototype.offset = function offset(n2) {
      return new Position(this.line, this.column + n2);
    };
    SourceLocation = function SourceLocation2(p, start, end) {
      this.start = start;
      this.end = end;
      if (p.sourceFile !== null) {
        this.source = p.sourceFile;
      }
    };
    defaultOptions = {
      // `ecmaVersion` indicates the ECMAScript version to parse. Must be
      // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
      // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
      // (the latest version the library supports). This influences
      // support for strict mode, the set of reserved words, and support
      // for new syntax features.
      ecmaVersion: null,
      // `sourceType` indicates the mode the code should be parsed in.
      // Can be either `"script"` or `"module"`. This influences global
      // strict mode and parsing of `import` and `export` declarations.
      sourceType: "script",
      // `onInsertedSemicolon` can be a callback that will be called
      // when a semicolon is automatically inserted. It will be passed
      // the position of the comma as an offset, and if `locations` is
      // enabled, it is given the location as a `{line, column}` object
      // as second argument.
      onInsertedSemicolon: null,
      // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
      // trailing commas.
      onTrailingComma: null,
      // By default, reserved words are only enforced if ecmaVersion >= 5.
      // Set `allowReserved` to a boolean value to explicitly turn this on
      // an off. When this option has the value "never", reserved words
      // and keywords can also not be used as property names.
      allowReserved: null,
      // When enabled, a return at the top level is not considered an
      // error.
      allowReturnOutsideFunction: false,
      // When enabled, import/export statements are not constrained to
      // appearing at the top of the program, and an import.meta expression
      // in a script isn't considered an error.
      allowImportExportEverywhere: false,
      // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
      // When enabled, await identifiers are allowed to appear at the top-level scope,
      // but they are still not allowed in non-async functions.
      allowAwaitOutsideFunction: null,
      // When enabled, super identifiers are not constrained to
      // appearing in methods and do not raise an error when they appear elsewhere.
      allowSuperOutsideMethod: null,
      // When enabled, hashbang directive in the beginning of file is
      // allowed and treated as a line comment. Enabled by default when
      // `ecmaVersion` >= 2023.
      allowHashBang: false,
      // When `locations` is on, `loc` properties holding objects with
      // `start` and `end` properties in `{line, column}` form (with
      // line being 1-based and column 0-based) will be attached to the
      // nodes.
      locations: false,
      // A function can be passed as `onToken` option, which will
      // cause Acorn to call that function with object in the same
      // format as tokens returned from `tokenizer().getToken()`. Note
      // that you are not allowed to call the parser from the
      // callbackthat will corrupt its internal state.
      onToken: null,
      // A function can be passed as `onComment` option, which will
      // cause Acorn to call that function with `(block, text, start,
      // end)` parameters whenever a comment is skipped. `block` is a
      // boolean indicating whether this is a block (`/* */`) comment,
      // `text` is the content of the comment, and `start` and `end` are
      // character offsets that denote the start and end of the comment.
      // When the `locations` option is on, two more parameters are
      // passed, the full `{line, column}` locations of the start and
      // end of the comments. Note that you are not allowed to call the
      // parser from the callbackthat will corrupt its internal state.
      onComment: null,
      // Nodes have their start and end characters offsets recorded in
      // `start` and `end` properties (directly on the node, rather than
      // the `loc` object, which holds line/column data. To also add a
      // [semi-standardized][range] `range` property holding a `[start,
      // end]` array with the same numbers, set the `ranges` option to
      // `true`.
      //
      // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
      ranges: false,
      // It is possible to parse multiple files into a single AST by
      // passing the tree produced by parsing the first file as
      // `program` option in subsequent parses. This will add the
      // toplevel forms of the parsed file to the `Program` (top) node
      // of an existing parse tree.
      program: null,
      // When `locations` is on, you can pass this to record the source
      // file in every node's `loc` object.
      sourceFile: null,
      // This value, if given, is stored in every node, whether
      // `locations` is on or off.
      directSourceFile: null,
      // When enabled, parenthesized expressions are represented by
      // (non-standard) ParenthesizedExpression nodes
      preserveParens: false
    };
    warnedAboutEcmaVersion = false;
    SCOPE_TOP = 1;
    SCOPE_FUNCTION = 2;
    SCOPE_ASYNC = 4;
    SCOPE_GENERATOR = 8;
    SCOPE_ARROW = 16;
    SCOPE_SIMPLE_CATCH = 32;
    SCOPE_SUPER = 64;
    SCOPE_DIRECT_SUPER = 128;
    SCOPE_CLASS_STATIC_BLOCK = 256;
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
    BIND_NONE = 0;
    BIND_VAR = 1;
    BIND_LEXICAL = 2;
    BIND_FUNCTION = 3;
    BIND_SIMPLE_CATCH = 4;
    BIND_OUTSIDE = 5;
    Parser = function Parser2(options2, input, startPos) {
      this.options = options2 = getOptions(options2);
      this.sourceFile = options2.sourceFile;
      this.keywords = wordsRegexp(keywords$1[options2.ecmaVersion >= 6 ? 6 : options2.sourceType === "module" ? "5module" : 5]);
      var reserved = "";
      if (options2.allowReserved !== true) {
        reserved = reservedWords[options2.ecmaVersion >= 6 ? 6 : options2.ecmaVersion === 5 ? 5 : 3];
        if (options2.sourceType === "module") {
          reserved += " await";
        }
      }
      this.reservedWords = wordsRegexp(reserved);
      var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
      this.reservedWordsStrict = wordsRegexp(reservedStrict);
      this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
      this.input = String(input);
      this.containsEsc = false;
      if (startPos) {
        this.pos = startPos;
        this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
      } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
      }
      this.type = types$1.eof;
      this.value = null;
      this.start = this.end = this.pos;
      this.startLoc = this.endLoc = this.curPosition();
      this.lastTokEndLoc = this.lastTokStartLoc = null;
      this.lastTokStart = this.lastTokEnd = this.pos;
      this.context = this.initialContext();
      this.exprAllowed = true;
      this.inModule = options2.sourceType === "module";
      this.strict = this.inModule || this.strictDirective(this.pos);
      this.potentialArrowAt = -1;
      this.potentialArrowInForAwait = false;
      this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
      this.labels = [];
      this.undefinedExports = /* @__PURE__ */ Object.create(null);
      if (this.pos === 0 && options2.allowHashBang && this.input.slice(0, 2) === "#!") {
        this.skipLineComment(2);
      }
      this.scopeStack = [];
      this.enterScope(SCOPE_TOP);
      this.regexpState = null;
      this.privateNameStack = [];
    };
    prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
    Parser.prototype.parse = function parse2() {
      var node2 = this.options.program || this.startNode();
      this.nextToken();
      return this.parseTopLevel(node2);
    };
    prototypeAccessors.inFunction.get = function() {
      return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
    };
    prototypeAccessors.inGenerator.get = function() {
      return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
    };
    prototypeAccessors.inAsync.get = function() {
      return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
    };
    prototypeAccessors.canAwait.get = function() {
      for (var i = this.scopeStack.length - 1; i >= 0; i--) {
        var scope = this.scopeStack[i];
        if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
          return false;
        }
        if (scope.flags & SCOPE_FUNCTION) {
          return (scope.flags & SCOPE_ASYNC) > 0;
        }
      }
      return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
    };
    prototypeAccessors.allowSuper.get = function() {
      var ref3 = this.currentThisScope();
      var flags = ref3.flags;
      var inClassFieldInit = ref3.inClassFieldInit;
      return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
    };
    prototypeAccessors.allowDirectSuper.get = function() {
      return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
    };
    prototypeAccessors.treatFunctionsAsVar.get = function() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    };
    prototypeAccessors.allowNewDotTarget.get = function() {
      var ref3 = this.currentThisScope();
      var flags = ref3.flags;
      var inClassFieldInit = ref3.inClassFieldInit;
      return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
    };
    prototypeAccessors.inClassStaticBlock.get = function() {
      return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
    };
    Parser.extend = function extend() {
      var plugins2 = [], len = arguments.length;
      while (len--)
        plugins2[len] = arguments[len];
      var cls = this;
      for (var i = 0; i < plugins2.length; i++) {
        cls = plugins2[i](cls);
      }
      return cls;
    };
    Parser.parse = function parse3(input, options2) {
      return new this(options2, input).parse();
    };
    Parser.parseExpressionAt = function parseExpressionAt(input, pos, options2) {
      var parser = new this(options2, input, pos);
      parser.nextToken();
      return parser.parseExpression();
    };
    Parser.tokenizer = function tokenizer(input, options2) {
      return new this(options2, input);
    };
    Object.defineProperties(Parser.prototype, prototypeAccessors);
    pp$9 = Parser.prototype;
    literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
    pp$9.strictDirective = function(start) {
      if (this.options.ecmaVersion < 5) {
        return false;
      }
      for (; ; ) {
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        var match = literal.exec(this.input.slice(start));
        if (!match) {
          return false;
        }
        if ((match[1] || match[2]) === "use strict") {
          skipWhiteSpace.lastIndex = start + match[0].length;
          var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
          var next = this.input.charAt(end);
          return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
        }
        start += match[0].length;
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        if (this.input[start] === ";") {
          start++;
        }
      }
    };
    pp$9.eat = function(type) {
      if (this.type === type) {
        this.next();
        return true;
      } else {
        return false;
      }
    };
    pp$9.isContextual = function(name2) {
      return this.type === types$1.name && this.value === name2 && !this.containsEsc;
    };
    pp$9.eatContextual = function(name2) {
      if (!this.isContextual(name2)) {
        return false;
      }
      this.next();
      return true;
    };
    pp$9.expectContextual = function(name2) {
      if (!this.eatContextual(name2)) {
        this.unexpected();
      }
    };
    pp$9.canInsertSemicolon = function() {
      return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$9.insertSemicolon = function() {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon) {
          this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
        }
        return true;
      }
    };
    pp$9.semicolon = function() {
      if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
        this.unexpected();
      }
    };
    pp$9.afterTrailingComma = function(tokType, notNext) {
      if (this.type === tokType) {
        if (this.options.onTrailingComma) {
          this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
        }
        if (!notNext) {
          this.next();
        }
        return true;
      }
    };
    pp$9.expect = function(type) {
      this.eat(type) || this.unexpected();
    };
    pp$9.unexpected = function(pos) {
      this.raise(pos != null ? pos : this.start, "Unexpected token");
    };
    DestructuringErrors = function DestructuringErrors2() {
      this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
    };
    pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
      if (!refDestructuringErrors) {
        return;
      }
      if (refDestructuringErrors.trailingComma > -1) {
        this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
      }
      var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
      if (parens > -1) {
        this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
      }
    };
    pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
      if (!refDestructuringErrors) {
        return false;
      }
      var shorthandAssign = refDestructuringErrors.shorthandAssign;
      var doubleProto = refDestructuringErrors.doubleProto;
      if (!andThrow) {
        return shorthandAssign >= 0 || doubleProto >= 0;
      }
      if (shorthandAssign >= 0) {
        this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
      }
      if (doubleProto >= 0) {
        this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
      }
    };
    pp$9.checkYieldAwaitInDefaultParams = function() {
      if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
        this.raise(this.yieldPos, "Yield expression cannot be a default value");
      }
      if (this.awaitPos) {
        this.raise(this.awaitPos, "Await expression cannot be a default value");
      }
    };
    pp$9.isSimpleAssignTarget = function(expr) {
      if (expr.type === "ParenthesizedExpression") {
        return this.isSimpleAssignTarget(expr.expression);
      }
      return expr.type === "Identifier" || expr.type === "MemberExpression";
    };
    pp$8 = Parser.prototype;
    pp$8.parseTopLevel = function(node2) {
      var exports2 = /* @__PURE__ */ Object.create(null);
      if (!node2.body) {
        node2.body = [];
      }
      while (this.type !== types$1.eof) {
        var stmt = this.parseStatement(null, true, exports2);
        node2.body.push(stmt);
      }
      if (this.inModule) {
        for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
          var name2 = list[i];
          this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
        }
      }
      this.adaptDirectivePrologue(node2.body);
      this.next();
      node2.sourceType = this.options.sourceType;
      return this.finishNode(node2, "Program");
    };
    loopLabel = { kind: "loop" };
    switchLabel = { kind: "switch" };
    pp$8.isLet = function(context) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
        return false;
      }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 91 || nextCh === 92) {
        return true;
      }
      if (context) {
        return false;
      }
      if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
        return true;
      }
      if (isIdentifierStart(nextCh, true)) {
        var pos = next + 1;
        while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
          ++pos;
        }
        if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) {
          return true;
        }
      }
      return false;
    };
    pp$8.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
        return false;
      }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, after;
      return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
    };
    pp$8.parseStatement = function(context, topLevel, exports2) {
      var starttype = this.type, node2 = this.startNode(), kind;
      if (this.isLet(context)) {
        starttype = types$1._var;
        kind = "let";
      }
      switch (starttype) {
        case types$1._break:
        case types$1._continue:
          return this.parseBreakContinueStatement(node2, starttype.keyword);
        case types$1._debugger:
          return this.parseDebuggerStatement(node2);
        case types$1._do:
          return this.parseDoStatement(node2);
        case types$1._for:
          return this.parseForStatement(node2);
        case types$1._function:
          if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
            this.unexpected();
          }
          return this.parseFunctionStatement(node2, false, !context);
        case types$1._class:
          if (context) {
            this.unexpected();
          }
          return this.parseClass(node2, true);
        case types$1._if:
          return this.parseIfStatement(node2);
        case types$1._return:
          return this.parseReturnStatement(node2);
        case types$1._switch:
          return this.parseSwitchStatement(node2);
        case types$1._throw:
          return this.parseThrowStatement(node2);
        case types$1._try:
          return this.parseTryStatement(node2);
        case types$1._const:
        case types$1._var:
          kind = kind || this.value;
          if (context && kind !== "var") {
            this.unexpected();
          }
          return this.parseVarStatement(node2, kind);
        case types$1._while:
          return this.parseWhileStatement(node2);
        case types$1._with:
          return this.parseWithStatement(node2);
        case types$1.braceL:
          return this.parseBlock(true, node2);
        case types$1.semi:
          return this.parseEmptyStatement(node2);
        case types$1._export:
        case types$1._import:
          if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
            skipWhiteSpace.lastIndex = this.pos;
            var skip = skipWhiteSpace.exec(this.input);
            var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
            if (nextCh === 40 || nextCh === 46) {
              return this.parseExpressionStatement(node2, this.parseExpression());
            }
          }
          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel) {
              this.raise(this.start, "'import' and 'export' may only appear at the top level");
            }
            if (!this.inModule) {
              this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
          }
          return starttype === types$1._import ? this.parseImport(node2) : this.parseExport(node2, exports2);
        default:
          if (this.isAsyncFunction()) {
            if (context) {
              this.unexpected();
            }
            this.next();
            return this.parseFunctionStatement(node2, true, !context);
          }
          var maybeName = this.value, expr = this.parseExpression();
          if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
            return this.parseLabeledStatement(node2, maybeName, expr, context);
          } else {
            return this.parseExpressionStatement(node2, expr);
          }
      }
    };
    pp$8.parseBreakContinueStatement = function(node2, keyword) {
      var isBreak = keyword === "break";
      this.next();
      if (this.eat(types$1.semi) || this.insertSemicolon()) {
        node2.label = null;
      } else if (this.type !== types$1.name) {
        this.unexpected();
      } else {
        node2.label = this.parseIdent();
        this.semicolon();
      }
      var i = 0;
      for (; i < this.labels.length; ++i) {
        var lab = this.labels[i];
        if (node2.label == null || lab.name === node2.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) {
            break;
          }
          if (node2.label && isBreak) {
            break;
          }
        }
      }
      if (i === this.labels.length) {
        this.raise(node2.start, "Unsyntactic " + keyword);
      }
      return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
    };
    pp$8.parseDebuggerStatement = function(node2) {
      this.next();
      this.semicolon();
      return this.finishNode(node2, "DebuggerStatement");
    };
    pp$8.parseDoStatement = function(node2) {
      this.next();
      this.labels.push(loopLabel);
      node2.body = this.parseStatement("do");
      this.labels.pop();
      this.expect(types$1._while);
      node2.test = this.parseParenExpression();
      if (this.options.ecmaVersion >= 6) {
        this.eat(types$1.semi);
      } else {
        this.semicolon();
      }
      return this.finishNode(node2, "DoWhileStatement");
    };
    pp$8.parseForStatement = function(node2) {
      this.next();
      var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
      this.labels.push(loopLabel);
      this.enterScope(0);
      this.expect(types$1.parenL);
      if (this.type === types$1.semi) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, null);
      }
      var isLet = this.isLet();
      if (this.type === types$1._var || this.type === types$1._const || isLet) {
        var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
        this.next();
        this.parseVar(init$1, true, kind);
        this.finishNode(init$1, "VariableDeclaration");
        if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$1._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node2.await = awaitAt > -1;
            }
          }
          return this.parseForIn(node2, init$1);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, init$1);
      }
      var startsWithLet = this.isContextual("let"), isForOf = false;
      var refDestructuringErrors = new DestructuringErrors();
      var init4 = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
      if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types$1._in) {
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
          } else {
            node2.await = awaitAt > -1;
          }
        }
        if (startsWithLet && isForOf) {
          this.raise(init4.start, "The left-hand side of a for-of loop may not start with 'let'.");
        }
        this.toAssignable(init4, false, refDestructuringErrors);
        this.checkLValPattern(init4);
        return this.parseForIn(node2, init4);
      } else {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node2, init4);
    };
    pp$8.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node2, FUNC_STATEMENT$1 | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
    };
    pp$8.parseIfStatement = function(node2) {
      this.next();
      node2.test = this.parseParenExpression();
      node2.consequent = this.parseStatement("if");
      node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
      return this.finishNode(node2, "IfStatement");
    };
    pp$8.parseReturnStatement = function(node2) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
        this.raise(this.start, "'return' outside of function");
      }
      this.next();
      if (this.eat(types$1.semi) || this.insertSemicolon()) {
        node2.argument = null;
      } else {
        node2.argument = this.parseExpression();
        this.semicolon();
      }
      return this.finishNode(node2, "ReturnStatement");
    };
    pp$8.parseSwitchStatement = function(node2) {
      this.next();
      node2.discriminant = this.parseParenExpression();
      node2.cases = [];
      this.expect(types$1.braceL);
      this.labels.push(switchLabel);
      this.enterScope(0);
      var cur;
      for (var sawDefault = false; this.type !== types$1.braceR; ) {
        if (this.type === types$1._case || this.type === types$1._default) {
          var isCase = this.type === types$1._case;
          if (cur) {
            this.finishNode(cur, "SwitchCase");
          }
          node2.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
            }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(types$1.colon);
        } else {
          if (!cur) {
            this.unexpected();
          }
          cur.consequent.push(this.parseStatement(null));
        }
      }
      this.exitScope();
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      this.next();
      this.labels.pop();
      return this.finishNode(node2, "SwitchStatement");
    };
    pp$8.parseThrowStatement = function(node2) {
      this.next();
      if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
        this.raise(this.lastTokEnd, "Illegal newline after throw");
      }
      node2.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node2, "ThrowStatement");
    };
    empty$1 = [];
    pp$8.parseTryStatement = function(node2) {
      this.next();
      node2.block = this.parseBlock();
      node2.handler = null;
      if (this.type === types$1._catch) {
        var clause = this.startNode();
        this.next();
        if (this.eat(types$1.parenL)) {
          clause.param = this.parseBindingAtom();
          var simple = clause.param.type === "Identifier";
          this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
          this.expect(types$1.parenR);
        } else {
          if (this.options.ecmaVersion < 10) {
            this.unexpected();
          }
          clause.param = null;
          this.enterScope(0);
        }
        clause.body = this.parseBlock(false);
        this.exitScope();
        node2.handler = this.finishNode(clause, "CatchClause");
      }
      node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
      if (!node2.handler && !node2.finalizer) {
        this.raise(node2.start, "Missing catch or finally clause");
      }
      return this.finishNode(node2, "TryStatement");
    };
    pp$8.parseVarStatement = function(node2, kind) {
      this.next();
      this.parseVar(node2, false, kind);
      this.semicolon();
      return this.finishNode(node2, "VariableDeclaration");
    };
    pp$8.parseWhileStatement = function(node2) {
      this.next();
      node2.test = this.parseParenExpression();
      this.labels.push(loopLabel);
      node2.body = this.parseStatement("while");
      this.labels.pop();
      return this.finishNode(node2, "WhileStatement");
    };
    pp$8.parseWithStatement = function(node2) {
      if (this.strict) {
        this.raise(this.start, "'with' in strict mode");
      }
      this.next();
      node2.object = this.parseParenExpression();
      node2.body = this.parseStatement("with");
      return this.finishNode(node2, "WithStatement");
    };
    pp$8.parseEmptyStatement = function(node2) {
      this.next();
      return this.finishNode(node2, "EmptyStatement");
    };
    pp$8.parseLabeledStatement = function(node2, maybeName, expr, context) {
      for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
        var label = list[i$1];
        if (label.name === maybeName) {
          this.raise(expr.start, "Label '" + maybeName + "' is already declared");
        }
      }
      var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
      for (var i = this.labels.length - 1; i >= 0; i--) {
        var label$1 = this.labels[i];
        if (label$1.statementStart === node2.start) {
          label$1.statementStart = this.start;
          label$1.kind = kind;
        } else {
          break;
        }
      }
      this.labels.push({ name: maybeName, kind, statementStart: this.start });
      node2.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.labels.pop();
      node2.label = expr;
      return this.finishNode(node2, "LabeledStatement");
    };
    pp$8.parseExpressionStatement = function(node2, expr) {
      node2.expression = expr;
      this.semicolon();
      return this.finishNode(node2, "ExpressionStatement");
    };
    pp$8.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
      if (createNewLexicalScope === void 0)
        createNewLexicalScope = true;
      if (node2 === void 0)
        node2 = this.startNode();
      node2.body = [];
      this.expect(types$1.braceL);
      if (createNewLexicalScope) {
        this.enterScope(0);
      }
      while (this.type !== types$1.braceR) {
        var stmt = this.parseStatement(null);
        node2.body.push(stmt);
      }
      if (exitStrict) {
        this.strict = false;
      }
      this.next();
      if (createNewLexicalScope) {
        this.exitScope();
      }
      return this.finishNode(node2, "BlockStatement");
    };
    pp$8.parseFor = function(node2, init4) {
      node2.init = init4;
      this.expect(types$1.semi);
      node2.test = this.type === types$1.semi ? null : this.parseExpression();
      this.expect(types$1.semi);
      node2.update = this.type === types$1.parenR ? null : this.parseExpression();
      this.expect(types$1.parenR);
      node2.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node2, "ForStatement");
    };
    pp$8.parseForIn = function(node2, init4) {
      var isForIn = this.type === types$1._in;
      this.next();
      if (init4.type === "VariableDeclaration" && init4.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init4.kind !== "var" || init4.declarations[0].id.type !== "Identifier")) {
        this.raise(
          init4.start,
          (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
        );
      }
      node2.left = init4;
      node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
      this.expect(types$1.parenR);
      node2.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
    };
    pp$8.parseVar = function(node2, isFor, kind) {
      node2.declarations = [];
      node2.kind = kind;
      for (; ; ) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        if (this.eat(types$1.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else if (kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          this.unexpected();
        } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
          this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types$1.comma)) {
          break;
        }
      }
      return node2;
    };
    pp$8.parseVarId = function(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
    };
    FUNC_STATEMENT$1 = 1;
    FUNC_HANGING_STATEMENT = 2;
    FUNC_NULLABLE_ID$1 = 4;
    pp$8.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
      this.initFunction(node2);
      if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
        if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
          this.unexpected();
        }
        node2.generator = this.eat(types$1.star);
      }
      if (this.options.ecmaVersion >= 8) {
        node2.async = !!isAsync;
      }
      if (statement & FUNC_STATEMENT$1) {
        node2.id = statement & FUNC_NULLABLE_ID$1 && this.type !== types$1.name ? null : this.parseIdent();
        if (node2.id && !(statement & FUNC_HANGING_STATEMENT)) {
          this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
        }
      }
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(node2.async, node2.generator));
      if (!(statement & FUNC_STATEMENT$1)) {
        node2.id = this.type === types$1.name ? this.parseIdent() : null;
      }
      this.parseFunctionParams(node2);
      this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node2, statement & FUNC_STATEMENT$1 ? "FunctionDeclaration" : "FunctionExpression");
    };
    pp$8.parseFunctionParams = function(node2) {
      this.expect(types$1.parenL);
      node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
    };
    pp$8.parseClass = function(node2, isStatement) {
      this.next();
      var oldStrict = this.strict;
      this.strict = true;
      this.parseClassId(node2, isStatement);
      this.parseClassSuper(node2);
      var privateNameMap = this.enterClassBody();
      var classBody = this.startNode();
      var hadConstructor = false;
      classBody.body = [];
      this.expect(types$1.braceL);
      while (this.type !== types$1.braceR) {
        var element = this.parseClassElement(node2.superClass !== null);
        if (element) {
          classBody.body.push(element);
          if (element.type === "MethodDefinition" && element.kind === "constructor") {
            if (hadConstructor) {
              this.raise(element.start, "Duplicate constructor in the same class");
            }
            hadConstructor = true;
          } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
            this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
          }
        }
      }
      this.strict = oldStrict;
      this.next();
      node2.body = this.finishNode(classBody, "ClassBody");
      this.exitClassBody();
      return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    pp$8.parseClassElement = function(constructorAllowsSuper) {
      if (this.eat(types$1.semi)) {
        return null;
      }
      var ecmaVersion = this.options.ecmaVersion;
      var node2 = this.startNode();
      var keyName = "";
      var isGenerator = false;
      var isAsync = false;
      var kind = "method";
      var isStatic = false;
      if (this.eatContextual("static")) {
        if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
          this.parseClassStaticBlock(node2);
          return node2;
        }
        if (this.isClassElementNameStart() || this.type === types$1.star) {
          isStatic = true;
        } else {
          keyName = "static";
        }
      }
      node2.static = isStatic;
      if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
        if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
          isAsync = true;
        } else {
          keyName = "async";
        }
      }
      if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
        isGenerator = true;
      }
      if (!keyName && !isAsync && !isGenerator) {
        var lastValue = this.value;
        if (this.eatContextual("get") || this.eatContextual("set")) {
          if (this.isClassElementNameStart()) {
            kind = lastValue;
          } else {
            keyName = lastValue;
          }
        }
      }
      if (keyName) {
        node2.computed = false;
        node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
        node2.key.name = keyName;
        this.finishNode(node2.key, "Identifier");
      } else {
        this.parseClassElementName(node2);
      }
      if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
        var isConstructor = !node2.static && checkKeyName(node2, "constructor");
        var allowsDirectSuper = isConstructor && constructorAllowsSuper;
        if (isConstructor && kind !== "method") {
          this.raise(node2.key.start, "Constructor can't have get/set modifier");
        }
        node2.kind = isConstructor ? "constructor" : kind;
        this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
      } else {
        this.parseClassField(node2);
      }
      return node2;
    };
    pp$8.isClassElementNameStart = function() {
      return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
    };
    pp$8.parseClassElementName = function(element) {
      if (this.type === types$1.privateId) {
        if (this.value === "constructor") {
          this.raise(this.start, "Classes can't have an element named '#constructor'");
        }
        element.computed = false;
        element.key = this.parsePrivateIdent();
      } else {
        this.parsePropertyName(element);
      }
    };
    pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
      var key = method.key;
      if (method.kind === "constructor") {
        if (isGenerator) {
          this.raise(key.start, "Constructor can't be a generator");
        }
        if (isAsync) {
          this.raise(key.start, "Constructor can't be an async method");
        }
      } else if (method.static && checkKeyName(method, "prototype")) {
        this.raise(key.start, "Classes may not have a static property named prototype");
      }
      var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
      if (method.kind === "get" && value2.params.length !== 0) {
        this.raiseRecoverable(value2.start, "getter should have no params");
      }
      if (method.kind === "set" && value2.params.length !== 1) {
        this.raiseRecoverable(value2.start, "setter should have exactly one param");
      }
      if (method.kind === "set" && value2.params[0].type === "RestElement") {
        this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
      }
      return this.finishNode(method, "MethodDefinition");
    };
    pp$8.parseClassField = function(field) {
      if (checkKeyName(field, "constructor")) {
        this.raise(field.key.start, "Classes can't have a field named 'constructor'");
      } else if (field.static && checkKeyName(field, "prototype")) {
        this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
      }
      if (this.eat(types$1.eq)) {
        var scope = this.currentThisScope();
        var inClassFieldInit = scope.inClassFieldInit;
        scope.inClassFieldInit = true;
        field.value = this.parseMaybeAssign();
        scope.inClassFieldInit = inClassFieldInit;
      } else {
        field.value = null;
      }
      this.semicolon();
      return this.finishNode(field, "PropertyDefinition");
    };
    pp$8.parseClassStaticBlock = function(node2) {
      node2.body = [];
      var oldLabels = this.labels;
      this.labels = [];
      this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
      while (this.type !== types$1.braceR) {
        var stmt = this.parseStatement(null);
        node2.body.push(stmt);
      }
      this.next();
      this.exitScope();
      this.labels = oldLabels;
      return this.finishNode(node2, "StaticBlock");
    };
    pp$8.parseClassId = function(node2, isStatement) {
      if (this.type === types$1.name) {
        node2.id = this.parseIdent();
        if (isStatement) {
          this.checkLValSimple(node2.id, BIND_LEXICAL, false);
        }
      } else {
        if (isStatement === true) {
          this.unexpected();
        }
        node2.id = null;
      }
    };
    pp$8.parseClassSuper = function(node2) {
      node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
    };
    pp$8.enterClassBody = function() {
      var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
      this.privateNameStack.push(element);
      return element.declared;
    };
    pp$8.exitClassBody = function() {
      var ref3 = this.privateNameStack.pop();
      var declared = ref3.declared;
      var used = ref3.used;
      var len = this.privateNameStack.length;
      var parent = len === 0 ? null : this.privateNameStack[len - 1];
      for (var i = 0; i < used.length; ++i) {
        var id = used[i];
        if (!hasOwn(declared, id.name)) {
          if (parent) {
            parent.used.push(id);
          } else {
            this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
          }
        }
      }
    };
    pp$8.parseExport = function(node2, exports2) {
      this.next();
      if (this.eat(types$1.star)) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node2.exported = this.parseModuleExportName();
            this.checkExport(exports2, node2.exported, this.lastTokStart);
          } else {
            node2.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node2.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node2, "ExportAllDeclaration");
      }
      if (this.eat(types$1._default)) {
        this.checkExport(exports2, "default", this.lastTokStart);
        var isAsync;
        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          node2.declaration = this.parseFunction(fNode, FUNC_STATEMENT$1 | FUNC_NULLABLE_ID$1, false, isAsync);
        } else if (this.type === types$1._class) {
          var cNode = this.startNode();
          node2.declaration = this.parseClass(cNode, "nullableID");
        } else {
          node2.declaration = this.parseMaybeAssign();
          this.semicolon();
        }
        return this.finishNode(node2, "ExportDefaultDeclaration");
      }
      if (this.shouldParseExportStatement()) {
        node2.declaration = this.parseStatement(null);
        if (node2.declaration.type === "VariableDeclaration") {
          this.checkVariableExport(exports2, node2.declaration.declarations);
        } else {
          this.checkExport(exports2, node2.declaration.id, node2.declaration.id.start);
        }
        node2.specifiers = [];
        node2.source = null;
      } else {
        node2.declaration = null;
        node2.specifiers = this.parseExportSpecifiers(exports2);
        if (this.eatContextual("from")) {
          if (this.type !== types$1.string) {
            this.unexpected();
          }
          node2.source = this.parseExprAtom();
        } else {
          for (var i = 0, list = node2.specifiers; i < list.length; i += 1) {
            var spec = list[i];
            this.checkUnreserved(spec.local);
            this.checkLocalExport(spec.local);
            if (spec.local.type === "Literal") {
              this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
            }
          }
          node2.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(node2, "ExportNamedDeclaration");
    };
    pp$8.checkExport = function(exports2, name2, pos) {
      if (!exports2) {
        return;
      }
      if (typeof name2 !== "string") {
        name2 = name2.type === "Identifier" ? name2.name : name2.value;
      }
      if (hasOwn(exports2, name2)) {
        this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
      }
      exports2[name2] = true;
    };
    pp$8.checkPatternExport = function(exports2, pat) {
      var type = pat.type;
      if (type === "Identifier") {
        this.checkExport(exports2, pat, pat.start);
      } else if (type === "ObjectPattern") {
        for (var i = 0, list = pat.properties; i < list.length; i += 1) {
          var prop = list[i];
          this.checkPatternExport(exports2, prop);
        }
      } else if (type === "ArrayPattern") {
        for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
          var elt = list$1[i$1];
          if (elt) {
            this.checkPatternExport(exports2, elt);
          }
        }
      } else if (type === "Property") {
        this.checkPatternExport(exports2, pat.value);
      } else if (type === "AssignmentPattern") {
        this.checkPatternExport(exports2, pat.left);
      } else if (type === "RestElement") {
        this.checkPatternExport(exports2, pat.argument);
      } else if (type === "ParenthesizedExpression") {
        this.checkPatternExport(exports2, pat.expression);
      }
    };
    pp$8.checkVariableExport = function(exports2, decls) {
      if (!exports2) {
        return;
      }
      for (var i = 0, list = decls; i < list.length; i += 1) {
        var decl = list[i];
        this.checkPatternExport(exports2, decl.id);
      }
    };
    pp$8.shouldParseExportStatement = function() {
      return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
    };
    pp$8.parseExportSpecifiers = function(exports2) {
      var nodes = [], first2 = true;
      this.expect(types$1.braceL);
      while (!this.eat(types$1.braceR)) {
        if (!first2) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) {
            break;
          }
        } else {
          first2 = false;
        }
        var node2 = this.startNode();
        node2.local = this.parseModuleExportName();
        node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
        this.checkExport(
          exports2,
          node2.exported,
          node2.exported.start
        );
        nodes.push(this.finishNode(node2, "ExportSpecifier"));
      }
      return nodes;
    };
    pp$8.parseImport = function(node2) {
      this.next();
      if (this.type === types$1.string) {
        node2.specifiers = empty$1;
        node2.source = this.parseExprAtom();
      } else {
        node2.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node2.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
      }
      this.semicolon();
      return this.finishNode(node2, "ImportDeclaration");
    };
    pp$8.parseImportSpecifiers = function() {
      var nodes = [], first2 = true;
      if (this.type === types$1.name) {
        var node2 = this.startNode();
        node2.local = this.parseIdent();
        this.checkLValSimple(node2.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node2, "ImportDefaultSpecifier"));
        if (!this.eat(types$1.comma)) {
          return nodes;
        }
      }
      if (this.type === types$1.star) {
        var node$12 = this.startNode();
        this.next();
        this.expectContextual("as");
        node$12.local = this.parseIdent();
        this.checkLValSimple(node$12.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$12, "ImportNamespaceSpecifier"));
        return nodes;
      }
      this.expect(types$1.braceL);
      while (!this.eat(types$1.braceR)) {
        if (!first2) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) {
            break;
          }
        } else {
          first2 = false;
        }
        var node$2 = this.startNode();
        node$2.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node$2.local = this.parseIdent();
        } else {
          this.checkUnreserved(node$2.imported);
          node$2.local = node$2.imported;
        }
        this.checkLValSimple(node$2.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$2, "ImportSpecifier"));
      }
      return nodes;
    };
    pp$8.parseModuleExportName = function() {
      if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
        var stringLiteral = this.parseLiteral(this.value);
        if (loneSurrogate.test(stringLiteral.value)) {
          this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
        }
        return stringLiteral;
      }
      return this.parseIdent(true);
    };
    pp$8.adaptDirectivePrologue = function(statements) {
      for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
        statements[i].directive = statements[i].expression.raw.slice(1, -1);
      }
    };
    pp$8.isDirectiveCandidate = function(statement) {
      return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
      (this.input[statement.start] === '"' || this.input[statement.start] === "'");
    };
    pp$7 = Parser.prototype;
    pp$7.toAssignable = function(node2, isBinding, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 6 && node2) {
        switch (node2.type) {
          case "Identifier":
            if (this.inAsync && node2.name === "await") {
              this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
            }
            break;
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node2.type = "ObjectPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            for (var i = 0, list = node2.properties; i < list.length; i += 1) {
              var prop = list[i];
              this.toAssignable(prop, isBinding);
              if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                this.raise(prop.argument.start, "Unexpected token");
              }
            }
            break;
          case "Property":
            if (node2.kind !== "init") {
              this.raise(node2.key.start, "Object pattern can't contain getter or setter");
            }
            this.toAssignable(node2.value, isBinding);
            break;
          case "ArrayExpression":
            node2.type = "ArrayPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            this.toAssignableList(node2.elements, isBinding);
            break;
          case "SpreadElement":
            node2.type = "RestElement";
            this.toAssignable(node2.argument, isBinding);
            if (node2.argument.type === "AssignmentPattern") {
              this.raise(node2.argument.start, "Rest elements cannot have a default value");
            }
            break;
          case "AssignmentExpression":
            if (node2.operator !== "=") {
              this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
            }
            node2.type = "AssignmentPattern";
            delete node2.operator;
            this.toAssignable(node2.left, isBinding);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
            break;
          case "ChainExpression":
            this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (!isBinding) {
              break;
            }
          default:
            this.raise(node2.start, "Assigning to rvalue");
        }
      } else if (refDestructuringErrors) {
        this.checkPatternErrors(refDestructuringErrors, true);
      }
      return node2;
    };
    pp$7.toAssignableList = function(exprList, isBinding) {
      var end = exprList.length;
      for (var i = 0; i < end; i++) {
        var elt = exprList[i];
        if (elt) {
          this.toAssignable(elt, isBinding);
        }
      }
      if (end) {
        var last = exprList[end - 1];
        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
          this.unexpected(last.argument.start);
        }
      }
      return exprList;
    };
    pp$7.parseSpread = function(refDestructuringErrors) {
      var node2 = this.startNode();
      this.next();
      node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      return this.finishNode(node2, "SpreadElement");
    };
    pp$7.parseRestBinding = function() {
      var node2 = this.startNode();
      this.next();
      if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
        this.unexpected();
      }
      node2.argument = this.parseBindingAtom();
      return this.finishNode(node2, "RestElement");
    };
    pp$7.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6) {
        switch (this.type) {
          case types$1.bracketL:
            var node2 = this.startNode();
            this.next();
            node2.elements = this.parseBindingList(types$1.bracketR, true, true);
            return this.finishNode(node2, "ArrayPattern");
          case types$1.braceL:
            return this.parseObj(true);
        }
      }
      return this.parseIdent();
    };
    pp$7.parseBindingList = function(close2, allowEmpty, allowTrailingComma) {
      var elts = [], first2 = true;
      while (!this.eat(close2)) {
        if (first2) {
          first2 = false;
        } else {
          this.expect(types$1.comma);
        }
        if (allowEmpty && this.type === types$1.comma) {
          elts.push(null);
        } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
          break;
        } else if (this.type === types$1.ellipsis) {
          var rest = this.parseRestBinding();
          this.parseBindingListItem(rest);
          elts.push(rest);
          if (this.type === types$1.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          this.expect(close2);
          break;
        } else {
          var elem = this.parseMaybeDefault(this.start, this.startLoc);
          this.parseBindingListItem(elem);
          elts.push(elem);
        }
      }
      return elts;
    };
    pp$7.parseBindingListItem = function(param) {
      return param;
    };
    pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
      left = left || this.parseBindingAtom();
      if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
        return left;
      }
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.left = left;
      node2.right = this.parseMaybeAssign();
      return this.finishNode(node2, "AssignmentPattern");
    };
    pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE;
      var isBind = bindingType !== BIND_NONE;
      switch (expr.type) {
        case "Identifier":
          if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
            this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
          }
          if (isBind) {
            if (bindingType === BIND_LEXICAL && expr.name === "let") {
              this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
            }
            if (checkClashes) {
              if (hasOwn(checkClashes, expr.name)) {
                this.raiseRecoverable(expr.start, "Argument name clash");
              }
              checkClashes[expr.name] = true;
            }
            if (bindingType !== BIND_OUTSIDE) {
              this.declareName(expr.name, bindingType, expr.start);
            }
          }
          break;
        case "ChainExpression":
          this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding member expression");
          }
          break;
        case "ParenthesizedExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding parenthesized expression");
          }
          return this.checkLValSimple(expr.expression, bindingType, checkClashes);
        default:
          this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
      }
    };
    pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE;
      switch (expr.type) {
        case "ObjectPattern":
          for (var i = 0, list = expr.properties; i < list.length; i += 1) {
            var prop = list[i];
            this.checkLValInnerPattern(prop, bindingType, checkClashes);
          }
          break;
        case "ArrayPattern":
          for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
            var elem = list$1[i$1];
            if (elem) {
              this.checkLValInnerPattern(elem, bindingType, checkClashes);
            }
          }
          break;
        default:
          this.checkLValSimple(expr, bindingType, checkClashes);
      }
    };
    pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE;
      switch (expr.type) {
        case "Property":
          this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
          break;
        case "AssignmentPattern":
          this.checkLValPattern(expr.left, bindingType, checkClashes);
          break;
        case "RestElement":
          this.checkLValPattern(expr.argument, bindingType, checkClashes);
          break;
        default:
          this.checkLValPattern(expr, bindingType, checkClashes);
      }
    };
    TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
      this.generator = !!generator;
    };
    types = {
      b_stat: new TokContext("{", false),
      b_expr: new TokContext("{", true),
      b_tmpl: new TokContext("${", false),
      p_stat: new TokContext("(", false),
      p_expr: new TokContext("(", true),
      q_tmpl: new TokContext("`", true, true, function(p) {
        return p.tryReadTemplateToken();
      }),
      f_stat: new TokContext("function", false),
      f_expr: new TokContext("function", true),
      f_expr_gen: new TokContext("function", true, false, null, true),
      f_gen: new TokContext("function", false, false, null, true)
    };
    pp$6 = Parser.prototype;
    pp$6.initialContext = function() {
      return [types.b_stat];
    };
    pp$6.curContext = function() {
      return this.context[this.context.length - 1];
    };
    pp$6.braceIsBlock = function(prevType) {
      var parent = this.curContext();
      if (parent === types.f_expr || parent === types.f_stat) {
        return true;
      }
      if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
        return !parent.isExpr;
      }
      if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
        return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      }
      if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
        return true;
      }
      if (prevType === types$1.braceL) {
        return parent === types.b_stat;
      }
      if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
        return false;
      }
      return !this.exprAllowed;
    };
    pp$6.inGeneratorContext = function() {
      for (var i = this.context.length - 1; i >= 1; i--) {
        var context = this.context[i];
        if (context.token === "function") {
          return context.generator;
        }
      }
      return false;
    };
    pp$6.updateContext = function(prevType) {
      var update, type = this.type;
      if (type.keyword && prevType === types$1.dot) {
        this.exprAllowed = false;
      } else if (update = type.updateContext) {
        update.call(this, prevType);
      } else {
        this.exprAllowed = type.beforeExpr;
      }
    };
    pp$6.overrideContext = function(tokenCtx) {
      if (this.curContext() !== tokenCtx) {
        this.context[this.context.length - 1] = tokenCtx;
      }
    };
    types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
      if (this.context.length === 1) {
        this.exprAllowed = true;
        return;
      }
      var out = this.context.pop();
      if (out === types.b_stat && this.curContext().token === "function") {
        out = this.context.pop();
      }
      this.exprAllowed = !out.isExpr;
    };
    types$1.braceL.updateContext = function(prevType) {
      this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
      this.exprAllowed = true;
    };
    types$1.dollarBraceL.updateContext = function() {
      this.context.push(types.b_tmpl);
      this.exprAllowed = true;
    };
    types$1.parenL.updateContext = function(prevType) {
      var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
      this.context.push(statementParens ? types.p_stat : types.p_expr);
      this.exprAllowed = true;
    };
    types$1.incDec.updateContext = function() {
    };
    types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
      if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
        this.context.push(types.f_expr);
      } else {
        this.context.push(types.f_stat);
      }
      this.exprAllowed = false;
    };
    types$1.backQuote.updateContext = function() {
      if (this.curContext() === types.q_tmpl) {
        this.context.pop();
      } else {
        this.context.push(types.q_tmpl);
      }
      this.exprAllowed = false;
    };
    types$1.star.updateContext = function(prevType) {
      if (prevType === types$1._function) {
        var index = this.context.length - 1;
        if (this.context[index] === types.f_expr) {
          this.context[index] = types.f_expr_gen;
        } else {
          this.context[index] = types.f_gen;
        }
      }
      this.exprAllowed = true;
    };
    types$1.name.updateContext = function(prevType) {
      var allowed = false;
      if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
        if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
          allowed = true;
        }
      }
      this.exprAllowed = allowed;
    };
    pp$5 = Parser.prototype;
    pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
        return;
      }
      if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
        return;
      }
      var key = prop.key;
      var name2;
      switch (key.type) {
        case "Identifier":
          name2 = key.name;
          break;
        case "Literal":
          name2 = String(key.value);
          break;
        default:
          return;
      }
      var kind = prop.kind;
      if (this.options.ecmaVersion >= 6) {
        if (name2 === "__proto__" && kind === "init") {
          if (propHash.proto) {
            if (refDestructuringErrors) {
              if (refDestructuringErrors.doubleProto < 0) {
                refDestructuringErrors.doubleProto = key.start;
              }
            } else {
              this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
            }
          }
          propHash.proto = true;
        }
        return;
      }
      name2 = "$" + name2;
      var other = propHash[name2];
      if (other) {
        var redefinition;
        if (kind === "init") {
          redefinition = this.strict && other.init || other.get || other.set;
        } else {
          redefinition = other.init || other[kind];
        }
        if (redefinition) {
          this.raiseRecoverable(key.start, "Redefinition of property");
        }
      } else {
        other = propHash[name2] = {
          init: false,
          get: false,
          set: false
        };
      }
      other[kind] = true;
    };
    pp$5.parseExpression = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
      if (this.type === types$1.comma) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.expressions = [expr];
        while (this.eat(types$1.comma)) {
          node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
        }
        return this.finishNode(node2, "SequenceExpression");
      }
      return expr;
    };
    pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
      if (this.isContextual("yield")) {
        if (this.inGenerator) {
          return this.parseYield(forInit);
        } else {
          this.exprAllowed = false;
        }
      }
      var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
      if (refDestructuringErrors) {
        oldParenAssign = refDestructuringErrors.parenthesizedAssign;
        oldTrailingComma = refDestructuringErrors.trailingComma;
        oldDoubleProto = refDestructuringErrors.doubleProto;
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
      } else {
        refDestructuringErrors = new DestructuringErrors();
        ownDestructuringErrors = true;
      }
      var startPos = this.start, startLoc = this.startLoc;
      if (this.type === types$1.parenL || this.type === types$1.name) {
        this.potentialArrowAt = this.start;
        this.potentialArrowInForAwait = forInit === "await";
      }
      var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }
      if (this.type.isAssign) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.operator = this.value;
        if (this.type === types$1.eq) {
          left = this.toAssignable(left, false, refDestructuringErrors);
        }
        if (!ownDestructuringErrors) {
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
        }
        if (refDestructuringErrors.shorthandAssign >= left.start) {
          refDestructuringErrors.shorthandAssign = -1;
        }
        if (this.type === types$1.eq) {
          this.checkLValPattern(left);
        } else {
          this.checkLValSimple(left);
        }
        node2.left = left;
        this.next();
        node2.right = this.parseMaybeAssign(forInit);
        if (oldDoubleProto > -1) {
          refDestructuringErrors.doubleProto = oldDoubleProto;
        }
        return this.finishNode(node2, "AssignmentExpression");
      } else {
        if (ownDestructuringErrors) {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
      }
      if (oldParenAssign > -1) {
        refDestructuringErrors.parenthesizedAssign = oldParenAssign;
      }
      if (oldTrailingComma > -1) {
        refDestructuringErrors.trailingComma = oldTrailingComma;
      }
      return left;
    };
    pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprOps(forInit, refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      if (this.eat(types$1.question)) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.test = expr;
        node2.consequent = this.parseMaybeAssign();
        this.expect(types$1.colon);
        node2.alternate = this.parseMaybeAssign(forInit);
        return this.finishNode(node2, "ConditionalExpression");
      }
      return expr;
    };
    pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
    };
    pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
      var prec = this.type.binop;
      if (prec != null && (!forInit || this.type !== types$1._in)) {
        if (prec > minPrec) {
          var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
          var coalesce = this.type === types$1.coalesce;
          if (coalesce) {
            prec = types$1.logicalAND.binop;
          }
          var op = this.value;
          this.next();
          var startPos = this.start, startLoc = this.startLoc;
          var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
          var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
          if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
            this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
          }
          return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
        }
      }
      return left;
    };
    pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
      if (right.type === "PrivateIdentifier") {
        this.raise(right.start, "Private identifier can only be left side of binary expression");
      }
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.left = left;
      node2.operator = op;
      node2.right = right;
      return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
    };
    pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
      var startPos = this.start, startLoc = this.startLoc, expr;
      if (this.isContextual("await") && this.canAwait) {
        expr = this.parseAwait(forInit);
        sawUnary = true;
      } else if (this.type.prefix) {
        var node2 = this.startNode(), update = this.type === types$1.incDec;
        node2.operator = this.value;
        node2.prefix = true;
        this.next();
        node2.argument = this.parseMaybeUnary(null, true, update, forInit);
        this.checkExpressionErrors(refDestructuringErrors, true);
        if (update) {
          this.checkLValSimple(node2.argument);
        } else if (this.strict && node2.operator === "delete" && node2.argument.type === "Identifier") {
          this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
        } else if (node2.operator === "delete" && isPrivateFieldAccess(node2.argument)) {
          this.raiseRecoverable(node2.start, "Private fields can not be deleted");
        } else {
          sawUnary = true;
        }
        expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
      } else if (!sawUnary && this.type === types$1.privateId) {
        if (forInit || this.privateNameStack.length === 0) {
          this.unexpected();
        }
        expr = this.parsePrivateIdent();
        if (this.type !== types$1._in) {
          this.unexpected();
        }
      } else {
        expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        while (this.type.postfix && !this.canInsertSemicolon()) {
          var node$12 = this.startNodeAt(startPos, startLoc);
          node$12.operator = this.value;
          node$12.prefix = false;
          node$12.argument = expr;
          this.checkLValSimple(expr);
          this.next();
          expr = this.finishNode(node$12, "UpdateExpression");
        }
      }
      if (!incDec && this.eat(types$1.starstar)) {
        if (sawUnary) {
          this.unexpected(this.lastTokStart);
        } else {
          return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
        }
      } else {
        return expr;
      }
    };
    pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprAtom(refDestructuringErrors, forInit);
      if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
        return expr;
      }
      var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
      if (refDestructuringErrors && result.type === "MemberExpression") {
        if (refDestructuringErrors.parenthesizedAssign >= result.start) {
          refDestructuringErrors.parenthesizedAssign = -1;
        }
        if (refDestructuringErrors.parenthesizedBind >= result.start) {
          refDestructuringErrors.parenthesizedBind = -1;
        }
        if (refDestructuringErrors.trailingComma >= result.start) {
          refDestructuringErrors.trailingComma = -1;
        }
      }
      return result;
    };
    pp$5.parseSubscripts = function(base3, startPos, startLoc, noCalls, forInit) {
      var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base3.type === "Identifier" && base3.name === "async" && this.lastTokEnd === base3.end && !this.canInsertSemicolon() && base3.end - base3.start === 5 && this.potentialArrowAt === base3.start;
      var optionalChained = false;
      while (true) {
        var element = this.parseSubscript(base3, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
        if (element.optional) {
          optionalChained = true;
        }
        if (element === base3 || element.type === "ArrowFunctionExpression") {
          if (optionalChained) {
            var chainNode = this.startNodeAt(startPos, startLoc);
            chainNode.expression = element;
            element = this.finishNode(chainNode, "ChainExpression");
          }
          return element;
        }
        base3 = element;
      }
    };
    pp$5.parseSubscript = function(base3, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
      var optionalSupported = this.options.ecmaVersion >= 11;
      var optional = optionalSupported && this.eat(types$1.questionDot);
      if (noCalls && optional) {
        this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
      }
      var computed = this.eat(types$1.bracketL);
      if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.object = base3;
        if (computed) {
          node2.property = this.parseExpression();
          this.expect(types$1.bracketR);
        } else if (this.type === types$1.privateId && base3.type !== "Super") {
          node2.property = this.parsePrivateIdent();
        } else {
          node2.property = this.parseIdent(this.options.allowReserved !== "never");
        }
        node2.computed = !!computed;
        if (optionalSupported) {
          node2.optional = optional;
        }
        base3 = this.finishNode(node2, "MemberExpression");
      } else if (!noCalls && this.eat(types$1.parenL)) {
        var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
        if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          if (this.awaitIdentPos > 0) {
            this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
          }
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
        var node$12 = this.startNodeAt(startPos, startLoc);
        node$12.callee = base3;
        node$12.arguments = exprList;
        if (optionalSupported) {
          node$12.optional = optional;
        }
        base3 = this.finishNode(node$12, "CallExpression");
      } else if (this.type === types$1.backQuote) {
        if (optional || optionalChained) {
          this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        }
        var node$2 = this.startNodeAt(startPos, startLoc);
        node$2.tag = base3;
        node$2.quasi = this.parseTemplate({ isTagged: true });
        base3 = this.finishNode(node$2, "TaggedTemplateExpression");
      }
      return base3;
    };
    pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
      if (this.type === types$1.slash) {
        this.readRegexp();
      }
      var node2, canBeArrow = this.potentialArrowAt === this.start;
      switch (this.type) {
        case types$1._super:
          if (!this.allowSuper) {
            this.raise(this.start, "'super' keyword outside a method");
          }
          node2 = this.startNode();
          this.next();
          if (this.type === types$1.parenL && !this.allowDirectSuper) {
            this.raise(node2.start, "super() call outside constructor of a subclass");
          }
          if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
            this.unexpected();
          }
          return this.finishNode(node2, "Super");
        case types$1._this:
          node2 = this.startNode();
          this.next();
          return this.finishNode(node2, "ThisExpression");
        case types$1.name:
          var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          var id = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
            this.overrideContext(types.f_expr);
            return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(types$1.arrow)) {
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
            }
            if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
              id = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                this.unexpected();
              }
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
            }
          }
          return id;
        case types$1.regexp:
          var value2 = this.value;
          node2 = this.parseLiteral(value2.value);
          node2.regex = { pattern: value2.pattern, flags: value2.flags };
          return node2;
        case types$1.num:
        case types$1.string:
          return this.parseLiteral(this.value);
        case types$1._null:
        case types$1._true:
        case types$1._false:
          node2 = this.startNode();
          node2.value = this.type === types$1._null ? null : this.type === types$1._true;
          node2.raw = this.type.keyword;
          this.next();
          return this.finishNode(node2, "Literal");
        case types$1.parenL:
          var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
          if (refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
              refDestructuringErrors.parenthesizedAssign = start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = start;
            }
          }
          return expr;
        case types$1.bracketL:
          node2 = this.startNode();
          this.next();
          node2.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
          return this.finishNode(node2, "ArrayExpression");
        case types$1.braceL:
          this.overrideContext(types.b_expr);
          return this.parseObj(false, refDestructuringErrors);
        case types$1._function:
          node2 = this.startNode();
          this.next();
          return this.parseFunction(node2, 0);
        case types$1._class:
          return this.parseClass(this.startNode(), false);
        case types$1._new:
          return this.parseNew();
        case types$1.backQuote:
          return this.parseTemplate();
        case types$1._import:
          if (this.options.ecmaVersion >= 11) {
            return this.parseExprImport();
          } else {
            return this.unexpected();
          }
        default:
          this.unexpected();
      }
    };
    pp$5.parseExprImport = function() {
      var node2 = this.startNode();
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword import");
      }
      var meta = this.parseIdent(true);
      switch (this.type) {
        case types$1.parenL:
          return this.parseDynamicImport(node2);
        case types$1.dot:
          node2.meta = meta;
          return this.parseImportMeta(node2);
        default:
          this.unexpected();
      }
    };
    pp$5.parseDynamicImport = function(node2) {
      this.next();
      node2.source = this.parseMaybeAssign();
      if (!this.eat(types$1.parenR)) {
        var errorPos = this.start;
        if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
          this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
        } else {
          this.unexpected(errorPos);
        }
      }
      return this.finishNode(node2, "ImportExpression");
    };
    pp$5.parseImportMeta = function(node2) {
      this.next();
      var containsEsc = this.containsEsc;
      node2.property = this.parseIdent(true);
      if (node2.property.name !== "meta") {
        this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
      }
      if (containsEsc) {
        this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
      }
      if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
        this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
      }
      return this.finishNode(node2, "MetaProperty");
    };
    pp$5.parseLiteral = function(value2) {
      var node2 = this.startNode();
      node2.value = value2;
      node2.raw = this.input.slice(this.start, this.end);
      if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
        node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
      }
      this.next();
      return this.finishNode(node2, "Literal");
    };
    pp$5.parseParenExpression = function() {
      this.expect(types$1.parenL);
      var val = this.parseExpression();
      this.expect(types$1.parenR);
      return val;
    };
    pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
      var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();
        var innerStartPos = this.start, innerStartLoc = this.startLoc;
        var exprList = [], first2 = true, lastIsComma = false;
        var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
        this.yieldPos = 0;
        this.awaitPos = 0;
        while (this.type !== types$1.parenR) {
          first2 ? first2 = false : this.expect(types$1.comma);
          if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
            lastIsComma = true;
            break;
          } else if (this.type === types$1.ellipsis) {
            spreadStart = this.start;
            exprList.push(this.parseParenItem(this.parseRestBinding()));
            if (this.type === types$1.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            break;
          } else {
            exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
          }
        }
        var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
        this.expect(types$1.parenR);
        if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
        }
        if (!exprList.length || lastIsComma) {
          this.unexpected(this.lastTokStart);
        }
        if (spreadStart) {
          this.unexpected(spreadStart);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }
      } else {
        val = this.parseParenExpression();
      }
      if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression");
      } else {
        return val;
      }
    };
    pp$5.parseParenItem = function(item) {
      return item;
    };
    pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
    };
    empty = [];
    pp$5.parseNew = function() {
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword new");
      }
      var node2 = this.startNode();
      var meta = this.parseIdent(true);
      if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
        node2.meta = meta;
        var containsEsc = this.containsEsc;
        node2.property = this.parseIdent(true);
        if (node2.property.name !== "target") {
          this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
        }
        if (!this.allowNewDotTarget) {
          this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
        }
        return this.finishNode(node2, "MetaProperty");
      }
      var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
      node2.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
      if (isImport && node2.callee.type === "ImportExpression") {
        this.raise(startPos, "Cannot use new with import()");
      }
      if (this.eat(types$1.parenL)) {
        node2.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
      } else {
        node2.arguments = empty;
      }
      return this.finishNode(node2, "NewExpression");
    };
    pp$5.parseTemplateElement = function(ref3) {
      var isTagged = ref3.isTagged;
      var elem = this.startNode();
      if (this.type === types$1.invalidTemplate) {
        if (!isTagged) {
          this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        }
        elem.value = {
          raw: this.value,
          cooked: null
        };
      } else {
        elem.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
          cooked: this.value
        };
      }
      this.next();
      elem.tail = this.type === types$1.backQuote;
      return this.finishNode(elem, "TemplateElement");
    };
    pp$5.parseTemplate = function(ref3) {
      if (ref3 === void 0)
        ref3 = {};
      var isTagged = ref3.isTagged;
      if (isTagged === void 0)
        isTagged = false;
      var node2 = this.startNode();
      this.next();
      node2.expressions = [];
      var curElt = this.parseTemplateElement({ isTagged });
      node2.quasis = [curElt];
      while (!curElt.tail) {
        if (this.type === types$1.eof) {
          this.raise(this.pos, "Unterminated template literal");
        }
        this.expect(types$1.dollarBraceL);
        node2.expressions.push(this.parseExpression());
        this.expect(types$1.braceR);
        node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
      }
      this.next();
      return this.finishNode(node2, "TemplateLiteral");
    };
    pp$5.isAsyncProp = function(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$5.parseObj = function(isPattern, refDestructuringErrors) {
      var node2 = this.startNode(), first2 = true, propHash = {};
      node2.properties = [];
      this.next();
      while (!this.eat(types$1.braceR)) {
        if (!first2) {
          this.expect(types$1.comma);
          if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
            break;
          }
        } else {
          first2 = false;
        }
        var prop = this.parseProperty(isPattern, refDestructuringErrors);
        if (!isPattern) {
          this.checkPropClash(prop, propHash, refDestructuringErrors);
        }
        node2.properties.push(prop);
      }
      return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
    };
    pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
      var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
      if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
        if (isPattern) {
          prop.argument = this.parseIdent(false);
          if (this.type === types$1.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          return this.finishNode(prop, "RestElement");
        }
        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
        return this.finishNode(prop, "SpreadElement");
      }
      if (this.options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refDestructuringErrors) {
          startPos = this.start;
          startLoc = this.startLoc;
        }
        if (!isPattern) {
          isGenerator = this.eat(types$1.star);
        }
      }
      var containsEsc = this.containsEsc;
      this.parsePropertyName(prop);
      if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
        this.parsePropertyName(prop);
      } else {
        isAsync = false;
      }
      this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
      return this.finishNode(prop, "Property");
    };
    pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
      if ((isGenerator || isAsync) && this.type === types$1.colon) {
        this.unexpected();
      }
      if (this.eat(types$1.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
        prop.kind = "init";
      } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
        if (isPattern) {
          this.unexpected();
        }
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator, isAsync);
      } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
        if (isGenerator || isAsync) {
          this.unexpected();
        }
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        if (isGenerator || isAsync) {
          this.unexpected();
        }
        this.checkUnreserved(prop.key);
        if (prop.key.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = startPos;
        }
        prop.kind = "init";
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else if (this.type === types$1.eq && refDestructuringErrors) {
          if (refDestructuringErrors.shorthandAssign < 0) {
            refDestructuringErrors.shorthandAssign = this.start;
          }
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else {
          prop.value = this.copyNode(prop.key);
        }
        prop.shorthand = true;
      } else {
        this.unexpected();
      }
    };
    pp$5.parsePropertyName = function(prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(types$1.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(types$1.bracketR);
          return prop.key;
        } else {
          prop.computed = false;
        }
      }
      return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    };
    pp$5.initFunction = function(node2) {
      node2.id = null;
      if (this.options.ecmaVersion >= 6) {
        node2.generator = node2.expression = false;
      }
      if (this.options.ecmaVersion >= 8) {
        node2.async = false;
      }
    };
    pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
      var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.initFunction(node2);
      if (this.options.ecmaVersion >= 6) {
        node2.generator = isGenerator;
      }
      if (this.options.ecmaVersion >= 8) {
        node2.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(isAsync, node2.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.expect(types$1.parenL);
      node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
      this.parseFunctionBody(node2, false, true, false);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node2, "FunctionExpression");
    };
    pp$5.parseArrowExpression = function(node2, params, isAsync, forInit) {
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
      this.initFunction(node2);
      if (this.options.ecmaVersion >= 8) {
        node2.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      node2.params = this.toAssignableList(params, true);
      this.parseFunctionBody(node2, true, false, forInit);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node2, "ArrowFunctionExpression");
    };
    pp$5.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
      var isExpression = isArrowFunction && this.type !== types$1.braceL;
      var oldStrict = this.strict, useStrict = false;
      if (isExpression) {
        node2.body = this.parseMaybeAssign(forInit);
        node2.expression = true;
        this.checkParams(node2, false);
      } else {
        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
        if (!oldStrict || nonSimple) {
          useStrict = this.strictDirective(this.end);
          if (useStrict && nonSimple) {
            this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
          }
        }
        var oldLabels = this.labels;
        this.labels = [];
        if (useStrict) {
          this.strict = true;
        }
        this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
        if (this.strict && node2.id) {
          this.checkLValSimple(node2.id, BIND_OUTSIDE);
        }
        node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
        node2.expression = false;
        this.adaptDirectivePrologue(node2.body.body);
        this.labels = oldLabels;
      }
      this.exitScope();
    };
    pp$5.isSimpleParamList = function(params) {
      for (var i = 0, list = params; i < list.length; i += 1) {
        var param = list[i];
        if (param.type !== "Identifier") {
          return false;
        }
      }
      return true;
    };
    pp$5.checkParams = function(node2, allowDuplicates) {
      var nameHash = /* @__PURE__ */ Object.create(null);
      for (var i = 0, list = node2.params; i < list.length; i += 1) {
        var param = list[i];
        this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
      }
    };
    pp$5.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
      var elts = [], first2 = true;
      while (!this.eat(close2)) {
        if (!first2) {
          this.expect(types$1.comma);
          if (allowTrailingComma && this.afterTrailingComma(close2)) {
            break;
          }
        } else {
          first2 = false;
        }
        var elt = void 0;
        if (allowEmpty && this.type === types$1.comma) {
          elt = null;
        } else if (this.type === types$1.ellipsis) {
          elt = this.parseSpread(refDestructuringErrors);
          if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
        } else {
          elt = this.parseMaybeAssign(false, refDestructuringErrors);
        }
        elts.push(elt);
      }
      return elts;
    };
    pp$5.checkUnreserved = function(ref3) {
      var start = ref3.start;
      var end = ref3.end;
      var name2 = ref3.name;
      if (this.inGenerator && name2 === "yield") {
        this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
      }
      if (this.inAsync && name2 === "await") {
        this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
      }
      if (this.currentThisScope().inClassFieldInit && name2 === "arguments") {
        this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
      }
      if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
        this.raise(start, "Cannot use " + name2 + " in class static initialization block");
      }
      if (this.keywords.test(name2)) {
        this.raise(start, "Unexpected keyword '" + name2 + "'");
      }
      if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
        return;
      }
      var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
      if (re.test(name2)) {
        if (!this.inAsync && name2 === "await") {
          this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
        }
        this.raiseRecoverable(start, "The keyword '" + name2 + "' is reserved");
      }
    };
    pp$5.parseIdent = function(liberal) {
      var node2 = this.startNode();
      if (this.type === types$1.name) {
        node2.name = this.value;
      } else if (this.type.keyword) {
        node2.name = this.type.keyword;
        if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
          this.context.pop();
        }
      } else {
        this.unexpected();
      }
      this.next(!!liberal);
      this.finishNode(node2, "Identifier");
      if (!liberal) {
        this.checkUnreserved(node2);
        if (node2.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = node2.start;
        }
      }
      return node2;
    };
    pp$5.parsePrivateIdent = function() {
      var node2 = this.startNode();
      if (this.type === types$1.privateId) {
        node2.name = this.value;
      } else {
        this.unexpected();
      }
      this.next();
      this.finishNode(node2, "PrivateIdentifier");
      if (this.privateNameStack.length === 0) {
        this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
      } else {
        this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
      }
      return node2;
    };
    pp$5.parseYield = function(forInit) {
      if (!this.yieldPos) {
        this.yieldPos = this.start;
      }
      var node2 = this.startNode();
      this.next();
      if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
        node2.delegate = false;
        node2.argument = null;
      } else {
        node2.delegate = this.eat(types$1.star);
        node2.argument = this.parseMaybeAssign(forInit);
      }
      return this.finishNode(node2, "YieldExpression");
    };
    pp$5.parseAwait = function(forInit) {
      if (!this.awaitPos) {
        this.awaitPos = this.start;
      }
      var node2 = this.startNode();
      this.next();
      node2.argument = this.parseMaybeUnary(null, true, false, forInit);
      return this.finishNode(node2, "AwaitExpression");
    };
    pp$4 = Parser.prototype;
    pp$4.raise = function(pos, message) {
      var loc = getLineInfo(this.input, pos);
      message += " (" + loc.line + ":" + loc.column + ")";
      var err = new SyntaxError(message);
      err.pos = pos;
      err.loc = loc;
      err.raisedAt = this.pos;
      throw err;
    };
    pp$4.raiseRecoverable = pp$4.raise;
    pp$4.curPosition = function() {
      if (this.options.locations) {
        return new Position(this.curLine, this.pos - this.lineStart);
      }
    };
    pp$3 = Parser.prototype;
    Scope2 = function Scope3(flags) {
      this.flags = flags;
      this.var = [];
      this.lexical = [];
      this.functions = [];
      this.inClassFieldInit = false;
    };
    pp$3.enterScope = function(flags) {
      this.scopeStack.push(new Scope2(flags));
    };
    pp$3.exitScope = function() {
      this.scopeStack.pop();
    };
    pp$3.treatFunctionsAsVarInScope = function(scope) {
      return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
    };
    pp$3.declareName = function(name2, bindingType, pos) {
      var redeclared = false;
      if (bindingType === BIND_LEXICAL) {
        var scope = this.currentScope();
        redeclared = scope.lexical.indexOf(name2) > -1 || scope.functions.indexOf(name2) > -1 || scope.var.indexOf(name2) > -1;
        scope.lexical.push(name2);
        if (this.inModule && scope.flags & SCOPE_TOP) {
          delete this.undefinedExports[name2];
        }
      } else if (bindingType === BIND_SIMPLE_CATCH) {
        var scope$1 = this.currentScope();
        scope$1.lexical.push(name2);
      } else if (bindingType === BIND_FUNCTION) {
        var scope$2 = this.currentScope();
        if (this.treatFunctionsAsVar) {
          redeclared = scope$2.lexical.indexOf(name2) > -1;
        } else {
          redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
        }
        scope$2.functions.push(name2);
      } else {
        for (var i = this.scopeStack.length - 1; i >= 0; --i) {
          var scope$3 = this.scopeStack[i];
          if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
            redeclared = true;
            break;
          }
          scope$3.var.push(name2);
          if (this.inModule && scope$3.flags & SCOPE_TOP) {
            delete this.undefinedExports[name2];
          }
          if (scope$3.flags & SCOPE_VAR) {
            break;
          }
        }
      }
      if (redeclared) {
        this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
      }
    };
    pp$3.checkLocalExport = function(id) {
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
        this.undefinedExports[id.name] = id;
      }
    };
    pp$3.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1];
    };
    pp$3.currentVarScope = function() {
      for (var i = this.scopeStack.length - 1; ; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR) {
          return scope;
        }
      }
    };
    pp$3.currentThisScope = function() {
      for (var i = this.scopeStack.length - 1; ; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
          return scope;
        }
      }
    };
    Node = function Node2(parser, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      if (parser.options.locations) {
        this.loc = new SourceLocation(parser, loc);
      }
      if (parser.options.directSourceFile) {
        this.sourceFile = parser.options.directSourceFile;
      }
      if (parser.options.ranges) {
        this.range = [pos, 0];
      }
    };
    pp$2 = Parser.prototype;
    pp$2.startNode = function() {
      return new Node(this, this.start, this.startLoc);
    };
    pp$2.startNodeAt = function(pos, loc) {
      return new Node(this, pos, loc);
    };
    pp$2.finishNode = function(node2, type) {
      return finishNodeAt.call(this, node2, type, this.lastTokEnd, this.lastTokEndLoc);
    };
    pp$2.finishNodeAt = function(node2, type, pos, loc) {
      return finishNodeAt.call(this, node2, type, pos, loc);
    };
    pp$2.copyNode = function(node2) {
      var newNode = new Node(this, node2.start, this.startLoc);
      for (var prop in node2) {
        newNode[prop] = node2[prop];
      }
      return newNode;
    };
    ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
    ecma11BinaryProperties = ecma10BinaryProperties;
    ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
    ecma13BinaryProperties = ecma12BinaryProperties;
    ecma14BinaryProperties = ecma13BinaryProperties;
    unicodeBinaryProperties = {
      9: ecma9BinaryProperties,
      10: ecma10BinaryProperties,
      11: ecma11BinaryProperties,
      12: ecma12BinaryProperties,
      13: ecma13BinaryProperties,
      14: ecma14BinaryProperties
    };
    unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
    ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
    ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
    ecma14ScriptValues = ecma13ScriptValues + " Kawi Nag_Mundari Nagm";
    unicodeScriptValues = {
      9: ecma9ScriptValues,
      10: ecma10ScriptValues,
      11: ecma11ScriptValues,
      12: ecma12ScriptValues,
      13: ecma13ScriptValues,
      14: ecma14ScriptValues
    };
    data = {};
    for (i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
      ecmaVersion = list[i];
      buildUnicodeData(ecmaVersion);
    }
    pp$1 = Parser.prototype;
    RegExpValidationState = function RegExpValidationState2(parser) {
      this.parser = parser;
      this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "");
      this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
      this.source = "";
      this.flags = "";
      this.start = 0;
      this.switchU = false;
      this.switchN = false;
      this.pos = 0;
      this.lastIntValue = 0;
      this.lastStringValue = "";
      this.lastAssertionIsQuantifiable = false;
      this.numCapturingParens = 0;
      this.maxBackReference = 0;
      this.groupNames = [];
      this.backReferenceNames = [];
    };
    RegExpValidationState.prototype.reset = function reset(start, pattern2, flags) {
      var unicode = flags.indexOf("u") !== -1;
      this.start = start | 0;
      this.source = pattern2 + "";
      this.flags = flags;
      this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
      this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
    };
    RegExpValidationState.prototype.raise = function raise(message) {
      this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
    };
    RegExpValidationState.prototype.at = function at(i, forceU) {
      if (forceU === void 0)
        forceU = false;
      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return -1;
      }
      var c = s.charCodeAt(i);
      if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
        return c;
      }
      var next = s.charCodeAt(i + 1);
      return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
    };
    RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
      if (forceU === void 0)
        forceU = false;
      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return l;
      }
      var c = s.charCodeAt(i), next;
      if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
        return i + 1;
      }
      return i + 2;
    };
    RegExpValidationState.prototype.current = function current(forceU) {
      if (forceU === void 0)
        forceU = false;
      return this.at(this.pos, forceU);
    };
    RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
      if (forceU === void 0)
        forceU = false;
      return this.at(this.nextIndex(this.pos, forceU), forceU);
    };
    RegExpValidationState.prototype.advance = function advance(forceU) {
      if (forceU === void 0)
        forceU = false;
      this.pos = this.nextIndex(this.pos, forceU);
    };
    RegExpValidationState.prototype.eat = function eat(ch, forceU) {
      if (forceU === void 0)
        forceU = false;
      if (this.current(forceU) === ch) {
        this.advance(forceU);
        return true;
      }
      return false;
    };
    pp$1.validateRegExpFlags = function(state) {
      var validFlags = state.validFlags;
      var flags = state.flags;
      for (var i = 0; i < flags.length; i++) {
        var flag = flags.charAt(i);
        if (validFlags.indexOf(flag) === -1) {
          this.raise(state.start, "Invalid regular expression flag");
        }
        if (flags.indexOf(flag, i + 1) > -1) {
          this.raise(state.start, "Duplicate regular expression flag");
        }
      }
    };
    pp$1.validateRegExpPattern = function(state) {
      this.regexp_pattern(state);
      if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
        state.switchN = true;
        this.regexp_pattern(state);
      }
    };
    pp$1.regexp_pattern = function(state) {
      state.pos = 0;
      state.lastIntValue = 0;
      state.lastStringValue = "";
      state.lastAssertionIsQuantifiable = false;
      state.numCapturingParens = 0;
      state.maxBackReference = 0;
      state.groupNames.length = 0;
      state.backReferenceNames.length = 0;
      this.regexp_disjunction(state);
      if (state.pos !== state.source.length) {
        if (state.eat(
          41
          /* ) */
        )) {
          state.raise("Unmatched ')'");
        }
        if (state.eat(
          93
          /* ] */
        ) || state.eat(
          125
          /* } */
        )) {
          state.raise("Lone quantifier brackets");
        }
      }
      if (state.maxBackReference > state.numCapturingParens) {
        state.raise("Invalid escape");
      }
      for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
        var name2 = list[i];
        if (state.groupNames.indexOf(name2) === -1) {
          state.raise("Invalid named capture referenced");
        }
      }
    };
    pp$1.regexp_disjunction = function(state) {
      this.regexp_alternative(state);
      while (state.eat(
        124
        /* | */
      )) {
        this.regexp_alternative(state);
      }
      if (this.regexp_eatQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      if (state.eat(
        123
        /* { */
      )) {
        state.raise("Lone quantifier brackets");
      }
    };
    pp$1.regexp_alternative = function(state) {
      while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
      }
    };
    pp$1.regexp_eatTerm = function(state) {
      if (this.regexp_eatAssertion(state)) {
        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
          if (state.switchU) {
            state.raise("Invalid quantifier");
          }
        }
        return true;
      }
      if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
        this.regexp_eatQuantifier(state);
        return true;
      }
      return false;
    };
    pp$1.regexp_eatAssertion = function(state) {
      var start = state.pos;
      state.lastAssertionIsQuantifiable = false;
      if (state.eat(
        94
        /* ^ */
      ) || state.eat(
        36
        /* $ */
      )) {
        return true;
      }
      if (state.eat(
        92
        /* \ */
      )) {
        if (state.eat(
          66
          /* B */
        ) || state.eat(
          98
          /* b */
        )) {
          return true;
        }
        state.pos = start;
      }
      if (state.eat(
        40
        /* ( */
      ) && state.eat(
        63
        /* ? */
      )) {
        var lookbehind = false;
        if (this.options.ecmaVersion >= 9) {
          lookbehind = state.eat(
            60
            /* < */
          );
        }
        if (state.eat(
          61
          /* = */
        ) || state.eat(
          33
          /* ! */
        )) {
          this.regexp_disjunction(state);
          if (!state.eat(
            41
            /* ) */
          )) {
            state.raise("Unterminated group");
          }
          state.lastAssertionIsQuantifiable = !lookbehind;
          return true;
        }
      }
      state.pos = start;
      return false;
    };
    pp$1.regexp_eatQuantifier = function(state, noError) {
      if (noError === void 0)
        noError = false;
      if (this.regexp_eatQuantifierPrefix(state, noError)) {
        state.eat(
          63
          /* ? */
        );
        return true;
      }
      return false;
    };
    pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
      return state.eat(
        42
        /* * */
      ) || state.eat(
        43
        /* + */
      ) || state.eat(
        63
        /* ? */
      ) || this.regexp_eatBracedQuantifier(state, noError);
    };
    pp$1.regexp_eatBracedQuantifier = function(state, noError) {
      var start = state.pos;
      if (state.eat(
        123
        /* { */
      )) {
        var min2 = 0, max = -1;
        if (this.regexp_eatDecimalDigits(state)) {
          min2 = state.lastIntValue;
          if (state.eat(
            44
            /* , */
          ) && this.regexp_eatDecimalDigits(state)) {
            max = state.lastIntValue;
          }
          if (state.eat(
            125
            /* } */
          )) {
            if (max !== -1 && max < min2 && !noError) {
              state.raise("numbers out of order in {} quantifier");
            }
            return true;
          }
        }
        if (state.switchU && !noError) {
          state.raise("Incomplete quantifier");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatAtom = function(state) {
      return this.regexp_eatPatternCharacters(state) || state.eat(
        46
        /* . */
      ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
    };
    pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
      var start = state.pos;
      if (state.eat(
        92
        /* \ */
      )) {
        if (this.regexp_eatAtomEscape(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatUncapturingGroup = function(state) {
      var start = state.pos;
      if (state.eat(
        40
        /* ( */
      )) {
        if (state.eat(
          63
          /* ? */
        ) && state.eat(
          58
          /* : */
        )) {
          this.regexp_disjunction(state);
          if (state.eat(
            41
            /* ) */
          )) {
            return true;
          }
          state.raise("Unterminated group");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatCapturingGroup = function(state) {
      if (state.eat(
        40
        /* ( */
      )) {
        if (this.options.ecmaVersion >= 9) {
          this.regexp_groupSpecifier(state);
        } else if (state.current() === 63) {
          state.raise("Invalid group");
        }
        this.regexp_disjunction(state);
        if (state.eat(
          41
          /* ) */
        )) {
          state.numCapturingParens += 1;
          return true;
        }
        state.raise("Unterminated group");
      }
      return false;
    };
    pp$1.regexp_eatExtendedAtom = function(state) {
      return state.eat(
        46
        /* . */
      ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
    };
    pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
      if (this.regexp_eatBracedQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      return false;
    };
    pp$1.regexp_eatSyntaxCharacter = function(state) {
      var ch = state.current();
      if (isSyntaxCharacter(ch)) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatPatternCharacters = function(state) {
      var start = state.pos;
      var ch = 0;
      while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
        state.advance();
      }
      return state.pos !== start;
    };
    pp$1.regexp_eatExtendedPatternCharacter = function(state) {
      var ch = state.current();
      if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_groupSpecifier = function(state) {
      if (state.eat(
        63
        /* ? */
      )) {
        if (this.regexp_eatGroupName(state)) {
          if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
            state.raise("Duplicate capture group name");
          }
          state.groupNames.push(state.lastStringValue);
          return;
        }
        state.raise("Invalid group");
      }
    };
    pp$1.regexp_eatGroupName = function(state) {
      state.lastStringValue = "";
      if (state.eat(
        60
        /* < */
      )) {
        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
          62
          /* > */
        )) {
          return true;
        }
        state.raise("Invalid capture group name");
      }
      return false;
    };
    pp$1.regexp_eatRegExpIdentifierName = function(state) {
      state.lastStringValue = "";
      if (this.regexp_eatRegExpIdentifierStart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
        while (this.regexp_eatRegExpIdentifierPart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
        }
        return true;
      }
      return false;
    };
    pp$1.regexp_eatRegExpIdentifierStart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch = state.current(forceU);
      state.advance(forceU);
      if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierStart(ch)) {
        state.lastIntValue = ch;
        return true;
      }
      state.pos = start;
      return false;
    };
    pp$1.regexp_eatRegExpIdentifierPart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch = state.current(forceU);
      state.advance(forceU);
      if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierPart(ch)) {
        state.lastIntValue = ch;
        return true;
      }
      state.pos = start;
      return false;
    };
    pp$1.regexp_eatAtomEscape = function(state) {
      if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
        return true;
      }
      if (state.switchU) {
        if (state.current() === 99) {
          state.raise("Invalid unicode escape");
        }
        state.raise("Invalid escape");
      }
      return false;
    };
    pp$1.regexp_eatBackReference = function(state) {
      var start = state.pos;
      if (this.regexp_eatDecimalEscape(state)) {
        var n2 = state.lastIntValue;
        if (state.switchU) {
          if (n2 > state.maxBackReference) {
            state.maxBackReference = n2;
          }
          return true;
        }
        if (n2 <= state.numCapturingParens) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatKGroupName = function(state) {
      if (state.eat(
        107
        /* k */
      )) {
        if (this.regexp_eatGroupName(state)) {
          state.backReferenceNames.push(state.lastStringValue);
          return true;
        }
        state.raise("Invalid named reference");
      }
      return false;
    };
    pp$1.regexp_eatCharacterEscape = function(state) {
      return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
    };
    pp$1.regexp_eatCControlLetter = function(state) {
      var start = state.pos;
      if (state.eat(
        99
        /* c */
      )) {
        if (this.regexp_eatControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatZero = function(state) {
      if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
        state.lastIntValue = 0;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatControlEscape = function(state) {
      var ch = state.current();
      if (ch === 116) {
        state.lastIntValue = 9;
        state.advance();
        return true;
      }
      if (ch === 110) {
        state.lastIntValue = 10;
        state.advance();
        return true;
      }
      if (ch === 118) {
        state.lastIntValue = 11;
        state.advance();
        return true;
      }
      if (ch === 102) {
        state.lastIntValue = 12;
        state.advance();
        return true;
      }
      if (ch === 114) {
        state.lastIntValue = 13;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatControlLetter = function(state) {
      var ch = state.current();
      if (isControlLetter(ch)) {
        state.lastIntValue = ch % 32;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
      if (forceU === void 0)
        forceU = false;
      var start = state.pos;
      var switchU = forceU || state.switchU;
      if (state.eat(
        117
        /* u */
      )) {
        if (this.regexp_eatFixedHexDigits(state, 4)) {
          var lead = state.lastIntValue;
          if (switchU && lead >= 55296 && lead <= 56319) {
            var leadSurrogateEnd = state.pos;
            if (state.eat(
              92
              /* \ */
            ) && state.eat(
              117
              /* u */
            ) && this.regexp_eatFixedHexDigits(state, 4)) {
              var trail = state.lastIntValue;
              if (trail >= 56320 && trail <= 57343) {
                state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                return true;
              }
            }
            state.pos = leadSurrogateEnd;
            state.lastIntValue = lead;
          }
          return true;
        }
        if (switchU && state.eat(
          123
          /* { */
        ) && this.regexp_eatHexDigits(state) && state.eat(
          125
          /* } */
        ) && isValidUnicode(state.lastIntValue)) {
          return true;
        }
        if (switchU) {
          state.raise("Invalid unicode escape");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatIdentityEscape = function(state) {
      if (state.switchU) {
        if (this.regexp_eatSyntaxCharacter(state)) {
          return true;
        }
        if (state.eat(
          47
          /* / */
        )) {
          state.lastIntValue = 47;
          return true;
        }
        return false;
      }
      var ch = state.current();
      if (ch !== 99 && (!state.switchN || ch !== 107)) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatDecimalEscape = function(state) {
      state.lastIntValue = 0;
      var ch = state.current();
      if (ch >= 49 && ch <= 57) {
        do {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        } while ((ch = state.current()) >= 48 && ch <= 57);
        return true;
      }
      return false;
    };
    pp$1.regexp_eatCharacterClassEscape = function(state) {
      var ch = state.current();
      if (isCharacterClassEscape(ch)) {
        state.lastIntValue = -1;
        state.advance();
        return true;
      }
      if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
        state.lastIntValue = -1;
        state.advance();
        if (state.eat(
          123
          /* { */
        ) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(
          125
          /* } */
        )) {
          return true;
        }
        state.raise("Invalid property name");
      }
      return false;
    };
    pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
      var start = state.pos;
      if (this.regexp_eatUnicodePropertyName(state) && state.eat(
        61
        /* = */
      )) {
        var name2 = state.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(state)) {
          var value2 = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameAndValue(state, name2, value2);
          return true;
        }
      }
      state.pos = start;
      if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
        var nameOrValue = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        return true;
      }
      return false;
    };
    pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value2) {
      if (!hasOwn(state.unicodeProperties.nonBinary, name2)) {
        state.raise("Invalid property name");
      }
      if (!state.unicodeProperties.nonBinary[name2].test(value2)) {
        state.raise("Invalid property value");
      }
    };
    pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
      if (!state.unicodeProperties.binary.test(nameOrValue)) {
        state.raise("Invalid property name");
      }
    };
    pp$1.regexp_eatUnicodePropertyName = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyNameCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString(ch);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    pp$1.regexp_eatUnicodePropertyValue = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyValueCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString(ch);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
      return this.regexp_eatUnicodePropertyValue(state);
    };
    pp$1.regexp_eatCharacterClass = function(state) {
      if (state.eat(
        91
        /* [ */
      )) {
        state.eat(
          94
          /* ^ */
        );
        this.regexp_classRanges(state);
        if (state.eat(
          93
          /* ] */
        )) {
          return true;
        }
        state.raise("Unterminated character class");
      }
      return false;
    };
    pp$1.regexp_classRanges = function(state) {
      while (this.regexp_eatClassAtom(state)) {
        var left = state.lastIntValue;
        if (state.eat(
          45
          /* - */
        ) && this.regexp_eatClassAtom(state)) {
          var right = state.lastIntValue;
          if (state.switchU && (left === -1 || right === -1)) {
            state.raise("Invalid character class");
          }
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
        }
      }
    };
    pp$1.regexp_eatClassAtom = function(state) {
      var start = state.pos;
      if (state.eat(
        92
        /* \ */
      )) {
        if (this.regexp_eatClassEscape(state)) {
          return true;
        }
        if (state.switchU) {
          var ch$1 = state.current();
          if (ch$1 === 99 || isOctalDigit(ch$1)) {
            state.raise("Invalid class escape");
          }
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      var ch = state.current();
      if (ch !== 93) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatClassEscape = function(state) {
      var start = state.pos;
      if (state.eat(
        98
        /* b */
      )) {
        state.lastIntValue = 8;
        return true;
      }
      if (state.switchU && state.eat(
        45
        /* - */
      )) {
        state.lastIntValue = 45;
        return true;
      }
      if (!state.switchU && state.eat(
        99
        /* c */
      )) {
        if (this.regexp_eatClassControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
    };
    pp$1.regexp_eatClassControlLetter = function(state) {
      var ch = state.current();
      if (isDecimalDigit(ch) || ch === 95) {
        state.lastIntValue = ch % 32;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatHexEscapeSequence = function(state) {
      var start = state.pos;
      if (state.eat(
        120
        /* x */
      )) {
        if (this.regexp_eatFixedHexDigits(state, 2)) {
          return true;
        }
        if (state.switchU) {
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatDecimalDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isDecimalDigit(ch = state.current())) {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
        state.advance();
      }
      return state.pos !== start;
    };
    pp$1.regexp_eatHexDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isHexDigit(ch = state.current())) {
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return state.pos !== start;
    };
    pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
      if (this.regexp_eatOctalDigit(state)) {
        var n1 = state.lastIntValue;
        if (this.regexp_eatOctalDigit(state)) {
          var n2 = state.lastIntValue;
          if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
            state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
          } else {
            state.lastIntValue = n1 * 8 + n2;
          }
        } else {
          state.lastIntValue = n1;
        }
        return true;
      }
      return false;
    };
    pp$1.regexp_eatOctalDigit = function(state) {
      var ch = state.current();
      if (isOctalDigit(ch)) {
        state.lastIntValue = ch - 48;
        state.advance();
        return true;
      }
      state.lastIntValue = 0;
      return false;
    };
    pp$1.regexp_eatFixedHexDigits = function(state, length) {
      var start = state.pos;
      state.lastIntValue = 0;
      for (var i = 0; i < length; ++i) {
        var ch = state.current();
        if (!isHexDigit(ch)) {
          state.pos = start;
          return false;
        }
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return true;
    };
    Token = function Token2(p) {
      this.type = p.type;
      this.value = p.value;
      this.start = p.start;
      this.end = p.end;
      if (p.options.locations) {
        this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
      }
      if (p.options.ranges) {
        this.range = [p.start, p.end];
      }
    };
    pp = Parser.prototype;
    pp.next = function(ignoreEscapeSequenceInKeyword) {
      if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
      }
      if (this.options.onToken) {
        this.options.onToken(new Token(this));
      }
      this.lastTokEnd = this.end;
      this.lastTokStart = this.start;
      this.lastTokEndLoc = this.endLoc;
      this.lastTokStartLoc = this.startLoc;
      this.nextToken();
    };
    pp.getToken = function() {
      this.next();
      return new Token(this);
    };
    if (typeof Symbol !== "undefined") {
      pp[Symbol.iterator] = function() {
        var this$1$1 = this;
        return {
          next: function() {
            var token = this$1$1.getToken();
            return {
              done: token.type === types$1.eof,
              value: token
            };
          }
        };
      };
    }
    pp.nextToken = function() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) {
        this.skipSpace();
      }
      this.start = this.pos;
      if (this.options.locations) {
        this.startLoc = this.curPosition();
      }
      if (this.pos >= this.input.length) {
        return this.finishToken(types$1.eof);
      }
      if (curContext.override) {
        return curContext.override(this);
      } else {
        this.readToken(this.fullCharCodeAtPos());
      }
    };
    pp.readToken = function(code) {
      if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
        return this.readWord();
      }
      return this.getTokenFromCode(code);
    };
    pp.fullCharCodeAtPos = function() {
      var code = this.input.charCodeAt(this.pos);
      if (code <= 55295 || code >= 56320) {
        return code;
      }
      var next = this.input.charCodeAt(this.pos + 1);
      return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
    };
    pp.skipBlockComment = function() {
      var startLoc = this.options.onComment && this.curPosition();
      var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
      if (end === -1) {
        this.raise(this.pos - 2, "Unterminated comment");
      }
      this.pos = end + 2;
      if (this.options.locations) {
        for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
          ++this.curLine;
          pos = this.lineStart = nextBreak;
        }
      }
      if (this.options.onComment) {
        this.options.onComment(
          true,
          this.input.slice(start + 2, end),
          start,
          this.pos,
          startLoc,
          this.curPosition()
        );
      }
    };
    pp.skipLineComment = function(startSkip) {
      var start = this.pos;
      var startLoc = this.options.onComment && this.curPosition();
      var ch = this.input.charCodeAt(this.pos += startSkip);
      while (this.pos < this.input.length && !isNewLine(ch)) {
        ch = this.input.charCodeAt(++this.pos);
      }
      if (this.options.onComment) {
        this.options.onComment(
          false,
          this.input.slice(start + startSkip, this.pos),
          start,
          this.pos,
          startLoc,
          this.curPosition()
        );
      }
    };
    pp.skipSpace = function() {
      loop:
        while (this.pos < this.input.length) {
          var ch = this.input.charCodeAt(this.pos);
          switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
          }
        }
    };
    pp.finishToken = function(type, val) {
      this.end = this.pos;
      if (this.options.locations) {
        this.endLoc = this.curPosition();
      }
      var prevType = this.type;
      this.type = type;
      this.value = val;
      this.updateContext(prevType);
    };
    pp.readToken_dot = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next >= 48 && next <= 57) {
        return this.readNumber(true);
      }
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
        this.pos += 3;
        return this.finishToken(types$1.ellipsis);
      } else {
        ++this.pos;
        return this.finishToken(types$1.dot);
      }
    };
    pp.readToken_slash = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed) {
        ++this.pos;
        return this.readRegexp();
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(types$1.slash, 1);
    };
    pp.readToken_mult_modulo_exp = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      var tokentype = code === 42 ? types$1.star : types$1.modulo;
      if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
        ++size;
        tokentype = types$1.starstar;
        next = this.input.charCodeAt(this.pos + 2);
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, size + 1);
      }
      return this.finishOp(tokentype, size);
    };
    pp.readToken_pipe_amp = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (this.options.ecmaVersion >= 12) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 === 61) {
            return this.finishOp(types$1.assign, 3);
          }
        }
        return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
    };
    pp.readToken_caret = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(types$1.bitwiseXOR, 1);
    };
    pp.readToken_plus_min = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken();
        }
        return this.finishOp(types$1.incDec, 2);
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(types$1.plusMin, 1);
    };
    pp.readToken_lt_gt = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) {
          return this.finishOp(types$1.assign, size + 1);
        }
        return this.finishOp(types$1.bitShift, size);
      }
      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken();
      }
      if (next === 61) {
        size = 2;
      }
      return this.finishOp(types$1.relational, size);
    };
    pp.readToken_eq_excl = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) {
        return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
      }
      if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
        this.pos += 2;
        return this.finishToken(types$1.arrow);
      }
      return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
    };
    pp.readToken_question = function() {
      var ecmaVersion = this.options.ecmaVersion;
      if (ecmaVersion >= 11) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 46) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 < 48 || next2 > 57) {
            return this.finishOp(types$1.questionDot, 2);
          }
        }
        if (next === 63) {
          if (ecmaVersion >= 12) {
            var next2$1 = this.input.charCodeAt(this.pos + 2);
            if (next2$1 === 61) {
              return this.finishOp(types$1.assign, 3);
            }
          }
          return this.finishOp(types$1.coalesce, 2);
        }
      }
      return this.finishOp(types$1.question, 1);
    };
    pp.readToken_numberSign = function() {
      var ecmaVersion = this.options.ecmaVersion;
      var code = 35;
      if (ecmaVersion >= 13) {
        ++this.pos;
        code = this.fullCharCodeAtPos();
        if (isIdentifierStart(code, true) || code === 92) {
          return this.finishToken(types$1.privateId, this.readWord1());
        }
      }
      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    pp.getTokenFromCode = function(code) {
      switch (code) {
        case 46:
          return this.readToken_dot();
        case 40:
          ++this.pos;
          return this.finishToken(types$1.parenL);
        case 41:
          ++this.pos;
          return this.finishToken(types$1.parenR);
        case 59:
          ++this.pos;
          return this.finishToken(types$1.semi);
        case 44:
          ++this.pos;
          return this.finishToken(types$1.comma);
        case 91:
          ++this.pos;
          return this.finishToken(types$1.bracketL);
        case 93:
          ++this.pos;
          return this.finishToken(types$1.bracketR);
        case 123:
          ++this.pos;
          return this.finishToken(types$1.braceL);
        case 125:
          ++this.pos;
          return this.finishToken(types$1.braceR);
        case 58:
          ++this.pos;
          return this.finishToken(types$1.colon);
        case 96:
          if (this.options.ecmaVersion < 6) {
            break;
          }
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        case 48:
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 120 || next === 88) {
            return this.readRadixNumber(16);
          }
          if (this.options.ecmaVersion >= 6) {
            if (next === 111 || next === 79) {
              return this.readRadixNumber(8);
            }
            if (next === 98 || next === 66) {
              return this.readRadixNumber(2);
            }
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(false);
        case 34:
        case 39:
          return this.readString(code);
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(code);
        case 124:
        case 38:
          return this.readToken_pipe_amp(code);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(code);
        case 60:
        case 62:
          return this.readToken_lt_gt(code);
        case 61:
        case 33:
          return this.readToken_eq_excl(code);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(types$1.prefix, 1);
        case 35:
          return this.readToken_numberSign();
      }
      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    pp.finishOp = function(type, size) {
      var str = this.input.slice(this.pos, this.pos + size);
      this.pos += size;
      return this.finishToken(type, str);
    };
    pp.readRegexp = function() {
      var escaped2, inClass, start = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(start, "Unterminated regular expression");
        }
        var ch = this.input.charAt(this.pos);
        if (lineBreak.test(ch)) {
          this.raise(start, "Unterminated regular expression");
        }
        if (!escaped2) {
          if (ch === "[") {
            inClass = true;
          } else if (ch === "]" && inClass) {
            inClass = false;
          } else if (ch === "/" && !inClass) {
            break;
          }
          escaped2 = ch === "\\";
        } else {
          escaped2 = false;
        }
        ++this.pos;
      }
      var pattern2 = this.input.slice(start, this.pos);
      ++this.pos;
      var flagsStart = this.pos;
      var flags = this.readWord1();
      if (this.containsEsc) {
        this.unexpected(flagsStart);
      }
      var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
      state.reset(start, pattern2, flags);
      this.validateRegExpFlags(state);
      this.validateRegExpPattern(state);
      var value2 = null;
      try {
        value2 = new RegExp(pattern2, flags);
      } catch (e) {
      }
      return this.finishToken(types$1.regexp, { pattern: pattern2, flags, value: value2 });
    };
    pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
      var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
      var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
      var start = this.pos, total = 0, lastCode = 0;
      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
        var code = this.input.charCodeAt(this.pos), val = void 0;
        if (allowSeparators && code === 95) {
          if (isLegacyOctalNumericLiteral) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
          }
          if (lastCode === 95) {
            this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
          }
          if (i === 0) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
          }
          lastCode = code;
          continue;
        }
        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (code >= 48 && code <= 57) {
          val = code - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          break;
        }
        lastCode = code;
        total = total * radix + val;
      }
      if (allowSeparators && lastCode === 95) {
        this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
      }
      if (this.pos === start || len != null && this.pos - start !== len) {
        return null;
      }
      return total;
    };
    pp.readRadixNumber = function(radix) {
      var start = this.pos;
      this.pos += 2;
      var val = this.readInt(radix);
      if (val == null) {
        this.raise(this.start + 2, "Expected number in radix " + radix);
      }
      if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
        val = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
      } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      return this.finishToken(types$1.num, val);
    };
    pp.readNumber = function(startsWithDot) {
      var start = this.pos;
      if (!startsWithDot && this.readInt(10, void 0, true) === null) {
        this.raise(start, "Invalid number");
      }
      var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (octal && this.strict) {
        this.raise(start, "Invalid number");
      }
      var next = this.input.charCodeAt(this.pos);
      if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
        var val$1 = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$1.num, val$1);
      }
      if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
        octal = false;
      }
      if (next === 46 && !octal) {
        ++this.pos;
        this.readInt(10);
        next = this.input.charCodeAt(this.pos);
      }
      if ((next === 69 || next === 101) && !octal) {
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) {
          ++this.pos;
        }
        if (this.readInt(10) === null) {
          this.raise(start, "Invalid number");
        }
      }
      if (isIdentifierStart(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      var val = stringToNumber(this.input.slice(start, this.pos), octal);
      return this.finishToken(types$1.num, val);
    };
    pp.readCodePoint = function() {
      var ch = this.input.charCodeAt(this.pos), code;
      if (ch === 123) {
        if (this.options.ecmaVersion < 6) {
          this.unexpected();
        }
        var codePos = ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 1114111) {
          this.invalidStringToken(codePos, "Code point out of bounds");
        }
      } else {
        code = this.readHexChar(4);
      }
      return code;
    };
    pp.readString = function(quote) {
      var out = "", chunkStart = ++this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated string constant");
        }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === quote) {
          break;
        }
        if (ch === 92) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.pos;
        } else if (ch === 8232 || ch === 8233) {
          if (this.options.ecmaVersion < 10) {
            this.raise(this.start, "Unterminated string constant");
          }
          ++this.pos;
          if (this.options.locations) {
            this.curLine++;
            this.lineStart = this.pos;
          }
        } else {
          if (isNewLine(ch)) {
            this.raise(this.start, "Unterminated string constant");
          }
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(types$1.string, out);
    };
    INVALID_TEMPLATE_ESCAPE_ERROR = {};
    pp.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (err) {
        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
          this.readInvalidTemplateToken();
        } else {
          throw err;
        }
      }
      this.inTemplateElement = false;
    };
    pp.invalidStringToken = function(position, message) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
        throw INVALID_TEMPLATE_ESCAPE_ERROR;
      } else {
        this.raise(position, message);
      }
    };
    pp.readTmplToken = function() {
      var out = "", chunkStart = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated template");
        }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
          if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
            if (ch === 36) {
              this.pos += 2;
              return this.finishToken(types$1.dollarBraceL);
            } else {
              ++this.pos;
              return this.finishToken(types$1.backQuote);
            }
          }
          out += this.input.slice(chunkStart, this.pos);
          return this.finishToken(types$1.template, out);
        }
        if (ch === 92) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(true);
          chunkStart = this.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          ++this.pos;
          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) {
                ++this.pos;
              }
            case 10:
              out += "\n";
              break;
            default:
              out += String.fromCharCode(ch);
              break;
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    };
    pp.readInvalidTemplateToken = function() {
      for (; this.pos < this.input.length; this.pos++) {
        switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break;
          case "$":
            if (this.input[this.pos + 1] !== "{") {
              break;
            }
          case "`":
            return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
        }
      }
      this.raise(this.start, "Unterminated template");
    };
    pp.readEscapedChar = function(inTemplate) {
      var ch = this.input.charCodeAt(++this.pos);
      ++this.pos;
      switch (ch) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        case 117:
          return codePointToString(this.readCodePoint());
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          if (this.options.locations) {
            this.lineStart = this.pos;
            ++this.curLine;
          }
          return "";
        case 56:
        case 57:
          if (this.strict) {
            this.invalidStringToken(
              this.pos - 1,
              "Invalid escape sequence"
            );
          }
          if (inTemplate) {
            var codePos = this.pos - 1;
            this.invalidStringToken(
              codePos,
              "Invalid escape sequence in template string"
            );
          }
        default:
          if (ch >= 48 && ch <= 55) {
            var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            this.pos += octalStr.length - 1;
            ch = this.input.charCodeAt(this.pos);
            if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
              this.invalidStringToken(
                this.pos - 1 - octalStr.length,
                inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
              );
            }
            return String.fromCharCode(octal);
          }
          if (isNewLine(ch)) {
            return "";
          }
          return String.fromCharCode(ch);
      }
    };
    pp.readHexChar = function(len) {
      var codePos = this.pos;
      var n2 = this.readInt(16, len);
      if (n2 === null) {
        this.invalidStringToken(codePos, "Bad character escape sequence");
      }
      return n2;
    };
    pp.readWord1 = function() {
      this.containsEsc = false;
      var word = "", first2 = true, chunkStart = this.pos;
      var astral = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var ch = this.fullCharCodeAtPos();
        if (isIdentifierChar(ch, astral)) {
          this.pos += ch <= 65535 ? 1 : 2;
        } else if (ch === 92) {
          this.containsEsc = true;
          word += this.input.slice(chunkStart, this.pos);
          var escStart = this.pos;
          if (this.input.charCodeAt(++this.pos) !== 117) {
            this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
          }
          ++this.pos;
          var esc = this.readCodePoint();
          if (!(first2 ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
            this.invalidStringToken(escStart, "Invalid Unicode escape");
          }
          word += codePointToString(esc);
          chunkStart = this.pos;
        } else {
          break;
        }
        first2 = false;
      }
      return word + this.input.slice(chunkStart, this.pos);
    };
    pp.readWord = function() {
      var word = this.readWord1();
      var type = types$1.name;
      if (this.keywords.test(word)) {
        type = keywords[word];
      }
      return this.finishToken(type, word);
    };
    version2 = "8.8.2";
    Parser.acorn = {
      Parser,
      version: version2,
      defaultOptions,
      Position,
      SourceLocation,
      getLineInfo,
      Node,
      TokenType,
      tokTypes: types$1,
      keywordTypes: keywords,
      TokContext,
      tokContexts: types,
      isIdentifierChar,
      isIdentifierStart,
      Token,
      isNewLine,
      lineBreak,
      lineBreakG,
      nonASCIIwhitespace
    };
    inputHookNames = {
      buildEnd: 1,
      buildStart: 1,
      closeBundle: 1,
      closeWatcher: 1,
      load: 1,
      moduleParsed: 1,
      options: 1,
      resolveDynamicImport: 1,
      resolveId: 1,
      shouldTransformCachedModule: 1,
      transform: 1,
      watchChange: 1
    };
    inputHooks = Object.keys(inputHookNames);
    beforeExitEvent = "beforeExit";
    beforeExitEmitter = new import_node_events.EventEmitter();
    beforeExitEmitter.setMaxListeners(0);
    import_node_process.default.on(beforeExitEvent, () => beforeExitEmitter.emit(beforeExitEvent));
    leftCurlyBrace = "{".charCodeAt(0);
    space = " ".charCodeAt(0);
    (function(SortingFileType2) {
      SortingFileType2[SortingFileType2["ENTRY_CHUNK"] = 0] = "ENTRY_CHUNK";
      SortingFileType2[SortingFileType2["SECONDARY_CHUNK"] = 1] = "SECONDARY_CHUNK";
      SortingFileType2[SortingFileType2["ASSET"] = 2] = "ASSET";
    })(SortingFileType || (SortingFileType = {}));
    ({
      env = {},
      argv = [],
      platform = ""
    } = typeof process === "undefined" ? {} : process);
    isDisabled = "NO_COLOR" in env || argv.includes("--no-color");
    isForced = "FORCE_COLOR" in env || argv.includes("--color");
    isWindows = platform === "win32";
    isDumbTerminal = env.TERM === "dumb";
    isCompatibleTerminal = tty && tty.isatty && tty.isatty(1) && env.TERM && !isDumbTerminal;
    isCI = "CI" in env && ("GITHUB_ACTIONS" in env || "GITLAB_CI" in env || "CIRCLECI" in env);
    isColorSupported = !isDisabled && (isForced || isWindows && !isDumbTerminal || isCompatibleTerminal || isCI);
    replaceClose = (index, string2, close2, replace, head = string2.substring(0, index) + replace, tail = string2.substring(index + close2.length), next = tail.indexOf(close2)) => head + (next < 0 ? tail : replaceClose(next, tail, close2, replace));
    clearBleed = (index, string2, open2, close2, replace) => index < 0 ? open2 + string2 + close2 : open2 + replaceClose(index, string2, close2, replace) + close2;
    filterEmpty = (open2, close2, replace = open2, at3 = open2.length + 1) => (string2) => string2 || !(string2 === "" || string2 === void 0) ? clearBleed(
      ("" + string2).indexOf(close2, at3),
      string2,
      open2,
      close2,
      replace
    ) : "";
    init2 = (open2, close2, replace) => filterEmpty(`\x1B[${open2}m`, `\x1B[${close2}m`, replace);
    colors = {
      reset: init2(0, 0),
      bold: init2(1, 22, "\x1B[22m\x1B[1m"),
      dim: init2(2, 22, "\x1B[22m\x1B[2m"),
      italic: init2(3, 23),
      underline: init2(4, 24),
      inverse: init2(7, 27),
      hidden: init2(8, 28),
      strikethrough: init2(9, 29),
      black: init2(30, 39),
      red: init2(31, 39),
      green: init2(32, 39),
      yellow: init2(33, 39),
      blue: init2(34, 39),
      magenta: init2(35, 39),
      cyan: init2(36, 39),
      white: init2(37, 39),
      gray: init2(90, 39),
      bgBlack: init2(40, 49),
      bgRed: init2(41, 49),
      bgGreen: init2(42, 49),
      bgYellow: init2(43, 49),
      bgBlue: init2(44, 49),
      bgMagenta: init2(45, 49),
      bgCyan: init2(46, 49),
      bgWhite: init2(47, 49),
      blackBright: init2(90, 39),
      redBright: init2(91, 39),
      greenBright: init2(92, 39),
      yellowBright: init2(93, 39),
      blueBright: init2(94, 39),
      magentaBright: init2(95, 39),
      cyanBright: init2(96, 39),
      whiteBright: init2(97, 39),
      bgBlackBright: init2(100, 49),
      bgRedBright: init2(101, 49),
      bgGreenBright: init2(102, 49),
      bgYellowBright: init2(103, 49),
      bgBlueBright: init2(104, 49),
      bgMagentaBright: init2(105, 49),
      bgCyanBright: init2(106, 49),
      bgWhiteBright: init2(107, 49)
    };
    createColors = ({ useColor = isColorSupported } = {}) => useColor ? colors : Object.keys(colors).reduce(
      (colors2, key) => ({ ...colors2, [key]: String }),
      {}
    );
    createColors();
    ({ bold, cyan, dim, gray, green, red, underline, yellow } = createColors({
      useColor: import_node_process.env.FORCE_COLOR !== "0" && !import_node_process.env.NO_COLOR
    }));
  }
});

// node_modules/rollup/dist/es/rollup.js
var import_node_path3, import_node_process2, import_node_perf_hooks2, import_node_crypto2, import_promises2, import_node_events2;
var init_rollup = __esm({
  "node_modules/rollup/dist/es/rollup.js"() {
    init_node_entry();
    import_node_path3 = require("path");
    import_node_process2 = require("process");
    import_node_perf_hooks2 = require("perf_hooks");
    import_node_crypto2 = require("crypto");
    import_promises2 = require("fs/promises");
    import_node_events2 = require("events");
  }
});

// node_modules/vite/dist/node/chunks/dep-79892de8.js
function getDefaultExportFromCjs2(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f = n2.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        var args = [null];
        args.push.apply(args, arguments);
        var Ctor = Function.bind.apply(f, args);
        return new Ctor();
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a;
}
function rethrow() {
  var callback;
  if (DEBUG$1) {
    var backtrace = new Error();
    callback = debugCallback;
  } else
    callback = missingCallback;
  return callback;
  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }
  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;
      else if (!process.noDeprecation) {
        var msg = "fs: missing callback " + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}
function maybeCallback(cb) {
  return typeof cb === "function" ? cb : rethrow();
}
function newError(er) {
  return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
}
function realpath$2(p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb);
  }
  if (typeof cache === "function") {
    cb = cache;
    cache = null;
  }
  origRealpath(p, cache, function(er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb);
    } else {
      cb(er, result);
    }
  });
}
function realpathSync2(p, cache) {
  if (ok) {
    return origRealpathSync(p, cache);
  }
  try {
    return origRealpathSync(p, cache);
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache);
    } else {
      throw er;
    }
  }
}
function monkeypatch() {
  fs$j.realpath = realpath$2;
  fs$j.realpathSync = realpathSync2;
}
function unmonkeypatch() {
  fs$j.realpath = origRealpath;
  fs$j.realpathSync = origRealpathSync;
}
function balanced$1(a, b, str) {
  if (a instanceof RegExp)
    a = maybeMatch(a, str);
  if (b instanceof RegExp)
    b = maybeMatch(b, str);
  var r = range$1(a, b, str);
  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}
function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}
function range$1(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;
  if (ai >= 0 && bi > 0) {
    if (a === b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;
    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [begs.pop(), bi];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }
        bi = str.indexOf(b, i + 1);
      }
      i = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length) {
      result = [left, right];
    }
  }
  return result;
}
function numeric(str) {
  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
  return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
}
function unescapeBraces(str) {
  return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
}
function parseCommaParts(str) {
  if (!str)
    return [""];
  var parts = [];
  var m = balanced("{", "}", str);
  if (!m)
    return str.split(",");
  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expandTop(str) {
  if (!str)
    return [];
  if (str.substr(0, 2) === "{}") {
    str = "\\{\\}" + str.substr(2);
  }
  return expand$4(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
  return "{" + str + "}";
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}
function expand$4(str, isTop) {
  var expansions = [];
  var m = balanced("{", "}", str);
  if (!m)
    return [str];
  var pre = m.pre;
  var post = m.post.length ? expand$4(m.post, false) : [""];
  if (/\$$/.test(m.pre)) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + "{" + m.body + "}" + post[k];
      expansions.push(expansion);
    }
  } else {
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand$4(str);
      }
      return [str];
    }
    var n2;
    if (isSequence) {
      n2 = m.body.split(/\.\./);
    } else {
      n2 = parseCommaParts(m.body);
      if (n2.length === 1) {
        n2 = expand$4(n2[0], false).map(embrace);
        if (n2.length === 1) {
          return post.map(function(p) {
            return m.pre + n2[0] + p;
          });
        }
      }
    }
    var N;
    if (isSequence) {
      var x = numeric(n2[0]);
      var y = numeric(n2[1]);
      var width = Math.max(n2[0].length, n2[1].length);
      var incr = n2.length == 3 ? Math.abs(numeric(n2[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad2 = n2.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad2) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = [];
      for (var j = 0; j < n2.length; j++) {
        N.push.apply(N, expand$4(n2[j], false));
      }
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
  }
  return expansions;
}
function requireInherits_browser() {
  if (hasRequiredInherits_browser)
    return inherits_browserExports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browserExports;
}
function ownProp(obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field);
}
function alphasort(a, b) {
  return a.localeCompare(b, "en");
}
function setupIgnores(self2, options2) {
  self2.ignore = options2.ignore || [];
  if (!Array.isArray(self2.ignore))
    self2.ignore = [self2.ignore];
  if (self2.ignore.length) {
    self2.ignore = self2.ignore.map(ignoreMap);
  }
}
function ignoreMap(pattern2) {
  var gmatcher = null;
  if (pattern2.slice(-3) === "/**") {
    var gpattern = pattern2.replace(/(\/\*\*)+$/, "");
    gmatcher = new Minimatch2(gpattern, { dot: true });
  }
  return {
    matcher: new Minimatch2(pattern2, { dot: true }),
    gmatcher
  };
}
function setopts(self2, pattern2, options2) {
  if (!options2)
    options2 = {};
  if (options2.matchBase && -1 === pattern2.indexOf("/")) {
    if (options2.noglobstar) {
      throw new Error("base matching requires globstar");
    }
    pattern2 = "**/" + pattern2;
  }
  self2.silent = !!options2.silent;
  self2.pattern = pattern2;
  self2.strict = options2.strict !== false;
  self2.realpath = !!options2.realpath;
  self2.realpathCache = options2.realpathCache || /* @__PURE__ */ Object.create(null);
  self2.follow = !!options2.follow;
  self2.dot = !!options2.dot;
  self2.mark = !!options2.mark;
  self2.nodir = !!options2.nodir;
  if (self2.nodir)
    self2.mark = true;
  self2.sync = !!options2.sync;
  self2.nounique = !!options2.nounique;
  self2.nonull = !!options2.nonull;
  self2.nosort = !!options2.nosort;
  self2.nocase = !!options2.nocase;
  self2.stat = !!options2.stat;
  self2.noprocess = !!options2.noprocess;
  self2.absolute = !!options2.absolute;
  self2.fs = options2.fs || fs$i;
  self2.maxLength = options2.maxLength || Infinity;
  self2.cache = options2.cache || /* @__PURE__ */ Object.create(null);
  self2.statCache = options2.statCache || /* @__PURE__ */ Object.create(null);
  self2.symlinks = options2.symlinks || /* @__PURE__ */ Object.create(null);
  setupIgnores(self2, options2);
  self2.changedCwd = false;
  var cwd = process.cwd();
  if (!ownProp(options2, "cwd"))
    self2.cwd = path$i.resolve(cwd);
  else {
    self2.cwd = path$i.resolve(options2.cwd);
    self2.changedCwd = self2.cwd !== cwd;
  }
  self2.root = options2.root || path$i.resolve(self2.cwd, "/");
  self2.root = path$i.resolve(self2.root);
  self2.cwdAbs = isAbsolute2(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
  self2.nomount = !!options2.nomount;
  if (process.platform === "win32") {
    self2.root = self2.root.replace(/\\/g, "/");
    self2.cwd = self2.cwd.replace(/\\/g, "/");
    self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
  }
  options2.nonegate = true;
  options2.nocomment = true;
  options2.allowWindowsEscape = true;
  self2.minimatch = new Minimatch2(pattern2, options2);
  self2.options = self2.minimatch.options;
}
function finish(self2) {
  var nou = self2.nounique;
  var all = nou ? [] : /* @__PURE__ */ Object.create(null);
  for (var i = 0, l = self2.matches.length; i < l; i++) {
    var matches = self2.matches[i];
    if (!matches || Object.keys(matches).length === 0) {
      if (self2.nonull) {
        var literal3 = self2.minimatch.globSet[i];
        if (nou)
          all.push(literal3);
        else
          all[literal3] = true;
      }
    } else {
      var m = Object.keys(matches);
      if (nou)
        all.push.apply(all, m);
      else
        m.forEach(function(m2) {
          all[m2] = true;
        });
    }
  }
  if (!nou)
    all = Object.keys(all);
  if (!self2.nosort)
    all = all.sort(alphasort);
  if (self2.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self2._mark(all[i]);
    }
    if (self2.nodir) {
      all = all.filter(function(e) {
        var notDir = !/\/$/.test(e);
        var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
        if (notDir && c)
          notDir = c !== "DIR" && !Array.isArray(c);
        return notDir;
      });
    }
  }
  if (self2.ignore.length)
    all = all.filter(function(m2) {
      return !isIgnored(self2, m2);
    });
  self2.found = all;
}
function mark(self2, p) {
  var abs = makeAbs(self2, p);
  var c = self2.cache[abs];
  var m = p;
  if (c) {
    var isDir = c === "DIR" || Array.isArray(c);
    var slash2 = p.slice(-1) === "/";
    if (isDir && !slash2)
      m += "/";
    else if (!isDir && slash2)
      m = m.slice(0, -1);
    if (m !== p) {
      var mabs = makeAbs(self2, m);
      self2.statCache[mabs] = self2.statCache[abs];
      self2.cache[mabs] = self2.cache[abs];
    }
  }
  return m;
}
function makeAbs(self2, f) {
  var abs = f;
  if (f.charAt(0) === "/") {
    abs = path$i.join(self2.root, f);
  } else if (isAbsolute2(f) || f === "") {
    abs = f;
  } else if (self2.changedCwd) {
    abs = path$i.resolve(self2.cwd, f);
  } else {
    abs = path$i.resolve(f);
  }
  if (process.platform === "win32")
    abs = abs.replace(/\\/g, "/");
  return abs;
}
function isIgnored(self2, path4) {
  if (!self2.ignore.length)
    return false;
  return self2.ignore.some(function(item) {
    return item.matcher.match(path4) || !!(item.gmatcher && item.gmatcher.match(path4));
  });
}
function childrenIgnored(self2, path4) {
  if (!self2.ignore.length)
    return false;
  return self2.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path4));
  });
}
function requireSync() {
  if (hasRequiredSync)
    return sync$9;
  hasRequiredSync = 1;
  sync$9 = globSync;
  globSync.GlobSync = GlobSync;
  var rp = fs_realpath;
  var minimatch2 = minimatch_1;
  requireGlob().Glob;
  var path4 = import_path2.default;
  var assert2 = import_assert.default;
  var isAbsolute3 = import_path2.default.isAbsolute;
  var common2 = common$c;
  var setopts2 = common2.setopts;
  var ownProp2 = common2.ownProp;
  var childrenIgnored2 = common2.childrenIgnored;
  var isIgnored2 = common2.isIgnored;
  function globSync(pattern2, options2) {
    if (typeof options2 === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    return new GlobSync(pattern2, options2).found;
  }
  function GlobSync(pattern2, options2) {
    if (!pattern2)
      throw new Error("must provide pattern");
    if (typeof options2 === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern2, options2);
    setopts2(this, pattern2, options2);
    if (this.noprocess)
      return this;
    var n2 = this.minimatch.set.length;
    this.matches = new Array(n2);
    for (var i = 0; i < n2; i++) {
      this._process(this.minimatch.set[i], i, false);
    }
    this._finish();
  }
  GlobSync.prototype._finish = function() {
    assert2.ok(this instanceof GlobSync);
    if (this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index) {
        var set2 = self2.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var p in matchset) {
          try {
            p = self2._makeAbs(p);
            var real = rp.realpathSync(p, self2.realpathCache);
            set2[real] = true;
          } catch (er) {
            if (er.syscall === "stat")
              set2[self2._makeAbs(p)] = true;
            else
              throw er;
          }
        }
      });
    }
    common2.finish(this);
  };
  GlobSync.prototype._process = function(pattern2, index, inGlobStar) {
    assert2.ok(this instanceof GlobSync);
    var n2 = 0;
    while (typeof pattern2[n2] === "string") {
      n2++;
    }
    var prefix;
    switch (n2) {
      case pattern2.length:
        this._processSimple(pattern2.join("/"), index);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern2.slice(0, n2).join("/");
        break;
    }
    var remain = pattern2.slice(n2);
    var read2;
    if (prefix === null)
      read2 = ".";
    else if (isAbsolute3(prefix) || isAbsolute3(pattern2.map(function(p) {
      return typeof p === "string" ? p : "[*]";
    }).join("/"))) {
      if (!prefix || !isAbsolute3(prefix))
        prefix = "/" + prefix;
      read2 = prefix;
    } else
      read2 = prefix;
    var abs = this._makeAbs(read2);
    if (childrenIgnored2(this, read2))
      return;
    var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read2, abs, remain, index, inGlobStar);
    else
      this._processReaddir(prefix, read2, abs, remain, index, inGlobStar);
  };
  GlobSync.prototype._processReaddir = function(prefix, read2, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return;
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix.slice(-1) !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path4.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return;
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix)
        newPattern = [prefix, e];
      else
        newPattern = [e];
      this._process(newPattern.concat(remain), index, inGlobStar);
    }
  };
  GlobSync.prototype._emitMatch = function(index, e) {
    if (isIgnored2(this, e))
      return;
    var abs = this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute) {
      e = abs;
    }
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    if (this.stat)
      this._stat(e);
  };
  GlobSync.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, false);
    var entries;
    var lstat3;
    try {
      lstat3 = this.fs.lstatSync(abs);
    } catch (er) {
      if (er.code === "ENOENT") {
        return null;
      }
    }
    var isSym = lstat3 && lstat3.isSymbolicLink();
    this.symlinks[abs] = isSym;
    if (!isSym && lstat3 && !lstat3.isDirectory())
      this.cache[abs] = "FILE";
    else
      entries = this._readdir(abs, false);
    return entries;
  };
  GlobSync.prototype._readdir = function(abs, inGlobStar) {
    if (inGlobStar && !ownProp2(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp2(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return null;
      if (Array.isArray(c))
        return c;
    }
    try {
      return this._readdirEntries(abs, this.fs.readdirSync(abs));
    } catch (er) {
      this._readdirError(abs, er);
      return null;
    }
  };
  GlobSync.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return entries;
  };
  GlobSync.prototype._readdirError = function(f, er) {
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error2 = new Error(er.code + " invalid cwd " + this.cwd);
          error2.path = this.cwd;
          error2.code = er.code;
          throw error2;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict)
          throw er;
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
  };
  GlobSync.prototype._processGlobStar = function(prefix, read2, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false);
    var len = entries.length;
    var isSym = this.symlinks[abs];
    if (isSym && inGlobStar)
      return;
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true);
    }
  };
  GlobSync.prototype._processSimple = function(prefix, index) {
    var exists = this._stat(prefix);
    if (!this.matches[index])
      this.matches[index] = /* @__PURE__ */ Object.create(null);
    if (!exists)
      return;
    if (prefix && isAbsolute3(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path4.join(this.root, prefix);
      } else {
        prefix = path4.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
  };
  GlobSync.prototype._stat = function(f) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return false;
    if (!this.stat && ownProp2(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return c;
      if (needDir && c === "FILE")
        return false;
    }
    var stat2 = this.statCache[abs];
    if (!stat2) {
      var lstat3;
      try {
        lstat3 = this.fs.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs] = false;
          return false;
        }
      }
      if (lstat3 && lstat3.isSymbolicLink()) {
        try {
          stat2 = this.fs.statSync(abs);
        } catch (er) {
          stat2 = lstat3;
        }
      } else {
        stat2 = lstat3;
      }
    }
    this.statCache[abs] = stat2;
    var c = true;
    if (stat2)
      c = stat2.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return false;
    return c;
  };
  GlobSync.prototype._mark = function(p) {
    return common2.mark(this, p);
  };
  GlobSync.prototype._makeAbs = function(f) {
    return common2.makeAbs(this, f);
  };
  return sync$9;
}
function wrappy$2(fn, cb) {
  if (fn && cb)
    return wrappy$2(fn)(cb);
  if (typeof fn !== "function")
    throw new TypeError("need wrapper function");
  Object.keys(fn).forEach(function(k) {
    wrapper[k] = fn[k];
  });
  return wrapper;
  function wrapper() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    var ret = fn.apply(this, args);
    var cb2 = args[args.length - 1];
    if (typeof ret === "function" && ret !== cb2) {
      Object.keys(cb2).forEach(function(k) {
        ret[k] = cb2[k];
      });
    }
    return ret;
  }
}
function once$1(fn) {
  var f = function() {
    if (f.called)
      return f.value;
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };
  f.called = false;
  return f;
}
function onceStrict(fn) {
  var f = function() {
    if (f.called)
      throw new Error(f.onceError);
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };
  var name2 = fn.name || "Function wrapped with `once`";
  f.onceError = name2 + " shouldn't be called more than once";
  f.called = false;
  return f;
}
function inflight(key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb);
    return null;
  } else {
    reqs[key] = [cb];
    return makeres(key);
  }
}
function makeres(key) {
  return once(function RES() {
    var cbs = reqs[key];
    var len = cbs.length;
    var args = slice$1(arguments);
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args);
      }
    } finally {
      if (cbs.length > len) {
        cbs.splice(0, len);
        process.nextTick(function() {
          RES.apply(null, args);
        });
      } else {
        delete reqs[key];
      }
    }
  });
}
function slice$1(args) {
  var length = args.length;
  var array2 = [];
  for (var i = 0; i < length; i++)
    array2[i] = args[i];
  return array2;
}
function requireGlob() {
  if (hasRequiredGlob)
    return glob_1;
  hasRequiredGlob = 1;
  glob_1 = glob;
  var rp = fs_realpath;
  var minimatch2 = minimatch_1;
  var inherits2 = inheritsExports;
  var EE = import_events.default.EventEmitter;
  var path4 = import_path2.default;
  var assert2 = import_assert.default;
  var isAbsolute3 = import_path2.default.isAbsolute;
  var globSync = requireSync();
  var common2 = common$c;
  var setopts2 = common2.setopts;
  var ownProp2 = common2.ownProp;
  var inflight2 = inflight_1;
  var childrenIgnored2 = common2.childrenIgnored;
  var isIgnored2 = common2.isIgnored;
  var once2 = onceExports;
  function glob(pattern2, options2, cb) {
    if (typeof options2 === "function")
      cb = options2, options2 = {};
    if (!options2)
      options2 = {};
    if (options2.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync(pattern2, options2);
    }
    return new Glob(pattern2, options2, cb);
  }
  glob.sync = globSync;
  var GlobSync = glob.GlobSync = globSync.GlobSync;
  glob.glob = glob;
  function extend3(origin, add) {
    if (add === null || typeof add !== "object") {
      return origin;
    }
    var keys2 = Object.keys(add);
    var i = keys2.length;
    while (i--) {
      origin[keys2[i]] = add[keys2[i]];
    }
    return origin;
  }
  glob.hasMagic = function(pattern2, options_) {
    var options2 = extend3({}, options_);
    options2.noprocess = true;
    var g = new Glob(pattern2, options2);
    var set2 = g.minimatch.set;
    if (!pattern2)
      return false;
    if (set2.length > 1)
      return true;
    for (var j = 0; j < set2[0].length; j++) {
      if (typeof set2[0][j] !== "string")
        return true;
    }
    return false;
  };
  glob.Glob = Glob;
  inherits2(Glob, EE);
  function Glob(pattern2, options2, cb) {
    if (typeof options2 === "function") {
      cb = options2;
      options2 = null;
    }
    if (options2 && options2.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern2, options2);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern2, options2, cb);
    setopts2(this, pattern2, options2);
    this._didRealPath = false;
    var n2 = this.minimatch.set.length;
    this.matches = new Array(n2);
    if (typeof cb === "function") {
      cb = once2(cb);
      this.on("error", cb);
      this.on("end", function(matches) {
        cb(null, matches);
      });
    }
    var self2 = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess)
      return this;
    if (n2 === 0)
      return done();
    var sync2 = true;
    for (var i = 0; i < n2; i++) {
      this._process(this.minimatch.set[i], i, false, done);
    }
    sync2 = false;
    function done() {
      --self2._processing;
      if (self2._processing <= 0) {
        if (sync2) {
          process.nextTick(function() {
            self2._finish();
          });
        } else {
          self2._finish();
        }
      }
    }
  }
  Glob.prototype._finish = function() {
    assert2(this instanceof Glob);
    if (this.aborted)
      return;
    if (this.realpath && !this._didRealpath)
      return this._realpath();
    common2.finish(this);
    this.emit("end", this.found);
  };
  Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = true;
    var n2 = this.matches.length;
    if (n2 === 0)
      return this._finish();
    var self2 = this;
    for (var i = 0; i < this.matches.length; i++)
      this._realpathSet(i, next);
    function next() {
      if (--n2 === 0)
        self2._finish();
    }
  };
  Glob.prototype._realpathSet = function(index, cb) {
    var matchset = this.matches[index];
    if (!matchset)
      return cb();
    var found2 = Object.keys(matchset);
    var self2 = this;
    var n2 = found2.length;
    if (n2 === 0)
      return cb();
    var set2 = this.matches[index] = /* @__PURE__ */ Object.create(null);
    found2.forEach(function(p, i) {
      p = self2._makeAbs(p);
      rp.realpath(p, self2.realpathCache, function(er, real) {
        if (!er)
          set2[real] = true;
        else if (er.syscall === "stat")
          set2[p] = true;
        else
          self2.emit("error", er);
        if (--n2 === 0) {
          self2.matches[index] = set2;
          cb();
        }
      });
    });
  };
  Glob.prototype._mark = function(p) {
    return common2.mark(this, p);
  };
  Glob.prototype._makeAbs = function(f) {
    return common2.makeAbs(this, f);
  };
  Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit("abort");
  };
  Glob.prototype.pause = function() {
    if (!this.paused) {
      this.paused = true;
      this.emit("pause");
    }
  };
  Glob.prototype.resume = function() {
    if (this.paused) {
      this.emit("resume");
      this.paused = false;
      if (this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i = 0; i < eq.length; i++) {
          var e = eq[i];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i = 0; i < pq.length; i++) {
          var p = pq[i];
          this._processing--;
          this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  };
  Glob.prototype._process = function(pattern2, index, inGlobStar, cb) {
    assert2(this instanceof Glob);
    assert2(typeof cb === "function");
    if (this.aborted)
      return;
    this._processing++;
    if (this.paused) {
      this._processQueue.push([pattern2, index, inGlobStar, cb]);
      return;
    }
    var n2 = 0;
    while (typeof pattern2[n2] === "string") {
      n2++;
    }
    var prefix;
    switch (n2) {
      case pattern2.length:
        this._processSimple(pattern2.join("/"), index, cb);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern2.slice(0, n2).join("/");
        break;
    }
    var remain = pattern2.slice(n2);
    var read2;
    if (prefix === null)
      read2 = ".";
    else if (isAbsolute3(prefix) || isAbsolute3(pattern2.map(function(p) {
      return typeof p === "string" ? p : "[*]";
    }).join("/"))) {
      if (!prefix || !isAbsolute3(prefix))
        prefix = "/" + prefix;
      read2 = prefix;
    } else
      read2 = prefix;
    var abs = this._makeAbs(read2);
    if (childrenIgnored2(this, read2))
      return cb();
    var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read2, abs, remain, index, inGlobStar, cb);
    else
      this._processReaddir(prefix, read2, abs, remain, index, inGlobStar, cb);
  };
  Glob.prototype._processReaddir = function(prefix, read2, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix, read2, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processReaddir2 = function(prefix, read2, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path4.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return cb();
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      if (prefix) {
        if (prefix !== "/")
          e = prefix + "/" + e;
        else
          e = prefix + e;
      }
      this._process([e].concat(remain), index, inGlobStar, cb);
    }
    cb();
  };
  Glob.prototype._emitMatch = function(index, e) {
    if (this.aborted)
      return;
    if (isIgnored2(this, e))
      return;
    if (this.paused) {
      this._emitQueue.push([index, e]);
      return;
    }
    var abs = isAbsolute3(e) ? e : this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute)
      e = abs;
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    var st = this.statCache[abs];
    if (st)
      this.emit("stat", e, st);
    this.emit("match", e);
  };
  Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, false, cb);
    var lstatkey = "lstat\0" + abs;
    var self2 = this;
    var lstatcb = inflight2(lstatkey, lstatcb_);
    if (lstatcb)
      self2.fs.lstat(abs, lstatcb);
    function lstatcb_(er, lstat3) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat3 && lstat3.isSymbolicLink();
      self2.symlinks[abs] = isSym;
      if (!isSym && lstat3 && !lstat3.isDirectory()) {
        self2.cache[abs] = "FILE";
        cb();
      } else
        self2._readdir(abs, false, cb);
    }
  };
  Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (this.aborted)
      return;
    cb = inflight2("readdir\0" + abs + "\0" + inGlobStar, cb);
    if (!cb)
      return;
    if (inGlobStar && !ownProp2(this.symlinks, abs))
      return this._readdirInGlobStar(abs, cb);
    if (ownProp2(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return cb();
      if (Array.isArray(c))
        return cb(null, c);
    }
    var self2 = this;
    self2.fs.readdir(abs, readdirCb(this, abs, cb));
  };
  function readdirCb(self2, abs, cb) {
    return function(er, entries) {
      if (er)
        self2._readdirError(abs, er, cb);
      else
        self2._readdirEntries(abs, entries, cb);
    };
  }
  Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (this.aborted)
      return;
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return cb(null, entries);
  };
  Glob.prototype._readdirError = function(f, er, cb) {
    if (this.aborted)
      return;
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error2 = new Error(er.code + " invalid cwd " + this.cwd);
          error2.path = this.cwd;
          error2.code = er.code;
          this.emit("error", error2);
          this.abort();
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict) {
          this.emit("error", er);
          this.abort();
        }
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
    return cb();
  };
  Glob.prototype._processGlobStar = function(prefix, read2, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix, read2, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processGlobStar2 = function(prefix, read2, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false, cb);
    var isSym = this.symlinks[abs];
    var len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true, cb);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true, cb);
    }
    cb();
  };
  Glob.prototype._processSimple = function(prefix, index, cb) {
    var self2 = this;
    this._stat(prefix, function(er, exists) {
      self2._processSimple2(prefix, index, er, exists, cb);
    });
  };
  Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
    if (!this.matches[index])
      this.matches[index] = /* @__PURE__ */ Object.create(null);
    if (!exists)
      return cb();
    if (prefix && isAbsolute3(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path4.join(this.root, prefix);
      } else {
        prefix = path4.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
    cb();
  };
  Glob.prototype._stat = function(f, cb) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp2(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return cb(null, c);
      if (needDir && c === "FILE")
        return cb();
    }
    var stat2 = this.statCache[abs];
    if (stat2 !== void 0) {
      if (stat2 === false)
        return cb(null, stat2);
      else {
        var type = stat2.isDirectory() ? "DIR" : "FILE";
        if (needDir && type === "FILE")
          return cb();
        else
          return cb(null, type, stat2);
      }
    }
    var self2 = this;
    var statcb = inflight2("stat\0" + abs, lstatcb_);
    if (statcb)
      self2.fs.lstat(abs, statcb);
    function lstatcb_(er, lstat3) {
      if (lstat3 && lstat3.isSymbolicLink()) {
        return self2.fs.stat(abs, function(er2, stat3) {
          if (er2)
            self2._stat2(f, abs, null, lstat3, cb);
          else
            self2._stat2(f, abs, er2, stat3, cb);
        });
      } else {
        self2._stat2(f, abs, er, lstat3, cb);
      }
    }
  };
  Glob.prototype._stat2 = function(f, abs, er, stat2, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
      this.statCache[abs] = false;
      return cb();
    }
    var needDir = f.slice(-1) === "/";
    this.statCache[abs] = stat2;
    if (abs.slice(-1) === "/" && stat2 && !stat2.isDirectory())
      return cb(null, false, stat2);
    var c = true;
    if (stat2)
      c = stat2.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return cb();
    return cb(null, c, stat2);
  };
  return glob_1;
}
function decode(mappings) {
  const state = new Int32Array(5);
  const decoded = [];
  let index = 0;
  do {
    const semi = indexOf(mappings, index);
    const line = [];
    let sorted = true;
    let lastCol = 0;
    state[0] = 0;
    for (let i = index; i < semi; i++) {
      let seg;
      i = decodeInteger(mappings, i, state, 0);
      const col = state[0];
      if (col < lastCol)
        sorted = false;
      lastCol = col;
      if (hasMoreVlq(mappings, i, semi)) {
        i = decodeInteger(mappings, i, state, 1);
        i = decodeInteger(mappings, i, state, 2);
        i = decodeInteger(mappings, i, state, 3);
        if (hasMoreVlq(mappings, i, semi)) {
          i = decodeInteger(mappings, i, state, 4);
          seg = [col, state[1], state[2], state[3], state[4]];
        } else {
          seg = [col, state[1], state[2], state[3]];
        }
      } else {
        seg = [col];
      }
      line.push(seg);
    }
    if (!sorted)
      sort(line);
    decoded.push(line);
    index = semi + 1;
  } while (index <= mappings.length);
  return decoded;
}
function indexOf(mappings, index) {
  const idx = mappings.indexOf(";", index);
  return idx === -1 ? mappings.length : idx;
}
function decodeInteger(mappings, pos, state, j) {
  let value2 = 0;
  let shift = 0;
  let integer = 0;
  do {
    const c = mappings.charCodeAt(pos++);
    integer = charToInt3[c];
    value2 |= (integer & 31) << shift;
    shift += 5;
  } while (integer & 32);
  const shouldNegate = value2 & 1;
  value2 >>>= 1;
  if (shouldNegate) {
    value2 = -2147483648 | -value2;
  }
  state[j] += value2;
  return pos;
}
function hasMoreVlq(mappings, i, length) {
  if (i >= length)
    return false;
  return mappings.charCodeAt(i) !== comma3;
}
function sort(line) {
  line.sort(sortComparator$1);
}
function sortComparator$1(a, b) {
  return a[0] - b[0];
}
function encode$1(decoded) {
  const state = new Int32Array(5);
  const bufLength = 1024 * 16;
  const subLength = bufLength - 36;
  const buf = new Uint8Array(bufLength);
  const sub = buf.subarray(0, subLength);
  let pos = 0;
  let out = "";
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0) {
      if (pos === bufLength) {
        out += td2.decode(buf);
        pos = 0;
      }
      buf[pos++] = semicolon3;
    }
    if (line.length === 0)
      continue;
    state[0] = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      if (pos > subLength) {
        out += td2.decode(sub);
        buf.copyWithin(0, subLength, pos);
        pos -= subLength;
      }
      if (j > 0)
        buf[pos++] = comma3;
      pos = encodeInteger2(buf, pos, state, segment, 0);
      if (segment.length === 1)
        continue;
      pos = encodeInteger2(buf, pos, state, segment, 1);
      pos = encodeInteger2(buf, pos, state, segment, 2);
      pos = encodeInteger2(buf, pos, state, segment, 3);
      if (segment.length === 4)
        continue;
      pos = encodeInteger2(buf, pos, state, segment, 4);
    }
  }
  return out + td2.decode(buf.subarray(0, pos));
}
function encodeInteger2(buf, pos, state, segment, j) {
  const next = segment[j];
  let num = next - state[j];
  state[j] = next;
  num = num < 0 ? -num << 1 | 1 : num << 1;
  do {
    let clamped = num & 31;
    num >>>= 5;
    if (num > 0)
      clamped |= 32;
    buf[pos++] = intToChar3[clamped];
  } while (num > 0);
  return pos;
}
function binarySearch(haystack, needle, low, high) {
  while (low <= high) {
    const mid = low + (high - low >> 1);
    const cmp = haystack[mid][COLUMN] - needle;
    if (cmp === 0) {
      found = true;
      return mid;
    }
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  found = false;
  return low - 1;
}
function upperBound(haystack, needle, index) {
  for (let i = index + 1; i < haystack.length; index = i++) {
    if (haystack[i][COLUMN] !== needle)
      break;
  }
  return index;
}
function lowerBound(haystack, needle, index) {
  for (let i = index - 1; i >= 0; index = i--) {
    if (haystack[i][COLUMN] !== needle)
      break;
  }
  return index;
}
function memoizedBinarySearch(haystack, needle, state, key) {
  const { lastKey, lastNeedle, lastIndex } = state;
  let low = 0;
  let high = haystack.length - 1;
  if (key === lastKey) {
    if (needle === lastNeedle) {
      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
      return lastIndex;
    }
    if (needle >= lastNeedle) {
      low = lastIndex === -1 ? 0 : lastIndex;
    } else {
      high = lastIndex;
    }
  }
  state.lastKey = key;
  state.lastNeedle = needle;
  return state.lastIndex = binarySearch(haystack, needle, low, high);
}
function OMapping(source, line, column, name2) {
  return { source, line, column, name: name2 };
}
function traceSegmentInternal(segments, memo, line, column, bias) {
  let index = memoizedBinarySearch(segments, column, memo, line);
  if (found) {
    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
  } else if (bias === LEAST_UPPER_BOUND)
    index++;
  if (index === -1 || index === segments.length)
    return -1;
  return index;
}
function getLine(mappings, index) {
  for (let i = mappings.length; i <= index; i++) {
    mappings[i] = [];
  }
  return mappings[index];
}
function getColumnIndex(line, column, seg) {
  let index = line.length;
  for (let i = index - 1; i >= 0; i--, index--) {
    const current3 = line[i];
    const col = current3[0];
    if (col > column)
      continue;
    if (col < column)
      break;
    const cmp = compare$1(current3, seg);
    if (cmp === 0)
      return index;
    if (cmp < 0)
      break;
  }
  return index;
}
function compare$1(a, b) {
  let cmp = compareNum(a.length, b.length);
  if (cmp !== 0)
    return cmp;
  if (a.length === 1)
    return 0;
  cmp = compareNum(a[1], b[1]);
  if (cmp !== 0)
    return cmp;
  cmp = compareNum(a[2], b[2]);
  if (cmp !== 0)
    return cmp;
  cmp = compareNum(a[3], b[3]);
  if (cmp !== 0)
    return cmp;
  if (a.length === 4)
    return 0;
  return compareNum(a[4], b[4]);
}
function compareNum(a, b) {
  return a - b;
}
function insert(array2, index, value2) {
  if (index === -1)
    return;
  for (let i = array2.length; i > index; i--) {
    array2[i] = array2[i - 1];
  }
  array2[index] = value2;
}
function requireMs$1() {
  if (hasRequiredMs$1)
    return ms$1;
  hasRequiredMs$1 = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms$1 = function(val, options2) {
    options2 = options2 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse7(val);
    } else if (type === "number" && isFinite(val)) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse7(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n2 = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n2 * y;
      case "weeks":
      case "week":
      case "w":
        return n2 * w;
      case "days":
      case "day":
      case "d":
        return n2 * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n2 * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n2 * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n2 * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n2;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n2, name2) {
    var isPlural = msAbs >= n2 * 1.5;
    return Math.round(ms2 / n2) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms$1;
}
function requireCommon() {
  if (hasRequiredCommon)
    return common$b;
  hasRequiredCommon = 1;
  function setup(env3) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs$1();
    createDebug.destroy = destroy;
    Object.keys(env3).forEach((key) => {
      createDebug[key] = env3[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter2 = createDebug.formatters[format2];
          if (typeof formatter2 === "function") {
            const val = args[index];
            match = formatter2.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend3;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend3(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name2) {
      if (name2[name2.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name2)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$b = setup;
  return common$b;
}
function requireBrowser$1() {
  if (hasRequiredBrowser$1)
    return browserExports$1;
  hasRequiredBrowser$1 = 1;
  (function(module2, exports2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned3 = false;
      return () => {
        if (!warned3) {
          warned3 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module2.exports = requireCommon()(exports2);
    const { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser$2, browserExports$1);
  return browserExports$1;
}
function requireNode$1() {
  if (hasRequiredNode$1)
    return nodeExports$1;
  hasRequiredNode$1 = 1;
  (function(module2, exports2) {
    const tty3 = import_tty.default;
    const util2 = import_util.default;
    exports2.init = init4;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require2("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty3.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util2.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init4(debug2) {
      debug2.inspectOpts = {};
      const keys2 = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys2.length; i++) {
        debug2.inspectOpts[keys2[i]] = exports2.inspectOpts[keys2[i]];
      }
    }
    module2.exports = requireCommon()(exports2);
    const { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node$1, nodeExports$1);
  return nodeExports$1;
}
function slash$1(p) {
  return p.replace(/\\/g, "/");
}
function createDebugger(namespace, options2 = {}) {
  const log = _debug(namespace);
  const { onlyWhenFocused } = options2;
  const focus = typeof onlyWhenFocused === "string" ? onlyWhenFocused : namespace;
  return (msg, ...args) => {
    if (filter && !msg.includes(filter)) {
      return;
    }
    if (onlyWhenFocused && !DEBUG?.includes(focus)) {
      return;
    }
    log(msg, ...args);
  };
}
function testCaseInsensitiveFS() {
  if (!CLIENT_ENTRY.endsWith("client.mjs")) {
    throw new Error(`cannot test case insensitive FS, CLIENT_ENTRY const doesn't contain client.mjs`);
  }
  if (!import_node_fs2.default.existsSync(CLIENT_ENTRY)) {
    throw new Error("cannot test case insensitive FS, CLIENT_ENTRY does not point to an existing file: " + CLIENT_ENTRY);
  }
  return import_node_fs2.default.existsSync(CLIENT_ENTRY.replace("client.mjs", "cLiEnT.mjs"));
}
function normalizePath$3(id) {
  return import_node_path4.default.posix.normalize(isWindows$4 ? slash$1(id) : id);
}
async function asyncReplace(input, re, replacer) {
  let match;
  let remaining = input;
  let rewritten = "";
  while (match = re.exec(remaining)) {
    rewritten += remaining.slice(0, match.index);
    rewritten += await replacer(match);
    remaining = remaining.slice(match.index + match[0].length);
  }
  rewritten += remaining;
  return rewritten;
}
function reduceSrcset(ret) {
  return ret.reduce((prev, { url: url2, descriptor }, index) => {
    descriptor ?? (descriptor = "");
    return prev += url2 + ` ${descriptor}${index === ret.length - 1 ? "" : ", "}`;
  }, "");
}
function splitSrcSetDescriptor(srcs) {
  return splitSrcSet(srcs).map((s) => {
    const src2 = s.replace(escapedSpaceCharacters, " ").trim();
    const [url2] = imageSetUrlRE.exec(src2) || [""];
    return {
      url: url2,
      descriptor: src2?.slice(url2.length).trim()
    };
  }).filter(({ url: url2 }) => !!url2);
}
function processSrcSet(srcs, replacer) {
  return Promise.all(splitSrcSetDescriptor(srcs).map(async ({ url: url2, descriptor }) => ({
    url: await replacer({ url: url2, descriptor }),
    descriptor
  }))).then((ret) => reduceSrcset(ret));
}
function splitSrcSet(srcs) {
  const parts = [];
  const cleanedSrcs = srcs.replace(/(?:url|image|gradient|cross-fade)\([^)]*\)|"([^"]|(?<=\\)")*"|'([^']|(?<=\\)')*'/g, blankReplacer);
  let startIndex = 0;
  let splitIndex;
  do {
    splitIndex = cleanedSrcs.indexOf(",", startIndex);
    parts.push(srcs.slice(startIndex, splitIndex !== -1 ? splitIndex : void 0));
    startIndex = splitIndex + 1;
  } while (splitIndex !== -1);
  return parts;
}
function gracefulRename(from, to, cb) {
  const start = Date.now();
  let backoff = 0;
  import_node_fs2.default.rename(from, to, function CB(er) {
    if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < GRACEFUL_RENAME_TIMEOUT) {
      setTimeout(function() {
        import_node_fs2.default.stat(to, function(stater, st) {
          if (stater && stater.code === "ENOENT")
            import_node_fs2.default.rename(from, to, CB);
          else
            CB(er);
        });
      }, backoff);
      if (backoff < 100)
        backoff += 10;
      return;
    }
    if (cb)
      cb(er);
  });
}
function gracefulRemoveDir(dir, cb) {
  const start = Date.now();
  let backoff = 0;
  import_node_fs2.default.rm(dir, { recursive: true }, function CB(er) {
    if (er) {
      if ((er.code === "ENOTEMPTY" || er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < GRACEFUL_REMOVE_DIR_TIMEOUT) {
        setTimeout(function() {
          import_node_fs2.default.rm(dir, { recursive: true }, CB);
        }, backoff);
        if (backoff < 100)
          backoff += 10;
        return;
      }
      if (er.code === "ENOENT") {
        er = null;
      }
    }
    if (cb)
      cb(er);
  });
}
function genWorkerCode(fn) {
  return `
const doWork = ${fn.toString()}

const { parentPort } = require('worker_threads')

parentPort.on('message', async (args) => {
  const res = await doWork(...args)
  parentPort.postMessage(res)
})
  `;
}
function getBtoa2() {
  if (typeof window !== "undefined" && typeof window.btoa === "function") {
    return (str) => window.btoa(unescape(encodeURIComponent(str)));
  } else if (typeof Buffer === "function") {
    return (str) => Buffer.from(str, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
function guessIndent2(code) {
  const lines = code.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min2 = spaced.reduce((previous, current3) => {
    const numSpaces = /^ +/.exec(current3)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min2 + 1).join(" ");
}
function getRelativePath2(from, to) {
  const fromParts = from.split(/[/\\]/);
  const toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--)
      fromParts[i] = "..";
  }
  return fromParts.concat(toParts).join("/");
}
function isObject$1(thing) {
  return toString$2.call(thing) === "[object Object]";
}
function getLocator2(source) {
  const originalLines = source.split("\n");
  const lineOffsets = [];
  for (let i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate(index) {
    let i = 0;
    let j = lineOffsets.length;
    while (i < j) {
      const m = i + j >> 1;
      if (index < lineOffsets[m]) {
        j = m;
      } else {
        i = m + 1;
      }
    }
    const line = i - 1;
    const column = index - lineOffsets[line];
    return { line, column };
  };
}
function isInAstralSet2(code, set2) {
  var pos = 65536;
  for (var i = 0; i < set2.length; i += 2) {
    pos += set2[i];
    if (pos > code) {
      return false;
    }
    pos += set2[i + 1];
    if (pos >= code) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart2(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart2.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet2(code, astralIdentifierStartCodes2);
}
function isIdentifierChar2(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier2.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet2(code, astralIdentifierStartCodes2) || isInAstralSet2(code, astralIdentifierCodes2);
}
function binop2(name2, prec) {
  return new TokenType3(name2, { beforeExpr: true, binop: prec });
}
function kw2(name2, options2) {
  if (options2 === void 0)
    options2 = {};
  options2.keyword = name2;
  return keywords$2[name2] = new TokenType3(name2, options2);
}
function isNewLine2(code) {
  return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak2(code, from, end) {
  if (end === void 0)
    end = code.length;
  for (var i = from; i < end; i++) {
    var next = code.charCodeAt(i);
    if (isNewLine2(next)) {
      return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
function wordsRegexp2(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}
function codePointToString2(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
function getLineInfo2(input, offset4) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak2(input, cur, offset4);
    if (nextBreak < 0) {
      return new Position3(line, offset4 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
function getOptions2(opts) {
  var options2 = {};
  for (var opt in defaultOptions2) {
    options2[opt] = opts && hasOwn2(opts, opt) ? opts[opt] : defaultOptions2[opt];
  }
  if (options2.ecmaVersion === "latest") {
    options2.ecmaVersion = 1e8;
  } else if (options2.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion2 && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion2 = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options2.ecmaVersion = 11;
  } else if (options2.ecmaVersion >= 2015) {
    options2.ecmaVersion -= 2009;
  }
  if (options2.allowReserved == null) {
    options2.allowReserved = options2.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options2.allowHashBang = options2.ecmaVersion >= 14;
  }
  if (isArray2(options2.onToken)) {
    var tokens = options2.onToken;
    options2.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray2(options2.onComment)) {
    options2.onComment = pushComment2(options2, options2.onComment);
  }
  return options2;
}
function pushComment2(options2, array2) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start,
      end
    };
    if (options2.locations) {
      comment.loc = new SourceLocation3(this, startLoc, endLoc);
    }
    if (options2.ranges) {
      comment.range = [start, end];
    }
    array2.push(comment);
  };
}
function functionFlags2(async2, generator) {
  return SCOPE_FUNCTION2 | (async2 ? SCOPE_ASYNC2 : 0) | (generator ? SCOPE_GENERATOR2 : 0);
}
function isPrivateNameConflicted2(privateNameMap, element) {
  var name2 = element.key.name;
  var curr = privateNameMap[name2];
  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name2] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name2] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName2(node2, name2) {
  var computed = node2.computed;
  var key = node2.key;
  return !computed && (key.type === "Identifier" && key.name === name2 || key.type === "Literal" && key.value === name2);
}
function isPrivateFieldAccess2(node2) {
  return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess2(node2.expression);
}
function finishNodeAt2(node2, type, pos, loc) {
  node2.type = type;
  node2.end = pos;
  if (this.options.locations) {
    node2.loc.end = loc;
  }
  if (this.options.ranges) {
    node2.range[1] = pos;
  }
  return node2;
}
function buildUnicodeData2(ecmaVersion) {
  var d = data2[ecmaVersion] = {
    binary: wordsRegexp2(unicodeBinaryProperties2[ecmaVersion] + " " + unicodeGeneralCategoryValues2),
    nonBinary: {
      General_Category: wordsRegexp2(unicodeGeneralCategoryValues2),
      Script: wordsRegexp2(unicodeScriptValues2[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
function isSyntaxCharacter2(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
function isRegExpIdentifierStart2(ch) {
  return isIdentifierStart2(ch, true) || ch === 36 || ch === 95;
}
function isRegExpIdentifierPart2(ch) {
  return isIdentifierChar2(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
function isControlLetter2(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
function isValidUnicode2(ch) {
  return ch >= 0 && ch <= 1114111;
}
function isCharacterClassEscape2(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
function isUnicodePropertyNameCharacter2(ch) {
  return isControlLetter2(ch) || ch === 95;
}
function isUnicodePropertyValueCharacter2(ch) {
  return isUnicodePropertyNameCharacter2(ch) || isDecimalDigit2(ch);
}
function isDecimalDigit2(ch) {
  return ch >= 48 && ch <= 57;
}
function isHexDigit2(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt2(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
function isOctalDigit2(ch) {
  return ch >= 48 && ch <= 55;
}
function stringToNumber2(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt2(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
function formatList(array2, type = "and") {
  return array2.length < 3 ? array2.join(` ${type} `) : `${array2.slice(0, -1).join(", ")}, ${type} ${array2[array2.length - 1]}`;
}
function createError(sym, value2, def) {
  messages.set(sym, value2);
  return makeNodeErrorWithCode(def, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError(...args) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable())
      Error.stackTraceLimit = 0;
    const error2 = new Base();
    if (isErrorStackTraceLimitWritable())
      Error.stackTraceLimit = limit;
    const message = getMessage(key, args, error2);
    Object.defineProperties(error2, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error2);
    error2.code = key;
    return error2;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (import_node_v8.default.startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return own$1.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(fn) {
  const hidden = nodeInternalPrefix + fn.name;
  Object.defineProperty(fn, "name", { value: hidden });
  return fn;
}
function getMessage(key, args, self2) {
  const message = messages.get(key);
  (0, import_node_assert.default)(typeof message !== "undefined", "expected `message` to be found");
  if (typeof message === "function") {
    (0, import_node_assert.default)(
      message.length <= args.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self2, args);
  }
  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex.exec(message) !== null)
    expectedLength++;
  (0, import_node_assert.default)(
    expectedLength === args.length,
    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
  );
  if (args.length === 0)
    return message;
  args.unshift(message);
  return Reflect.apply(import_node_util.format, null, args);
}
function flatten$1(items) {
  return items.reduce((collection, item) => [].concat(collection, item), []);
}
function splitWhen(items, predicate) {
  const result = [[]];
  let groupIndex = 0;
  for (const item of items) {
    if (predicate(item)) {
      groupIndex++;
      result[groupIndex] = [];
    } else {
      result[groupIndex].push(item);
    }
  }
  return result;
}
function isEnoentCodeError(error2) {
  return error2.code === "ENOENT";
}
function createDirentFromStats$1(name2, stats) {
  return new DirentFromStats$1(name2, stats);
}
function unixify(filepath) {
  return filepath.replace(/\\/g, "/");
}
function makeAbsolute(cwd, filepath) {
  return path$g.resolve(cwd, filepath);
}
function escape$2(pattern2) {
  return pattern2.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
}
function removeLeadingDotSegment(entry2) {
  if (entry2.charAt(0) === ".") {
    const secondCharactery = entry2.charAt(1);
    if (secondCharactery === "/" || secondCharactery === "\\") {
      return entry2.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
    }
  }
  return entry2;
}
function collatePatterns(neg, pos, options2) {
  let onlyNegative = filterPatterns(neg, pos, "-", false) || [];
  let onlyPositive = filterPatterns(pos, neg, "", false) || [];
  let intersected = filterPatterns(neg, pos, "-?", true) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join("|");
}
function splitToRanges(min2, max) {
  let nines = 1;
  let zeros2 = 1;
  let stop = countNines(min2, nines);
  let stops = /* @__PURE__ */ new Set([max]);
  while (min2 <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min2, nines);
  }
  stop = countZeros(max + 1, zeros2) - 1;
  while (min2 < stop && stop <= max) {
    stops.add(stop);
    zeros2 += 1;
    stop = countZeros(max + 1, zeros2) - 1;
  }
  stops = [...stops];
  stops.sort(compare);
  return stops;
}
function rangeToPattern(start, stop, options2) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }
  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern2 = "";
  let count = 0;
  for (let i = 0; i < digits; i++) {
    let [startDigit, stopDigit] = zipped[i];
    if (startDigit === stopDigit) {
      pattern2 += startDigit;
    } else if (startDigit !== "0" || stopDigit !== "9") {
      pattern2 += toCharacterClass(startDigit, stopDigit);
    } else {
      count++;
    }
  }
  if (count) {
    pattern2 += options2.shorthand === true ? "\\d" : "[0-9]";
  }
  return { pattern: pattern2, count: [count], digits };
}
function splitToPatterns(min2, max, tok, options2) {
  let ranges = splitToRanges(min2, max);
  let tokens = [];
  let start = min2;
  let prev;
  for (let i = 0; i < ranges.length; i++) {
    let max2 = ranges[i];
    let obj = rangeToPattern(String(start), String(max2), options2);
    let zeros2 = "";
    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }
      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max2 + 1;
      continue;
    }
    if (tok.isPadded) {
      zeros2 = padZeros(max2, tok, options2);
    }
    obj.string = zeros2 + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max2 + 1;
    prev = obj;
  }
  return tokens;
}
function filterPatterns(arr, comparison, prefix, intersection, options2) {
  let result = [];
  for (let ele of arr) {
    let { string: string2 } = ele;
    if (!intersection && !contains(comparison, "string", string2)) {
      result.push(prefix + string2);
    }
    if (intersection && contains(comparison, "string", string2)) {
      result.push(prefix + string2);
    }
  }
  return result;
}
function zip(a, b) {
  let arr = [];
  for (let i = 0; i < a.length; i++)
    arr.push([a[i], b[i]]);
  return arr;
}
function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}
function contains(arr, key, val) {
  return arr.some((ele) => ele[key] === val);
}
function countNines(min2, len) {
  return Number(String(min2).slice(0, -len) + "9".repeat(len));
}
function countZeros(integer, zeros2) {
  return integer - integer % Math.pow(10, zeros2);
}
function toQuantifier(digits) {
  let [start = 0, stop = ""] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? "," + stop : "")}}`;
  }
  return "";
}
function toCharacterClass(a, b, options2) {
  return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
}
function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}
function padZeros(value2, tok, options2) {
  if (!tok.isPadded) {
    return value2;
  }
  let diff = Math.abs(tok.maxLen - String(value2).length);
  let relax = options2.relaxZeros !== false;
  switch (diff) {
    case 0:
      return "";
    case 1:
      return relax ? "0?" : "0";
    case 2:
      return relax ? "0{0,2}" : "00";
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}
function isStaticPattern(pattern2, options2 = {}) {
  return !isDynamicPattern(pattern2, options2);
}
function isDynamicPattern(pattern2, options2 = {}) {
  if (pattern2 === "") {
    return false;
  }
  if (options2.caseSensitiveMatch === false || pattern2.includes(ESCAPE_SYMBOL)) {
    return true;
  }
  if (COMMON_GLOB_SYMBOLS_RE.test(pattern2) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern2) || REGEX_GROUP_SYMBOLS_RE.test(pattern2)) {
    return true;
  }
  if (options2.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern2)) {
    return true;
  }
  if (options2.braceExpansion !== false && hasBraceExpansion(pattern2)) {
    return true;
  }
  return false;
}
function hasBraceExpansion(pattern2) {
  const openingBraceIndex = pattern2.indexOf("{");
  if (openingBraceIndex === -1) {
    return false;
  }
  const closingBraceIndex = pattern2.indexOf("}", openingBraceIndex + 1);
  if (closingBraceIndex === -1) {
    return false;
  }
  const braceContent = pattern2.slice(openingBraceIndex, closingBraceIndex);
  return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
}
function convertToPositivePattern(pattern2) {
  return isNegativePattern(pattern2) ? pattern2.slice(1) : pattern2;
}
function convertToNegativePattern(pattern2) {
  return "!" + pattern2;
}
function isNegativePattern(pattern2) {
  return pattern2.startsWith("!") && pattern2[1] !== "(";
}
function isPositivePattern(pattern2) {
  return !isNegativePattern(pattern2);
}
function getNegativePatterns(patterns2) {
  return patterns2.filter(isNegativePattern);
}
function getPositivePatterns$1(patterns2) {
  return patterns2.filter(isPositivePattern);
}
function getPatternsInsideCurrentDirectory(patterns2) {
  return patterns2.filter((pattern2) => !isPatternRelatedToParentDirectory(pattern2));
}
function getPatternsOutsideCurrentDirectory(patterns2) {
  return patterns2.filter(isPatternRelatedToParentDirectory);
}
function isPatternRelatedToParentDirectory(pattern2) {
  return pattern2.startsWith("..") || pattern2.startsWith("./..");
}
function getBaseDirectory(pattern2) {
  return globParent$1(pattern2, { flipBackslashes: false });
}
function hasGlobStar(pattern2) {
  return pattern2.includes(GLOBSTAR$1);
}
function endsWithSlashGlobStar(pattern2) {
  return pattern2.endsWith("/" + GLOBSTAR$1);
}
function isAffectDepthOfReadingPattern(pattern2) {
  const basename3 = path$f.basename(pattern2);
  return endsWithSlashGlobStar(pattern2) || isStaticPattern(basename3);
}
function expandPatternsWithBraceExpansion(patterns2) {
  return patterns2.reduce((collection, pattern2) => {
    return collection.concat(expandBraceExpansion(pattern2));
  }, []);
}
function expandBraceExpansion(pattern2) {
  return micromatch.braces(pattern2, {
    expand: true,
    nodupes: true
  });
}
function getPatternParts(pattern2, options2) {
  let { parts } = micromatch.scan(pattern2, Object.assign(Object.assign({}, options2), { parts: true }));
  if (parts.length === 0) {
    parts = [pattern2];
  }
  if (parts[0].startsWith("/")) {
    parts[0] = parts[0].slice(1);
    parts.unshift("");
  }
  return parts;
}
function makeRe(pattern2, options2) {
  return micromatch.makeRe(pattern2, options2);
}
function convertPatternsToRe(patterns2, options2) {
  return patterns2.map((pattern2) => makeRe(pattern2, options2));
}
function matchAny(entry2, patternsRe) {
  return patternsRe.some((patternRe) => patternRe.test(entry2));
}
function merge2$1() {
  const streamsQueue = [];
  const args = slice.call(arguments);
  let merging = false;
  let options2 = args[args.length - 1];
  if (options2 && !Array.isArray(options2) && options2.pipe == null) {
    args.pop();
  } else {
    options2 = {};
  }
  const doEnd = options2.end !== false;
  const doPipeError = options2.pipeError === true;
  if (options2.objectMode == null) {
    options2.objectMode = true;
  }
  if (options2.highWaterMark == null) {
    options2.highWaterMark = 64 * 1024;
  }
  const mergedStream = PassThrough(options2);
  function addStream() {
    for (let i = 0, len = arguments.length; i < len; i++) {
      streamsQueue.push(pauseStreams(arguments[i], options2));
    }
    mergeStream();
    return this;
  }
  function mergeStream() {
    if (merging) {
      return;
    }
    merging = true;
    let streams = streamsQueue.shift();
    if (!streams) {
      process.nextTick(endStream);
      return;
    }
    if (!Array.isArray(streams)) {
      streams = [streams];
    }
    let pipesCount = streams.length + 1;
    function next() {
      if (--pipesCount > 0) {
        return;
      }
      merging = false;
      mergeStream();
    }
    function pipe(stream4) {
      function onend() {
        stream4.removeListener("merge2UnpipeEnd", onend);
        stream4.removeListener("end", onend);
        if (doPipeError) {
          stream4.removeListener("error", onerror);
        }
        next();
      }
      function onerror(err) {
        mergedStream.emit("error", err);
      }
      if (stream4._readableState.endEmitted) {
        return next();
      }
      stream4.on("merge2UnpipeEnd", onend);
      stream4.on("end", onend);
      if (doPipeError) {
        stream4.on("error", onerror);
      }
      stream4.pipe(mergedStream, { end: false });
      stream4.resume();
    }
    for (let i = 0; i < streams.length; i++) {
      pipe(streams[i]);
    }
    next();
  }
  function endStream() {
    merging = false;
    mergedStream.emit("queueDrain");
    if (doEnd) {
      mergedStream.end();
    }
  }
  mergedStream.setMaxListeners(0);
  mergedStream.add = addStream;
  mergedStream.on("unpipe", function(stream4) {
    stream4.emit("merge2UnpipeEnd");
  });
  if (args.length) {
    addStream.apply(null, args);
  }
  return mergedStream;
}
function pauseStreams(streams, options2) {
  if (!Array.isArray(streams)) {
    if (!streams._readableState && streams.pipe) {
      streams = streams.pipe(PassThrough(options2));
    }
    if (!streams._readableState || !streams.pause || !streams.pipe) {
      throw new Error("Only readable stream can be merged.");
    }
    streams.pause();
  } else {
    for (let i = 0, len = streams.length; i < len; i++) {
      streams[i] = pauseStreams(streams[i], options2);
    }
  }
  return streams;
}
function merge$1(streams) {
  const mergedStream = merge2(streams);
  streams.forEach((stream4) => {
    stream4.once("error", (error2) => mergedStream.emit("error", error2));
  });
  mergedStream.once("close", () => propagateCloseEventToSources(streams));
  mergedStream.once("end", () => propagateCloseEventToSources(streams));
  return mergedStream;
}
function propagateCloseEventToSources(streams) {
  streams.forEach((stream4) => stream4.emit("close"));
}
function isString(input) {
  return typeof input === "string";
}
function isEmpty$1(input) {
  return input === "";
}
function generate(patterns2, settings2) {
  const positivePatterns = getPositivePatterns(patterns2);
  const negativePatterns = getNegativePatternsAsPositive(patterns2, settings2.ignore);
  const staticPatterns = positivePatterns.filter((pattern2) => utils$a.pattern.isStaticPattern(pattern2, settings2));
  const dynamicPatterns = positivePatterns.filter((pattern2) => utils$a.pattern.isDynamicPattern(pattern2, settings2));
  const staticTasks = convertPatternsToTasks(
    staticPatterns,
    negativePatterns,
    /* dynamic */
    false
  );
  const dynamicTasks = convertPatternsToTasks(
    dynamicPatterns,
    negativePatterns,
    /* dynamic */
    true
  );
  return staticTasks.concat(dynamicTasks);
}
function convertPatternsToTasks(positive, negative, dynamic) {
  const tasks2 = [];
  const patternsOutsideCurrentDirectory = utils$a.pattern.getPatternsOutsideCurrentDirectory(positive);
  const patternsInsideCurrentDirectory = utils$a.pattern.getPatternsInsideCurrentDirectory(positive);
  const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
  const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
  tasks2.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
  if ("." in insideCurrentDirectoryGroup) {
    tasks2.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
  } else {
    tasks2.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
  }
  return tasks2;
}
function getPositivePatterns(patterns2) {
  return utils$a.pattern.getPositivePatterns(patterns2);
}
function getNegativePatternsAsPositive(patterns2, ignore3) {
  const negative = utils$a.pattern.getNegativePatterns(patterns2).concat(ignore3);
  const positive = negative.map(utils$a.pattern.convertToPositivePattern);
  return positive;
}
function groupPatternsByBaseDirectory(patterns2) {
  const group = {};
  return patterns2.reduce((collection, pattern2) => {
    const base3 = utils$a.pattern.getBaseDirectory(pattern2);
    if (base3 in collection) {
      collection[base3].push(pattern2);
    } else {
      collection[base3] = [pattern2];
    }
    return collection;
  }, group);
}
function convertPatternGroupsToTasks(positive, negative, dynamic) {
  return Object.keys(positive).map((base3) => {
    return convertPatternGroupToTask(base3, positive[base3], negative, dynamic);
  });
}
function convertPatternGroupToTask(base3, positive, negative, dynamic) {
  return {
    dynamic,
    positive,
    negative,
    base: base3,
    patterns: [].concat(positive, negative.map(utils$a.pattern.convertToNegativePattern))
  };
}
function transform(patterns2) {
  return patterns2.map((pattern2) => removeDuplicateSlashes(pattern2));
}
function removeDuplicateSlashes(pattern2) {
  return pattern2.replace(DOUBLE_SLASH_RE$1, "/");
}
function read$3(path4, settings2, callback) {
  settings2.fs.lstat(path4, (lstatError, lstat3) => {
    if (lstatError !== null) {
      callFailureCallback$2(callback, lstatError);
      return;
    }
    if (!lstat3.isSymbolicLink() || !settings2.followSymbolicLink) {
      callSuccessCallback$2(callback, lstat3);
      return;
    }
    settings2.fs.stat(path4, (statError, stat2) => {
      if (statError !== null) {
        if (settings2.throwErrorOnBrokenSymbolicLink) {
          callFailureCallback$2(callback, statError);
          return;
        }
        callSuccessCallback$2(callback, lstat3);
        return;
      }
      if (settings2.markSymbolicLink) {
        stat2.isSymbolicLink = () => true;
      }
      callSuccessCallback$2(callback, stat2);
    });
  });
}
function callFailureCallback$2(callback, error2) {
  callback(error2);
}
function callSuccessCallback$2(callback, result) {
  callback(null, result);
}
function read$2(path4, settings2) {
  const lstat3 = settings2.fs.lstatSync(path4);
  if (!lstat3.isSymbolicLink() || !settings2.followSymbolicLink) {
    return lstat3;
  }
  try {
    const stat2 = settings2.fs.statSync(path4);
    if (settings2.markSymbolicLink) {
      stat2.isSymbolicLink = () => true;
    }
    return stat2;
  } catch (error2) {
    if (!settings2.throwErrorOnBrokenSymbolicLink) {
      return lstat3;
    }
    throw error2;
  }
}
function stat$4(path4, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === "function") {
    async$1.read(path4, getSettings$2(), optionsOrSettingsOrCallback);
    return;
  }
  async$1.read(path4, getSettings$2(optionsOrSettingsOrCallback), callback);
}
function statSync(path4, optionsOrSettings) {
  const settings2 = getSettings$2(optionsOrSettings);
  return sync$7.read(path4, settings2);
}
function getSettings$2(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof settings_1$3.default) {
    return settingsOrOptions;
  }
  return new settings_1$3.default(settingsOrOptions);
}
function runParallel(tasks2, cb) {
  let results, pending, keys2;
  let isSync = true;
  if (Array.isArray(tasks2)) {
    results = [];
    pending = tasks2.length;
  } else {
    keys2 = Object.keys(tasks2);
    results = {};
    pending = keys2.length;
  }
  function done(err) {
    function end() {
      if (cb)
        cb(err, results);
      cb = null;
    }
    if (isSync)
      queueMicrotask$1(end);
    else
      end();
  }
  function each(i, err, result) {
    results[i] = result;
    if (--pending === 0 || err) {
      done(err);
    }
  }
  if (!pending) {
    done(null);
  } else if (keys2) {
    keys2.forEach(function(key) {
      tasks2[key](function(err, result) {
        each(key, err, result);
      });
    });
  } else {
    tasks2.forEach(function(task, i) {
      task(function(err, result) {
        each(i, err, result);
      });
    });
  }
  isSync = false;
}
function createDirentFromStats(name2, stats) {
  return new DirentFromStats2(name2, stats);
}
function joinPathSegments$1(a, b, separator) {
  if (a.endsWith(separator)) {
    return a + b;
  }
  return a + separator + b;
}
function read$1(directory, settings2, callback) {
  if (!settings2.stats && constants_1$1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
    readdirWithFileTypes$1(directory, settings2, callback);
    return;
  }
  readdir$3(directory, settings2, callback);
}
function readdirWithFileTypes$1(directory, settings2, callback) {
  settings2.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
    if (readdirError !== null) {
      callFailureCallback$1(callback, readdirError);
      return;
    }
    const entries = dirents.map((dirent) => ({
      dirent,
      name: dirent.name,
      path: common$9.joinPathSegments(directory, dirent.name, settings2.pathSegmentSeparator)
    }));
    if (!settings2.followSymbolicLinks) {
      callSuccessCallback$1(callback, entries);
      return;
    }
    const tasks2 = entries.map((entry2) => makeRplTaskEntry(entry2, settings2));
    rpl(tasks2, (rplError, rplEntries) => {
      if (rplError !== null) {
        callFailureCallback$1(callback, rplError);
        return;
      }
      callSuccessCallback$1(callback, rplEntries);
    });
  });
}
function makeRplTaskEntry(entry2, settings2) {
  return (done) => {
    if (!entry2.dirent.isSymbolicLink()) {
      done(null, entry2);
      return;
    }
    settings2.fs.stat(entry2.path, (statError, stats) => {
      if (statError !== null) {
        if (settings2.throwErrorOnBrokenSymbolicLink) {
          done(statError);
          return;
        }
        done(null, entry2);
        return;
      }
      entry2.dirent = utils$8.fs.createDirentFromStats(entry2.name, stats);
      done(null, entry2);
    });
  };
}
function readdir$3(directory, settings2, callback) {
  settings2.fs.readdir(directory, (readdirError, names) => {
    if (readdirError !== null) {
      callFailureCallback$1(callback, readdirError);
      return;
    }
    const tasks2 = names.map((name2) => {
      const path4 = common$9.joinPathSegments(directory, name2, settings2.pathSegmentSeparator);
      return (done) => {
        fsStat$5.stat(path4, settings2.fsStatSettings, (error2, stats) => {
          if (error2 !== null) {
            done(error2);
            return;
          }
          const entry2 = {
            name: name2,
            path: path4,
            dirent: utils$8.fs.createDirentFromStats(name2, stats)
          };
          if (settings2.stats) {
            entry2.stats = stats;
          }
          done(null, entry2);
        });
      };
    });
    rpl(tasks2, (rplError, entries) => {
      if (rplError !== null) {
        callFailureCallback$1(callback, rplError);
        return;
      }
      callSuccessCallback$1(callback, entries);
    });
  });
}
function callFailureCallback$1(callback, error2) {
  callback(error2);
}
function callSuccessCallback$1(callback, result) {
  callback(null, result);
}
function read(directory, settings2) {
  if (!settings2.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
    return readdirWithFileTypes(directory, settings2);
  }
  return readdir$2(directory, settings2);
}
function readdirWithFileTypes(directory, settings2) {
  const dirents = settings2.fs.readdirSync(directory, { withFileTypes: true });
  return dirents.map((dirent) => {
    const entry2 = {
      dirent,
      name: dirent.name,
      path: common$8.joinPathSegments(directory, dirent.name, settings2.pathSegmentSeparator)
    };
    if (entry2.dirent.isSymbolicLink() && settings2.followSymbolicLinks) {
      try {
        const stats = settings2.fs.statSync(entry2.path);
        entry2.dirent = utils$7.fs.createDirentFromStats(entry2.name, stats);
      } catch (error2) {
        if (settings2.throwErrorOnBrokenSymbolicLink) {
          throw error2;
        }
      }
    }
    return entry2;
  });
}
function readdir$2(directory, settings2) {
  const names = settings2.fs.readdirSync(directory);
  return names.map((name2) => {
    const entryPath = common$8.joinPathSegments(directory, name2, settings2.pathSegmentSeparator);
    const stats = fsStat$4.statSync(entryPath, settings2.fsStatSettings);
    const entry2 = {
      name: name2,
      path: entryPath,
      dirent: utils$7.fs.createDirentFromStats(name2, stats)
    };
    if (settings2.stats) {
      entry2.stats = stats;
    }
    return entry2;
  });
}
function scandir(path4, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === "function") {
    async.read(path4, getSettings$1(), optionsOrSettingsOrCallback);
    return;
  }
  async.read(path4, getSettings$1(optionsOrSettingsOrCallback), callback);
}
function scandirSync(path4, optionsOrSettings) {
  const settings2 = getSettings$1(optionsOrSettings);
  return sync$5.read(path4, settings2);
}
function getSettings$1(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof settings_1$2.default) {
    return settingsOrOptions;
  }
  return new settings_1$2.default(settingsOrOptions);
}
function reusify$1(Constructor) {
  var head = new Constructor();
  var tail = head;
  function get2() {
    var current3 = head;
    if (current3.next) {
      head = current3.next;
    } else {
      head = new Constructor();
      tail = head;
    }
    current3.next = null;
    return current3;
  }
  function release(obj) {
    tail.next = obj;
    tail = obj;
  }
  return {
    get: get2,
    release
  };
}
function fastqueue(context, worker, concurrency) {
  if (typeof context === "function") {
    concurrency = worker;
    worker = context;
    context = null;
  }
  if (concurrency < 1) {
    throw new Error("fastqueue concurrency must be greater than 1");
  }
  var cache = reusify(Task);
  var queueHead = null;
  var queueTail = null;
  var _running = 0;
  var errorHandler = null;
  var self2 = {
    push: push2,
    drain: noop$3,
    saturated: noop$3,
    pause,
    paused: false,
    concurrency,
    running,
    resume: resume2,
    idle,
    length,
    getQueue,
    unshift,
    empty: noop$3,
    kill,
    killAndDrain,
    error: error2
  };
  return self2;
  function running() {
    return _running;
  }
  function pause() {
    self2.paused = true;
  }
  function length() {
    var current3 = queueHead;
    var counter = 0;
    while (current3) {
      current3 = current3.next;
      counter++;
    }
    return counter;
  }
  function getQueue() {
    var current3 = queueHead;
    var tasks2 = [];
    while (current3) {
      tasks2.push(current3.value);
      current3 = current3.next;
    }
    return tasks2;
  }
  function resume2() {
    if (!self2.paused)
      return;
    self2.paused = false;
    for (var i = 0; i < self2.concurrency; i++) {
      _running++;
      release();
    }
  }
  function idle() {
    return _running === 0 && self2.length() === 0;
  }
  function push2(value2, done) {
    var current3 = cache.get();
    current3.context = context;
    current3.release = release;
    current3.value = value2;
    current3.callback = done || noop$3;
    current3.errorHandler = errorHandler;
    if (_running === self2.concurrency || self2.paused) {
      if (queueTail) {
        queueTail.next = current3;
        queueTail = current3;
      } else {
        queueHead = current3;
        queueTail = current3;
        self2.saturated();
      }
    } else {
      _running++;
      worker.call(context, current3.value, current3.worked);
    }
  }
  function unshift(value2, done) {
    var current3 = cache.get();
    current3.context = context;
    current3.release = release;
    current3.value = value2;
    current3.callback = done || noop$3;
    if (_running === self2.concurrency || self2.paused) {
      if (queueHead) {
        current3.next = queueHead;
        queueHead = current3;
      } else {
        queueHead = current3;
        queueTail = current3;
        self2.saturated();
      }
    } else {
      _running++;
      worker.call(context, current3.value, current3.worked);
    }
  }
  function release(holder) {
    if (holder) {
      cache.release(holder);
    }
    var next = queueHead;
    if (next) {
      if (!self2.paused) {
        if (queueTail === queueHead) {
          queueTail = null;
        }
        queueHead = next.next;
        next.next = null;
        worker.call(context, next.value, next.worked);
        if (queueTail === null) {
          self2.empty();
        }
      } else {
        _running--;
      }
    } else if (--_running === 0) {
      self2.drain();
    }
  }
  function kill() {
    queueHead = null;
    queueTail = null;
    self2.drain = noop$3;
  }
  function killAndDrain() {
    queueHead = null;
    queueTail = null;
    self2.drain();
    self2.drain = noop$3;
  }
  function error2(handler) {
    errorHandler = handler;
  }
}
function noop$3() {
}
function Task() {
  this.value = null;
  this.callback = noop$3;
  this.next = null;
  this.release = noop$3;
  this.context = null;
  this.errorHandler = null;
  var self2 = this;
  this.worked = function worked(err, result) {
    var callback = self2.callback;
    var errorHandler = self2.errorHandler;
    var val = self2.value;
    self2.value = null;
    self2.callback = noop$3;
    if (self2.errorHandler) {
      errorHandler(err, val);
    }
    callback.call(self2.context, err, result);
    self2.release(self2);
  };
}
function queueAsPromised(context, worker, concurrency) {
  if (typeof context === "function") {
    concurrency = worker;
    worker = context;
    context = null;
  }
  function asyncWrapper(arg, cb) {
    worker.call(this, arg).then(function(res) {
      cb(null, res);
    }, cb);
  }
  var queue2 = fastqueue(context, asyncWrapper, concurrency);
  var pushCb = queue2.push;
  var unshiftCb = queue2.unshift;
  queue2.push = push2;
  queue2.unshift = unshift;
  queue2.drained = drained;
  return queue2;
  function push2(value2) {
    var p = new Promise(function(resolve5, reject) {
      pushCb(value2, function(err, result) {
        if (err) {
          reject(err);
          return;
        }
        resolve5(result);
      });
    });
    p.catch(noop$3);
    return p;
  }
  function unshift(value2) {
    var p = new Promise(function(resolve5, reject) {
      unshiftCb(value2, function(err, result) {
        if (err) {
          reject(err);
          return;
        }
        resolve5(result);
      });
    });
    p.catch(noop$3);
    return p;
  }
  function drained() {
    var previousDrain = queue2.drain;
    var p = new Promise(function(resolve5) {
      queue2.drain = function() {
        previousDrain();
        resolve5();
      };
    });
    return p;
  }
}
function isFatalError(settings2, error2) {
  if (settings2.errorFilter === null) {
    return true;
  }
  return !settings2.errorFilter(error2);
}
function isAppliedFilter(filter2, value2) {
  return filter2 === null || filter2(value2);
}
function replacePathSegmentSeparator(filepath, separator) {
  return filepath.split(/[/\\]/).join(separator);
}
function joinPathSegments(a, b, separator) {
  if (a === "") {
    return b;
  }
  if (a.endsWith(separator)) {
    return a + b;
  }
  return a + separator + b;
}
function callFailureCallback(callback, error2) {
  callback(error2);
}
function callSuccessCallback(callback, entries) {
  callback(null, entries);
}
function walk$2(directory, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === "function") {
    new async_1$2.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
    return;
  }
  new async_1$2.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
}
function walkSync(directory, optionsOrSettings) {
  const settings2 = getSettings(optionsOrSettings);
  const provider2 = new sync_1$2.default(directory, settings2);
  return provider2.read();
}
function walkStream(directory, optionsOrSettings) {
  const settings2 = getSettings(optionsOrSettings);
  const provider2 = new stream_1$4.default(directory, settings2);
  return provider2.read();
}
function getSettings(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof settings_1$1.default) {
    return settingsOrOptions;
  }
  return new settings_1$1.default(settingsOrOptions);
}
async function FastGlob(source, options2) {
  assertPatternsInput(source);
  const works = getWorks(source, async_1.default, options2);
  const result = await Promise.all(works);
  return utils2.array.flatten(result);
}
function getWorks(source, _Provider, options2) {
  const patterns2 = patternManager.transform([].concat(source));
  const settings2 = new settings_1.default(options2);
  const tasks2 = taskManager.generate(patterns2, settings2);
  const provider2 = new _Provider(settings2);
  return tasks2.map(provider2.read, provider2);
}
function assertPatternsInput(input) {
  const source = [].concat(input);
  const isValidSource = source.every((item) => utils2.string.isString(item) && !utils2.string.isEmpty(item));
  if (!isValidSource) {
    throw new TypeError("Patterns must be a string (non empty) or an array of strings");
  }
}
function isCollection$1(node2) {
  if (node2 && typeof node2 === "object")
    switch (node2[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode$1(node2) {
  if (node2 && typeof node2 === "object")
    switch (node2[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR$1:
      case SEQ:
        return true;
    }
  return false;
}
function visit$1(node2, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node2)) {
    const cd = visit_(null, node2.contents, visitor_, Object.freeze([node2]));
    if (cd === REMOVE$1)
      node2.contents = null;
  } else
    visit_(null, node2, visitor_, Object.freeze([]));
}
function visit_(key, node2, visitor, path4) {
  const ctrl = callVisitor(key, node2, visitor, path4);
  if (isNode$1(ctrl) || isPair(ctrl)) {
    replaceNode(key, path4, ctrl);
    return visit_(key, ctrl, visitor, path4);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection$1(node2)) {
      path4 = Object.freeze(path4.concat(node2));
      for (let i = 0; i < node2.items.length; ++i) {
        const ci = visit_(i, node2.items[i], visitor, path4);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK$1)
          return BREAK$1;
        else if (ci === REMOVE$1) {
          node2.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node2)) {
      path4 = Object.freeze(path4.concat(node2));
      const ck = visit_("key", node2.key, visitor, path4);
      if (ck === BREAK$1)
        return BREAK$1;
      else if (ck === REMOVE$1)
        node2.key = null;
      const cv = visit_("value", node2.value, visitor, path4);
      if (cv === BREAK$1)
        return BREAK$1;
      else if (cv === REMOVE$1)
        node2.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node2, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node2)) {
    const cd = await visitAsync_(null, node2.contents, visitor_, Object.freeze([node2]));
    if (cd === REMOVE$1)
      node2.contents = null;
  } else
    await visitAsync_(null, node2, visitor_, Object.freeze([]));
}
async function visitAsync_(key, node2, visitor, path4) {
  const ctrl = await callVisitor(key, node2, visitor, path4);
  if (isNode$1(ctrl) || isPair(ctrl)) {
    replaceNode(key, path4, ctrl);
    return visitAsync_(key, ctrl, visitor, path4);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection$1(node2)) {
      path4 = Object.freeze(path4.concat(node2));
      for (let i = 0; i < node2.items.length; ++i) {
        const ci = await visitAsync_(i, node2.items[i], visitor, path4);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK$1)
          return BREAK$1;
        else if (ci === REMOVE$1) {
          node2.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node2)) {
      path4 = Object.freeze(path4.concat(node2));
      const ck = await visitAsync_("key", node2.key, visitor, path4);
      if (ck === BREAK$1)
        return BREAK$1;
      else if (ck === REMOVE$1)
        node2.key = null;
      const cv = await visitAsync_("value", node2.value, visitor, path4);
      if (cv === BREAK$1)
        return BREAK$1;
      else if (cv === REMOVE$1)
        node2.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node2, visitor, path4) {
  if (typeof visitor === "function")
    return visitor(key, node2, path4);
  if (isMap(node2))
    return visitor.Map?.(key, node2, path4);
  if (isSeq(node2))
    return visitor.Seq?.(key, node2, path4);
  if (isPair(node2))
    return visitor.Pair?.(key, node2, path4);
  if (isScalar$1(node2))
    return visitor.Scalar?.(key, node2, path4);
  if (isAlias(node2))
    return visitor.Alias?.(key, node2, path4);
  return void 0;
}
function replaceNode(key, path4, node2) {
  const parent = path4[path4.length - 1];
  if (isCollection$1(parent)) {
    parent.items[key] = node2;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node2;
    else
      parent.value = node2;
  } else if (isDocument(parent)) {
    parent.contents = node2;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit$1(root, {
    Value(_key, node2) {
      if (node2.anchor)
        anchors.add(node2.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name2 = `${prefix}${i}`;
    if (!exclude.has(name2))
      return name2;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref3 = sourceObjects.get(source);
        if (typeof ref3 === "object" && ref3.anchor && (isScalar$1(ref3.node) || isCollection$1(ref3.node))) {
          ref3.node.anchor = ref3.anchor;
        } else {
          const error2 = new Error("Failed to resolve repeated object (this should not happen)");
          error2.source = source;
          throw error2;
        }
      }
    },
    sourceObjects
  };
}
function getAliasCount(doc, node2, anchors) {
  if (isAlias(node2)) {
    const source = node2.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection$1(node2)) {
    let count = 0;
    for (const item of node2.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node2)) {
    const kc = getAliasCount(doc, node2.key, anchors);
    const vc = getAliasCount(doc, node2.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
function toJS(value2, arg, ctx) {
  if (Array.isArray(value2))
    return value2.map((v, i) => toJS(v, String(i), ctx));
  if (value2 && typeof value2.toJSON === "function") {
    if (!ctx || !hasAnchor(value2))
      return value2.toJSON(arg, ctx);
    const data3 = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value2, data3);
    ctx.onCreate = (res2) => {
      data3.res = res2;
      delete ctx.onCreate;
    };
    const res = value2.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value2 === "bigint" && !ctx?.keep)
    return Number(value2);
  return value2;
}
function findTagObject(value2, tagName, tags) {
  if (tagName) {
    const match = tags.filter((t) => t.tag === tagName);
    const tagObj = match.find((t) => !t.format) ?? match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => t.identify?.(value2) && !t.format);
}
function createNode(value2, tagName, ctx) {
  if (isDocument(value2))
    value2 = value2.contents;
  if (isNode$1(value2))
    return value2;
  if (isPair(value2)) {
    const map2 = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
    map2.items.push(value2);
    return map2;
  }
  if (value2 instanceof String || value2 instanceof Number || value2 instanceof Boolean || typeof BigInt === "function" && value2 instanceof BigInt) {
    value2 = value2.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema2, sourceObjects } = ctx;
  let ref3 = void 0;
  if (aliasDuplicateObjects && value2 && typeof value2 === "object") {
    ref3 = sourceObjects.get(value2);
    if (ref3) {
      if (!ref3.anchor)
        ref3.anchor = onAnchor(value2);
      return new Alias(ref3.anchor);
    } else {
      ref3 = { anchor: null, node: null };
      sourceObjects.set(value2, ref3);
    }
  }
  if (tagName?.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value2, tagName, schema2.tags);
  if (!tagObj) {
    if (value2 && typeof value2.toJSON === "function") {
      value2 = value2.toJSON();
    }
    if (!value2 || typeof value2 !== "object") {
      const node3 = new Scalar(value2);
      if (ref3)
        ref3.node = node3;
      return node3;
    }
    tagObj = value2 instanceof Map ? schema2[MAP] : Symbol.iterator in Object(value2) ? schema2[SEQ] : schema2[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node2 = tagObj?.createNode ? tagObj.createNode(ctx.schema, value2, ctx) : new Scalar(value2);
  if (tagName)
    node2.tag = tagName;
  if (ref3)
    ref3.node = node2;
  return node2;
}
function collectionFromPath(schema2, path4, value2) {
  let v = value2;
  for (let i = path4.length - 1; i >= 0; --i) {
    const k = path4[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema2,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
function foldFlowLines(text, indent, mode2 = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode2 === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode2 === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode2 === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i);
      end = i + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode2 === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode2 === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i) {
  let ch = text[i + 1];
  while (ch === " " || ch === "	") {
    do {
      ch = text[i += 1];
    } while (ch && ch !== "\n");
    ch = text[i + 1];
  }
  return i;
}
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value2, ctx) {
  const json = JSON.stringify(value2);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value2) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value2, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value2.includes("\n") || /[ \t]\n|\n[ \t]/.test(value2))
    return doubleQuotedString(value2, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value2) ? "  " : "");
  const res = "'" + value2.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function quotedString(value2, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value2.includes('"');
    const hasSingle = value2.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value2, ctx);
}
function blockString({ comment, type, value: value2 }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value2) || /^\s*$/.test(value2)) {
    return quotedString(value2, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value2) ? "  " : "");
  const literal3 = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value2, lineWidth, indent.length);
  if (!value2)
    return literal3 ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value2.length; endStart > 0; --endStart) {
    const ch = value2[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value2.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value2 === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value2 = value2.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value2.length; ++startEnd) {
    const ch = value2[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value2.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value2 = value2.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal3 ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal3) {
    value2 = value2.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start}${value2}${end}`;
  }
  value2 = value2.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start}${value2}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value: value2 } = item;
  const { actualString, implicitKey, indent, inFlow } = ctx;
  if (implicitKey && /[\n[\]{},]/.test(value2) || inFlow && /[[\]{},]/.test(value2)) {
    return quotedString(value2, ctx);
  }
  if (!value2 || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value2)) {
    return implicitKey || inFlow || !value2.includes("\n") ? quotedString(value2, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value2.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (indent === "" && containsDocumentMarker(value2)) {
    ctx.forceBlockIndent = true;
    return blockString(item, ctx, onComment, onChompKeep);
  }
  const str = value2.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || compat?.some(test))
      return quotedString(value2, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}
function createStringifyContext(doc, options2) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options2);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  if (item.tag) {
    const match = tags.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return match.find((t) => t.format === item.format) ?? match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar$1(item)) {
    obj = item.value;
    const match = tags.filter((t) => t.identify?.(obj));
    tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name2 = obj?.constructor?.name ?? typeof obj;
    throw new Error(`Tag not resolved for ${name2} value`);
  }
  return tagObj;
}
function stringifyProps(node2, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar$1(node2) || isCollection$1(node2)) && node2.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node2.tag ? node2.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify$2(item, ctx, onComment, onChompKeep) {
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if (ctx.resolvedAliases?.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node2 = isNode$1(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node2);
  const props = stringifyProps(node2, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node2, ctx, onComment, onChompKeep) : isScalar$1(node2) ? stringifyString(node2, ctx, onComment, onChompKeep) : node2.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar$1(node2) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}
function stringifyPair({ key, value: value2 }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode$1(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection$1(key)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value2 == null && !ctx.inFlow || isCollection$1(key) || (isScalar$1(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify$2(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value2 == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value2 == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vcb = "";
  let valueComment = null;
  if (isNode$1(value2)) {
    if (value2.spaceBefore)
      vcb = "\n";
    if (value2.commentBefore) {
      const cs = commentString(value2.commentBefore);
      vcb += `
${indentComment(cs, ctx.indent)}`;
    }
    valueComment = value2.comment;
  } else if (value2 && typeof value2 === "object") {
    value2 = doc.createNode(value2);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar$1(value2))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value2) && !value2.flow && !value2.tag && !value2.anchor) {
    ctx.indent = ctx.indent.substr(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify$2(value2, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (vcb || keyComment) {
    if (valueStr === "" && !ctx.inFlow)
      ws = vcb === "\n" ? "\n\n" : vcb;
    else
      ws = `${vcb}
${ctx.indent}`;
  } else if (!explicitKey && isCollection$1(value2)) {
    const flow = valueStr[0] === "[" || valueStr[0] === "{";
    if (!flow || valueStr.includes("\n"))
      ws = `
${ctx.indent}`;
  } else if (valueStr === "" || valueStr[0] === "\n")
    ws = "";
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}
function addPairToJSMap(ctx, map2, { key, value: value2 }) {
  if (ctx?.doc.schema.merge && isMergeKey(key)) {
    value2 = isAlias(value2) ? value2.resolve(ctx.doc) : value2;
    if (isSeq(value2))
      for (const it of value2.items)
        mergeToJSMap(ctx, map2, it);
    else if (Array.isArray(value2))
      for (const it of value2)
        mergeToJSMap(ctx, map2, it);
    else
      mergeToJSMap(ctx, map2, value2);
  } else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value2, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value2, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
function mergeToJSMap(ctx, map2, value2) {
  const source = ctx && isAlias(value2) ? value2.resolve(ctx.doc) : value2;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value3] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value3);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value3,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode$1(key) && ctx && ctx.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node2 of ctx.anchors.keys())
      strCtx.anchors.add(node2.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
function createPair(key, value2, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value2, void 0, ctx);
  return new Pair(k, v);
}
function stringifyCollection(collection, ctx, options2) {
  const flow = ctx.inFlow ?? collection.flow;
  const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify2(collection, ctx, options2);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode$1(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode$1(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify$2(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
  const { indent, indentStep, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode$1(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode$1(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode$1(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik && ik.comment) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str2 = stringify$2(item, itemCtx, () => comment2 = null);
    if (i < items.length - 1)
      str2 += ",";
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
      reqNewline = true;
    lines.push(str2);
    linesAtValue = lines.length;
  }
  let str;
  const { start, end } = flowChars;
  if (lines.length === 0) {
    str = start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = len > Collection.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      str += `
${indent}${end}`;
    } else {
      str = `${start} ${lines.join(" ")} ${end}`;
    }
  }
  if (comment) {
    str += lineComment(str, commentString(comment), indent);
    if (onComment)
      onComment();
  }
  return str;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}
function findPair(items, key) {
  const k = isScalar$1(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar$1(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
function createMap(schema2, obj, ctx) {
  const { keepUndefined, replacer } = ctx;
  const map2 = new YAMLMap(schema2);
  const add = (key, value2) => {
    if (typeof replacer === "function")
      value2 = replacer.call(obj, key, value2);
    else if (Array.isArray(replacer) && !replacer.includes(key))
      return;
    if (value2 !== void 0 || keepUndefined)
      map2.items.push(createPair(key, value2, ctx));
  };
  if (obj instanceof Map) {
    for (const [key, value2] of obj)
      add(key, value2);
  } else if (obj && typeof obj === "object") {
    for (const key of Object.keys(obj))
      add(key, obj[key]);
  }
  if (typeof schema2.sortMapEntries === "function") {
    map2.items.sort(schema2.sortMapEntries);
  }
  return map2;
}
function asItemIndex(key) {
  let idx = isScalar$1(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
function createSeq(schema2, obj, ctx) {
  const { replacer } = ctx;
  const seq2 = new YAMLSeq(schema2);
  if (obj && Symbol.iterator in Object(obj)) {
    let i = 0;
    for (let it of obj) {
      if (typeof replacer === "function") {
        const key = obj instanceof Set ? it : String(i++);
        it = replacer.call(obj, key, it);
      }
      seq2.items.push(createNode(it, void 0, ctx));
    }
  }
  return seq2;
}
function stringifyNumber({ format: format2, minFractionDigits, tag, value: value2 }) {
  if (typeof value2 === "bigint")
    return String(value2);
  const num = typeof value2 === "number" ? value2 : Number(value2);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n2 = JSON.stringify(value2);
  if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n2)) {
    let i = n2.indexOf(".");
    if (i < 0) {
      i = n2.length;
      n2 += ".";
    }
    let d = minFractionDigits - (n2.length - i - 1);
    while (d-- > 0)
      n2 += "0";
  }
  return n2;
}
function intStringify$1(node2, radix, prefix) {
  const { value: value2 } = node2;
  if (intIdentify$2(value2) && value2 >= 0)
    return prefix + value2.toString(radix);
  return stringifyNumber(node2);
}
function intIdentify$1(value2) {
  return typeof value2 === "bigint" || Number.isInteger(value2);
}
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value ?? pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema2, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema2);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value2;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value2 = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys2 = Object.keys(it);
        if (keys2.length === 1) {
          key = keys2[0];
          value2 = it[key];
        } else
          throw new TypeError(`Expected { key: value } tuple: ${it}`);
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value2, ctx));
    }
  return pairs2;
}
function boolStringify({ value: value2, source }, ctx) {
  const boolObj = value2 ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value2 ? ctx.options.trueStr : ctx.options.falseStr;
}
function intResolve(str, offset4, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset4 += 1;
  str = str.substring(offset4).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n3 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n3 : n3;
  }
  const n2 = parseInt(str, radix);
  return sign === "-" ? -1 * n2 : n2;
}
function intStringify(node2, radix, prefix) {
  const { value: value2 } = node2;
  if (intIdentify(value2)) {
    const str = value2.toString(radix);
    return value2 < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node2);
}
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n2) => asBigInt ? BigInt(n2) : Number(n2);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node2) {
  let { value: value2 } = node2;
  let num = (n2) => n2;
  if (typeof value2 === "bigint")
    num = (n2) => BigInt(n2);
  else if (isNaN(value2) || !isFinite(value2))
    return stringifyNumber(node2);
  let sign = "";
  if (value2 < 0) {
    sign = "-";
    value2 *= num(-1);
  }
  const _60 = num(60);
  const parts = [value2 % _60];
  if (value2 < 60) {
    parts.unshift(0);
  } else {
    value2 = (value2 - parts[0]) / _60;
    parts.unshift(value2 % _60);
    if (value2 >= 60) {
      value2 = (value2 - parts[0]) / _60;
      parts.unshift(value2);
    }
  }
  return sign + parts.map((n2) => n2 < 10 ? "0" + String(n2) : String(n2)).join(":").replace(/000000\d*$/, "");
}
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys2 = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys2} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag) => {
    if (typeof tag !== "string")
      return tag;
    const tagObj = tagsByName[tag];
    if (tagObj)
      return tagObj;
    const keys2 = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag}"; use one of ${keys2}`);
  });
}
function stringifyDocument(doc, options2) {
  const lines = [];
  let hasDirectives = options2.directives === true;
  if (options2.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options2);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode$1(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify$2(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify$2(doc.contents, ctx));
  }
  if (doc.directives?.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}
function assertCollection(contents) {
  if (isCollection$1(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
function resolveProps(tokens, { flow, indicator, next, offset: offset4, onError, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let hasNewlineAfterProp = false;
  let reqSpace = false;
  let anchor = null;
  let tag = null;
  let comma4 = null;
  let found2 = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    switch (token.type) {
      case "space":
        if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
          onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          hasNewlineAfterProp = true;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found2)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
        found2 = token;
        atNewline = false;
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma4)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma4 = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset4;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  return {
    comma: comma4,
    found: found2,
    spaceBefore,
    comment,
    hasNewline,
    hasNewlineAfterProp,
    anchor,
    tag,
    end,
    start: start ?? end
  };
}
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
function flowIndentCheck(indent, fc, onError) {
  if (fc?.type === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar$1(a) && isScalar$1(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError) {
  const map2 = new YAMLMap(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset4 = bm.offset;
  for (const collItem of bm.items) {
    const { start, key, sep: sep2, value: value2 } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key ?? sep2?.[0],
      offset: offset4,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset4, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset4, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep2) {
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.hasNewlineAfterProp || containsNewline(key)) {
        onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (keyProps.found?.indent !== bm.indent) {
      onError(offset4, "BAD_INDENT", startColMsg);
    }
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep2 ?? [], {
      indicator: "map-value-ind",
      next: value2,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset4 = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if (value2?.type === "block-map" && !valueProps.hasNewline)
          onError(offset4, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value2 ? composeNode2(ctx, value2, valueProps, onError) : composeEmptyNode2(ctx, offset4, sep2, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value2, onError);
      offset4 = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  map2.range = [bm.offset, offset4, offset4];
  return map2;
}
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError) {
  const seq2 = new YAMLSeq(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset4 = bs.offset;
  for (const { start, value: value2 } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value2,
      offset: offset4,
      onError,
      startOnNewline: true
    });
    offset4 = props.end;
    if (!props.found) {
      if (props.anchor || props.tag || value2) {
        if (value2 && value2.type === "block-seq")
          onError(offset4, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset4, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node2 = value2 ? composeNode2(ctx, value2, props, onError) : composeEmptyNode2(ctx, offset4, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value2, onError);
    offset4 = node2.range[2];
    seq2.items.push(node2);
  }
  seq2.range = [bs.offset, offset4, offset4];
  return seq2;
}
function resolveEnd(end, offset4, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep2 = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep2 + cb;
          sep2 = "";
          break;
        }
        case "newline":
          if (comment)
            sep2 += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset4 += source.length;
    }
  }
  return { comment, offset: offset4 };
}
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const coll = isMap2 ? new YAMLMap(ctx.schema) : new YAMLSeq(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  let offset4 = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep: sep2, value: value2 } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? sep2?.[0],
      offset: offset4,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep2 && !value2) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset4 = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value ?? prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep2 && !props.found) {
      const valueNode = value2 ? composeNode2(ctx, value2, props, onError) : composeEmptyNode2(ctx, props.end, sep2, null, props, onError);
      coll.items.push(valueNode);
      offset4 = valueNode.range[2];
      if (isBlock(value2))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep2 ?? [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value2,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep2)
            for (const st of sep2) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value2) {
        if ("source" in value2 && value2.source && value2.source[0] === ":")
          onError(value2, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value2 ? composeNode2(ctx, value2, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep2, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value2))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        coll.items.push(map2);
      }
      offset4 = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset4;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name2 = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name2} must end with a ${expectedEnd}` : `${name2} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset4, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
function composeCollection(CN2, ctx, token, tagToken, onError) {
  let coll;
  switch (token.type) {
    case "block-map": {
      coll = resolveBlockMap(CN2, ctx, token, onError);
      break;
    }
    case "block-seq": {
      coll = resolveBlockSeq(CN2, ctx, token, onError);
      break;
    }
    case "flow-collection": {
      coll = resolveFlowCollection(CN2, ctx, token, onError);
      break;
    }
  }
  if (!tagToken)
    return coll;
  const tagName = ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (!tagName)
    return coll;
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  const expType = isMap(coll) ? "map" : "seq";
  let tag = ctx.schema.tags.find((t) => t.collection === expType && t.tag === tagName);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      coll.tag = tagName;
      return coll;
    }
  }
  const res = tag.resolve(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options);
  const node2 = isNode$1(res) ? res : new Scalar(res);
  node2.range = coll.range;
  node2.tag = tagName;
  if (tag?.format)
    node2.format = tag.format;
  return node2;
}
function resolveBlockScalar(scalar, strict, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value3 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value3, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset4 = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset4 + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      break;
    }
    offset4 += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value2 = "";
  let sep2 = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value2 += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset4 += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src2 = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src2}`;
      onError(offset4 - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value2 += sep2 + indent.slice(trimIndent) + content;
      sep2 = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep2 === " ")
        sep2 = "\n";
      else if (!prevMoreIndented && sep2 === "\n")
        sep2 = "\n\n";
      value2 += sep2 + indent.slice(trimIndent) + content;
      sep2 = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep2 === "\n")
        value2 += "\n";
      else
        sep2 = "\n";
    } else {
      value2 += sep2 + content;
      sep2 = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value2 += "\n" + lines[i][0].slice(trimIndent);
      if (value2[value2.length - 1] !== "\n")
        value2 += "\n";
      break;
    default:
      value2 += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value: value2, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset: offset4, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode2 = source[0];
  let indent = 0;
  let chomp = "";
  let error2 = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n2 = Number(ch);
      if (!indent && n2)
        indent = n2;
      else if (error2 === -1)
        error2 = offset4 + i;
    }
  }
  if (error2 !== -1)
    onError(error2, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode: mode2, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first2 = split[0];
  const m = first2.match(/^( *)/);
  const line0 = m?.[1] ? [m[1], first2.slice(m[1].length)] : ["", first2];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}
function resolveFlowScalar(scalar, strict, onError) {
  const { offset: offset4, type, source, end } = scalar;
  let _type;
  let value2;
  const _onError = (rel, code, msg) => onError(offset4 + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value2 = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value2 = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value2 = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset4, offset4 + source.length, offset4 + source.length]
      };
  }
  const valueEnd = offset4 + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value: value2,
    type: _type,
    comment: re.comment,
    range: [offset4, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  let first2, line;
  try {
    first2 = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_) {
    first2 = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first2.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep2 = " ";
  let pos = first2.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep2 === "\n")
        res += sep2;
      else
        sep2 = "\n";
    } else {
      res += sep2 + match[1];
      sep2 = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep2 + (match?.[1] ?? "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset: offset4 } = foldNewline(source, i);
      res += fold;
      i = offset4;
    } else if (ch === "\\") {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "\r" && source[i + 1] === "\n") {
        next = source[++i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i + 1, length, onError);
        i += length;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source[i + 1];
      while (next === " " || next === "	")
        next = source[++i + 1];
      if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset4) {
  let fold = "";
  let ch = source[offset4 + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset4 + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset4 += 1;
    ch = source[offset4 + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset: offset4 };
}
function parseCharCode(source, offset4, length, onError) {
  const cc = source.substr(offset4, length);
  const ok2 = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok2 ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset4 - 2, length + 2);
    onError(offset4 - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}
function composeScalar(ctx, token, tagToken, onError) {
  const { value: value2, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value2, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value2, token, onError) : ctx.schema[SCALAR$1];
  let scalar;
  try {
    const res = tag.resolve(value2, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar$1(res) ? res : new Scalar(res);
  } catch (error2) {
    const msg = error2 instanceof Error ? error2.message : String(error2);
    onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value2);
  }
  scalar.range = range;
  scalar.source = value2;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema2, value2, tagName, tagToken, onError) {
  if (tagName === "!")
    return schema2[SCALAR$1];
  const matchWithTest = [];
  for (const tag of schema2.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if (tag.test?.test(value2))
      return tag;
  const kt = schema2.knownTags[tagName];
  if (kt && !kt.collection) {
    schema2.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema2[SCALAR$1];
}
function findScalarTagByTest({ directives, schema: schema2 }, value2, token, onError) {
  const tag = schema2.tags.find((tag2) => tag2.default && tag2.test?.test(value2)) || schema2[SCALAR$1];
  if (schema2.compat) {
    const compat = schema2.compat.find((tag2) => tag2.default && tag2.test?.test(value2)) ?? schema2[SCALAR$1];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}
function emptyScalarPosition(offset4, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset4 -= st.source.length;
          continue;
      }
      st = before[++i];
      while (st?.type === "space") {
        offset4 += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset4;
}
function composeNode(ctx, token, props, onError) {
  const { spaceBefore, comment, anchor, tag } = props;
  let node2;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node2 = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node2 = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node2.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node2 = composeCollection(CN, ctx, token, tag, onError);
      if (anchor)
        node2.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node2 = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node2.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node2.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node2.comment = comment;
    else
      node2.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node2.srcToken = token;
  return node2;
}
function composeEmptyNode(ctx, offset4, before, pos, { spaceBefore, comment, anchor, tag }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset4, before, pos),
    indent: -1,
    source: ""
  };
  const node2 = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node2.anchor = anchor.source.substring(1);
    if (node2.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node2.spaceBefore = true;
  if (comment)
    node2.comment = comment;
  return node2;
}
function composeAlias({ options: options2 }, { offset: offset4, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset4, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset4 + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset4 + source.length;
  const re = resolveEnd(end, valueEnd, options2.strict, onError);
  alias.range = [offset4, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}
function composeDoc(options2, directives, { offset: offset4, start, value: value2, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options2);
  const doc = new Document(void 0, opts);
  const ctx = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value2 ?? end?.[0],
    offset: offset4,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value2 && (value2.type === "block-map" || value2.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value2 ? composeNode(ctx, value2, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset4, contentEnd, re.offset];
  return doc;
}
function getErrorPos(src2) {
  if (typeof src2 === "number")
    return [src2, src2 + 1];
  if (Array.isArray(src2))
    return src2.length === 2 ? src2 : [src2[0], src2[1]];
  const { offset: offset4, source } = src2;
  return [offset4, offset4 + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (prelude[i + 1]?.[0] !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
function resolveAsScalar(token, strict = true, onError) {
  if (token) {
    const _onError = (pos, code, message) => {
      const offset4 = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError)
        onError(offset4, code, message);
      else
        throw new YAMLParseError([offset4, offset4 + 1], code, message);
    };
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar(token, strict, _onError);
    }
  }
  return null;
}
function createScalarToken(value2, context) {
  const { implicitKey = false, indent, inFlow = false, offset: offset4 = -1, type = "PLAIN" } = context;
  const source = stringifyString({ type, value: value2 }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = context.end ?? [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source[0]) {
    case "|":
    case ">": {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset: offset4, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset: offset4, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset: offset4, indent, source, end };
    case "'":
      return { type: "single-quoted-scalar", offset: offset4, indent, source, end };
    default:
      return { type: "scalar", offset: offset4, indent, source, end };
  }
}
function setScalarValue(token, value2, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source = stringifyString({ type, value: value2 }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token, source);
      break;
    case '"':
      setFlowScalarValue(token, source, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token, source, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token, source, "scalar");
  }
}
function setBlockScalarValue(token, source) {
  const he = source.indexOf("\n");
  const head = source.substring(0, he);
  const body = source.substring(he + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token.source = body;
  } else {
    const { offset: offset4 } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset: offset4, indent, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key of Object.keys(token))
      if (key !== "type" && key !== "offset")
        delete token[key];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue(token, source, type) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type;
      token.source = source;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type, source, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset4 = token.offset + source.length;
      const nl = { type: "newline", offset: offset4, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type, source, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type, indent, source, end });
    }
  }
}
function stringifyToken(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem({ start, key, sep: sep2, value: value2 }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key)
    res += stringifyToken(key);
  if (sep2)
    for (const st of sep2)
      res += st.source;
  if (value2)
    res += stringifyToken(value2);
  return res;
}
function visit(cst2, visitor) {
  if ("type" in cst2 && cst2.type === "document")
    cst2 = { start: cst2.start, value: cst2.value };
  _visit(Object.freeze([]), cst2, visitor);
}
function _visit(path4, item, visitor) {
  let ctrl = visitor(item, path4);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit(Object.freeze(path4.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path4);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path4) : ctrl;
}
function prettyToken(token) {
  switch (token) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep ?? it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop:
    while (--i >= 0) {
      switch (prev[i].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (prev[++i]?.type === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
function parseOptions(options2) {
  const prettyErrors = options2.prettyErrors !== false;
  const lineCounter = options2.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseAllDocuments(source, options2 = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options2);
  const parser = new Parser4(lineCounter?.addNewLine);
  const composer = new Composer(options2);
  const docs = Array.from(composer.compose(parser.parse(source)));
  if (prettyErrors && lineCounter)
    for (const doc of docs) {
      doc.errors.forEach(prettifyError(source, lineCounter));
      doc.warnings.forEach(prettifyError(source, lineCounter));
    }
  if (docs.length > 0)
    return docs;
  return Object.assign([], { empty: true }, composer.streamInfo());
}
function parseDocument(source, options2 = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options2);
  const parser = new Parser4(lineCounter?.addNewLine);
  const composer = new Composer(options2);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse$a(src2, reviver, options2) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options2 === void 0 && reviver && typeof reviver === "object") {
    options2 = reviver;
  }
  const doc = parseDocument(src2, options2);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options2));
}
function stringify(value2, replacer, options2) {
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options2 === void 0 && replacer) {
    options2 = replacer;
  }
  if (typeof options2 === "string")
    options2 = options2.length;
  if (typeof options2 === "number") {
    const indent = Math.round(options2);
    options2 = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value2 === void 0) {
    const { keepUndefined } = options2 ?? replacer ?? {};
    if (!keepUndefined)
      return void 0;
  }
  return new Document(value2, _replacer, options2).toString(options2);
}
function req$2(name2, rootFile) {
  const create = createRequire || createRequireFromPath;
  const require3 = create(rootFile);
  return require3(name2);
}
function parse$9(src2) {
  const obj = {};
  let lines = src2.toString();
  lines = lines.replace(/\r\n?/mg, "\n");
  let match;
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1];
    let value2 = match[2] || "";
    value2 = value2.trim();
    const maybeQuote = value2[0];
    value2 = value2.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
    if (maybeQuote === '"') {
      value2 = value2.replace(/\\n/g, "\n");
      value2 = value2.replace(/\\r/g, "\r");
    }
    obj[key] = value2;
  }
  return obj;
}
function _log(message) {
  console.log(`[dotenv@${version3}][DEBUG] ${message}`);
}
function _resolveHome(envPath) {
  return envPath[0] === "~" ? path$9.join(os$2.homedir(), envPath.slice(1)) : envPath;
}
function config(options2) {
  let dotenvPath = path$9.resolve(process.cwd(), ".env");
  let encoding = "utf8";
  const debug2 = Boolean(options2 && options2.debug);
  const override = Boolean(options2 && options2.override);
  if (options2) {
    if (options2.path != null) {
      dotenvPath = _resolveHome(options2.path);
    }
    if (options2.encoding != null) {
      encoding = options2.encoding;
    }
  }
  try {
    const parsed = DotenvModule.parse(fs$9.readFileSync(dotenvPath, { encoding }));
    Object.keys(parsed).forEach(function(key) {
      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
        process.env[key] = parsed[key];
      } else {
        if (override === true) {
          process.env[key] = parsed[key];
        }
        if (debug2) {
          if (override === true) {
            _log(`"${key}" is already defined in \`process.env\` and WAS overwritten`);
          } else {
            _log(`"${key}" is already defined in \`process.env\` and was NOT overwritten`);
          }
        }
      }
    });
    return { parsed };
  } catch (e) {
    if (debug2) {
      _log(`Failed to load ${dotenvPath} ${e.message}`);
    }
    return { error: e };
  }
}
function rewriteCssUrls(css, replacer) {
  return asyncReplace(css, cssUrlRE, async (match) => {
    const [matched, rawUrl] = match;
    return await doUrlReplace(rawUrl.trim(), matched, replacer);
  });
}
function rewriteCssDataUris(css, replacer) {
  return asyncReplace(css, cssDataUriRE, async (match) => {
    const [matched, rawUrl] = match;
    return await doUrlReplace(rawUrl.trim(), matched, replacer, "data-uri");
  });
}
function rewriteImportCss(css, replacer) {
  return asyncReplace(css, importCssRE, async (match) => {
    const [matched, rawUrl] = match;
    return await doImportCSSReplace(rawUrl, matched, replacer);
  });
}
async function rewriteCssImageSet(css, replacer) {
  return await asyncReplace(css, cssImageSetRE, async (match) => {
    const [, rawUrl] = match;
    const url2 = await processSrcSet(rawUrl, async ({ url: url3 }) => {
      if (cssUrlRE.test(url3)) {
        return await rewriteCssUrls(url3, replacer);
      }
      if (!cssNotProcessedRE.test(url3)) {
        return await doUrlReplace(url3, url3, replacer);
      }
      return url3;
    });
    return url2;
  });
}
async function doUrlReplace(rawUrl, matched, replacer, funcName = "url") {
  let wrap2 = "";
  const first2 = rawUrl[0];
  if (first2 === `"` || first2 === `'`) {
    wrap2 = first2;
    rawUrl = rawUrl.slice(1, -1);
  }
  if (isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl.startsWith("#") || varRE.test(rawUrl)) {
    return matched;
  }
  const newUrl = await replacer(rawUrl);
  if (wrap2 === "" && newUrl !== encodeURI(newUrl)) {
    wrap2 = "'";
  }
  return `${funcName}(${wrap2}${newUrl}${wrap2})`;
}
async function doImportCSSReplace(rawUrl, matched, replacer) {
  let wrap2 = "";
  const first2 = rawUrl[0];
  if (first2 === `"` || first2 === `'`) {
    wrap2 = first2;
    rawUrl = rawUrl.slice(1, -1);
  }
  if (isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl.startsWith("#")) {
    return matched;
  }
  return `@import ${wrap2}${await replacer(rawUrl)}${wrap2}`;
}
function loadPreprocessor(lang, root) {
  if (lang in loadedPreprocessors) {
    return loadedPreprocessors[lang];
  }
  try {
    const resolved = requireResolveFromRootWithFallback(root, lang);
    return loadedPreprocessors[lang] = _require$1(resolved);
  } catch (e) {
    if (e.code === "MODULE_NOT_FOUND") {
      throw new Error(`Preprocessor dependency "${lang}" not found. Did you install it?`);
    } else {
      const message = new Error(`Preprocessor dependency "${lang}" failed to load:
${e.message}`);
      message.stack = e.stack + "\n" + message.stack;
      throw message;
    }
  }
}
function cleanScssBugUrl(url2) {
  if (
    // check bug via `window` and `location` global
    typeof window !== "undefined" && typeof location !== "undefined"
  ) {
    const prefix = location.href.replace(/\/$/, "");
    return url2.replace(prefix, "");
  } else {
    return url2;
  }
}
function fixScssBugImportValue(data3) {
  if (
    // check bug via `window` and `location` global
    typeof window !== "undefined" && typeof location !== "undefined" && data3 && "file" in data3 && (!("contents" in data3) || data3.contents == null)
  ) {
    data3.contents = import_node_fs2.default.readFileSync(data3.file, "utf-8");
  }
  return data3;
}
async function rebaseUrls(file, rootFile, alias, variablePrefix) {
  file = import_node_path4.default.resolve(file);
  const fileDir = import_node_path4.default.dirname(file);
  const rootDir = import_node_path4.default.dirname(rootFile);
  if (fileDir === rootDir) {
    return { file };
  }
  const content = import_node_fs2.default.readFileSync(file, "utf-8");
  const hasUrls = cssUrlRE.test(content);
  const hasDataUris = cssDataUriRE.test(content);
  const hasImportCss = importCssRE.test(content);
  if (!hasUrls && !hasDataUris && !hasImportCss) {
    return { file };
  }
  let rebased;
  const rebaseFn = (url2) => {
    if (url2.startsWith("/"))
      return url2;
    if (url2.startsWith(variablePrefix))
      return url2;
    for (const { find } of alias) {
      const matches = typeof find === "string" ? url2.startsWith(find) : find.test(url2);
      if (matches) {
        return url2;
      }
    }
    const absolute = import_node_path4.default.resolve(fileDir, url2);
    const relative3 = import_node_path4.default.relative(rootDir, absolute);
    return normalizePath$3(relative3);
  };
  if (hasImportCss) {
    rebased = await rewriteImportCss(content, rebaseFn);
  }
  if (hasUrls) {
    rebased = await rewriteCssUrls(rebased || content, rebaseFn);
  }
  if (hasDataUris) {
    rebased = await rewriteCssDataUris(rebased || content, rebaseFn);
  }
  return {
    file,
    contents: rebased
  };
}
function createViteLessPlugin(less2, rootFile, alias, resolvers) {
  if (!ViteLessManager) {
    ViteLessManager = class ViteManager extends less2.FileManager {
      constructor(rootFile2, resolvers2, alias2) {
        super();
        this.rootFile = rootFile2;
        this.resolvers = resolvers2;
        this.alias = alias2;
      }
      supports(filename) {
        return !isExternalUrl(filename);
      }
      supportsSync() {
        return false;
      }
      async loadFile(filename, dir, opts, env3) {
        const resolved = await this.resolvers.less(filename, import_node_path4.default.join(dir, "*"));
        if (resolved) {
          const result = await rebaseUrls(resolved, this.rootFile, this.alias, "@");
          let contents;
          if (result && "contents" in result) {
            contents = result.contents;
          } else {
            contents = import_node_fs2.default.readFileSync(resolved, "utf-8");
          }
          return {
            filename: import_node_path4.default.resolve(resolved),
            contents
          };
        } else {
          return super.loadFile(filename, dir, opts, env3);
        }
      }
    };
  }
  return {
    install(_, pluginManager) {
      pluginManager.addFileManager(new ViteLessManager(rootFile, resolvers, alias));
    },
    minVersion: [3, 0, 0]
  };
}
function formatStylusSourceMap(mapBefore, root) {
  if (!mapBefore)
    return void 0;
  const map2 = { ...mapBefore };
  const resolveFromRoot = (p) => normalizePath$3(import_node_path4.default.resolve(root, p));
  if (map2.file) {
    map2.file = resolveFromRoot(map2.file);
  }
  map2.sources = map2.sources.map(resolveFromRoot);
  return map2;
}
async function getSource(source, filename, additionalData, enableSourcemap, sep2 = "") {
  if (!additionalData)
    return { content: source };
  if (typeof additionalData === "function") {
    const newContent = await additionalData(source, filename);
    if (typeof newContent === "string") {
      return { content: newContent };
    }
    return newContent;
  }
  if (!enableSourcemap) {
    return { content: additionalData + sep2 + source };
  }
  const ms2 = new MagicString2(source);
  ms2.appendLeft(0, sep2);
  ms2.appendLeft(0, additionalData);
  const map2 = ms2.generateMap({ hires: true });
  map2.file = filename;
  map2.sources = [filename];
  return {
    content: ms2.toString(),
    map: map2
  };
}
function skipThrough2(node2, st, c) {
  c(node2, st);
}
function ignore2(_node, _st, _c) {
}
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  ms = function(val, options2) {
    options2 = options2 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse7(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse7(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n2 = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n2 * y;
      case "days":
      case "day":
      case "d":
        return n2 * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n2 * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n2 * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n2 * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n2;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    if (ms2 >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (ms2 >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (ms2 >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (ms2 >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    return plural(ms2, d, "day") || plural(ms2, h, "hour") || plural(ms2, m, "minute") || plural(ms2, s, "second") || ms2 + " ms";
  }
  function plural(ms2, n2, name2) {
    if (ms2 < n2) {
      return;
    }
    if (ms2 < n2 * 1.5) {
      return Math.floor(ms2 / n2) + " " + name2;
    }
    return Math.ceil(ms2 / n2) + " " + name2 + "s";
  }
  return ms;
}
function requireDebug() {
  if (hasRequiredDebug)
    return debugExports;
  hasRequiredDebug = 1;
  (function(module2, exports2) {
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = requireMs();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug2() {
        if (!debug2.enabled)
          return;
        var self2 = debug2;
        var curr = +/* @__PURE__ */ new Date();
        var ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format2) {
          if (match === "%%")
            return match;
          index++;
          var formatter2 = exports2.formatters[format2];
          if ("function" === typeof formatter2) {
            var val = args[index];
            match = formatter2.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug2.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.enabled = exports2.enabled(namespace);
      debug2.useColors = exports2.useColors();
      debug2.color = selectColor(namespace);
      if ("function" === typeof exports2.init) {
        exports2.init(debug2);
      }
      return debug2;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name2) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name2)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  })(debug$6, debugExports);
  return debugExports;
}
function requireBrowser() {
  if (hasRequiredBrowser)
    return browserExports;
  hasRequiredBrowser = 1;
  (function(module2, exports2) {
    exports2 = module2.exports = requireDebug();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load2() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load2());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  })(browser, browserExports);
  return browserExports;
}
function requireNode() {
  if (hasRequiredNode)
    return nodeExports;
  hasRequiredNode = 1;
  (function(module2, exports2) {
    var tty3 = import_tty.default;
    var util2 = import_util.default;
    exports2 = module2.exports = requireDebug();
    exports2.init = init4;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util2.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream4 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty3.isatty(fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name2 = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name2 + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports2.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name2 + " " + args[0];
      }
    }
    function log() {
      return stream4.write(util2.format.apply(util2, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream5;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream5 = new tty3.WriteStream(fd2);
          stream5._type = "tty";
          if (stream5._handle && stream5._handle.unref) {
            stream5._handle.unref();
          }
          break;
        case "FILE":
          var fs2 = import_fs.default;
          stream5 = new fs2.SyncWriteStream(fd2, { autoClose: false });
          stream5._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net2 = import_net.default;
          stream5 = new net2.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream5.readable = false;
          stream5.read = null;
          stream5._type = "pipe";
          if (stream5._handle && stream5._handle.unref) {
            stream5._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream5.fd = fd2;
      stream5._isStdio = true;
      return stream5;
    }
    function init4(debug2) {
      debug2.inspectOpts = {};
      var keys2 = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys2.length; i++) {
        debug2.inspectOpts[keys2[i]] = exports2.inspectOpts[keys2[i]];
      }
    }
    exports2.enable(load2());
  })(node, nodeExports);
  return nodeExports;
}
function encodeUrl$1(url2) {
  return String(url2).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
}
function escapeHtml$1(string2) {
  var str = "" + string2;
  var match = matchHtmlRegExp.exec(str);
  if (!match) {
    return str;
  }
  var escape2;
  var html = "";
  var index = 0;
  var lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escape2 = "&quot;";
        break;
      case 38:
        escape2 = "&amp;";
        break;
      case 39:
        escape2 = "&#39;";
        break;
      case 60:
        escape2 = "&lt;";
        break;
      case 62:
        escape2 = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escape2;
  }
  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
function first$1(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError("arg must be an array of [ee, events...] arrays");
  var cleanups = [];
  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i];
    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError("each array member must be [ee, events...]");
    var ee = arr[0];
    for (var j = 1; j < arr.length; j++) {
      var event = arr[j];
      var fn = listener(event, callback);
      ee.on(event, fn);
      cleanups.push({
        ee,
        event,
        fn
      });
    }
  }
  function callback() {
    cleanup();
    done.apply(null, arguments);
  }
  function cleanup() {
    var x;
    for (var i2 = 0; i2 < cleanups.length; i2++) {
      x = cleanups[i2];
      x.ee.removeListener(x.event, x.fn);
    }
  }
  function thunk(fn2) {
    done = fn2;
  }
  thunk.cancel = cleanup;
  return thunk;
}
function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length);
    var ee = this;
    var err = event === "error" ? arg1 : null;
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    done(err, ee, event, args);
  };
}
function onFinished$1(msg, listener2) {
  if (isFinished$1(msg) !== false) {
    defer$2(listener2, null, msg);
    return msg;
  }
  attachListener(msg, listener2);
  return msg;
}
function isFinished$1(msg) {
  var socket = msg.socket;
  if (typeof msg.finished === "boolean") {
    return Boolean(msg.finished || socket && !socket.writable);
  }
  if (typeof msg.complete === "boolean") {
    return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
  }
  return void 0;
}
function attachFinishedListener(msg, callback) {
  var eeMsg;
  var eeSocket;
  var finished = false;
  function onFinish(error2) {
    eeMsg.cancel();
    eeSocket.cancel();
    finished = true;
    callback(error2);
  }
  eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
  function onSocket(socket) {
    msg.removeListener("socket", onSocket);
    if (finished)
      return;
    if (eeMsg !== eeSocket)
      return;
    eeSocket = first([[socket, "error", "close"]], onFinish);
  }
  if (msg.socket) {
    onSocket(msg.socket);
    return;
  }
  msg.on("socket", onSocket);
  if (msg.socket === void 0) {
    patchAssignSocket(msg, onSocket);
  }
}
function attachListener(msg, listener2) {
  var attached = msg.__onFinished;
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg);
    attachFinishedListener(msg, attached);
  }
  attached.queue.push(listener2);
}
function createListener(msg) {
  function listener2(err) {
    if (msg.__onFinished === listener2)
      msg.__onFinished = null;
    if (!listener2.queue)
      return;
    var queue2 = listener2.queue;
    listener2.queue = null;
    for (var i = 0; i < queue2.length; i++) {
      queue2[i](err, msg);
    }
  }
  listener2.queue = [];
  return listener2;
}
function patchAssignSocket(res, callback) {
  var assignSocket = res.assignSocket;
  if (typeof assignSocket !== "function")
    return;
  res.assignSocket = function _assignSocket(socket) {
    assignSocket.call(this, socket);
    callback(socket);
  };
}
function parseurl(req2) {
  var url2 = req2.url;
  if (url2 === void 0) {
    return void 0;
  }
  var parsed = req2._parsedUrl;
  if (fresh(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedUrl = parsed;
}
function originalurl(req2) {
  var url2 = req2.originalUrl;
  if (typeof url2 !== "string") {
    return parseurl(req2);
  }
  var parsed = req2._parsedOriginalUrl;
  if (fresh(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedOriginalUrl = parsed;
}
function fastparse(str) {
  if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
    return parse$7(str);
  }
  var pathname = str;
  var query = null;
  var search = null;
  for (var i = 1; i < str.length; i++) {
    switch (str.charCodeAt(i)) {
      case 63:
        if (search === null) {
          pathname = str.substring(0, i);
          query = str.substring(i + 1);
          search = str.substring(i);
        }
        break;
      case 9:
      case 10:
      case 12:
      case 13:
      case 32:
      case 35:
      case 160:
      case 65279:
        return parse$7(str);
    }
  }
  var url2 = Url !== void 0 ? new Url() : {};
  url2.path = str;
  url2.href = str;
  url2.pathname = pathname;
  if (search !== null) {
    url2.query = query;
    url2.search = search;
  }
  return url2;
}
function fresh(url2, parsedUrl) {
  return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
}
function populateStatusesMap(statuses2, codes2) {
  var arr = [];
  Object.keys(codes2).forEach(function forEachCode(code) {
    var message = codes2[code];
    var status2 = Number(code);
    statuses2[status2] = message;
    statuses2[message] = status2;
    statuses2[message.toLowerCase()] = status2;
    arr.push(status2);
  });
  return arr;
}
function status(code) {
  if (typeof code === "number") {
    if (!status[code])
      throw new Error("invalid status code: " + code);
    return code;
  }
  if (typeof code !== "string") {
    throw new TypeError("code must be a number or string");
  }
  var n2 = parseInt(code, 10);
  if (!isNaN(n2)) {
    if (!status[n2])
      throw new Error("invalid status code: " + n2);
    return n2;
  }
  n2 = status[code.toLowerCase()];
  if (!n2)
    throw new Error('invalid status message: "' + code + '"');
  return n2;
}
function hasPipeDataListeners(stream4) {
  var listeners = stream4.listeners("data");
  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i].name === "ondata") {
      return true;
    }
  }
  return false;
}
function unpipe$1(stream4) {
  if (!stream4) {
    throw new TypeError("argument stream is required");
  }
  if (typeof stream4.unpipe === "function") {
    stream4.unpipe();
    return;
  }
  if (!hasPipeDataListeners(stream4)) {
    return;
  }
  var listener2;
  var listeners = stream4.listeners("close");
  for (var i = 0; i < listeners.length; i++) {
    listener2 = listeners[i];
    if (listener2.name !== "cleanup" && listener2.name !== "onclose") {
      continue;
    }
    listener2.call(stream4);
  }
}
function createHtmlDocument(message) {
  var body = escapeHtml(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
  return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
}
function finalhandler$1(req2, res, options2) {
  var opts = options2 || {};
  var env3 = opts.env || process.env.NODE_ENV || "development";
  var onerror = opts.onerror;
  return function(err) {
    var headers;
    var msg;
    var status2;
    if (!err && headersSent(res)) {
      debug$5("cannot 404 after headers sent");
      return;
    }
    if (err) {
      status2 = getErrorStatusCode(err);
      if (status2 === void 0) {
        status2 = getResponseStatusCode(res);
      } else {
        headers = getErrorHeaders(err);
      }
      msg = getErrorMessage(err, status2, env3);
    } else {
      status2 = 404;
      msg = "Cannot " + req2.method + " " + encodeUrl(getResourceName(req2));
    }
    debug$5("default %s", status2);
    if (err && onerror) {
      defer$1(onerror, err, req2, res);
    }
    if (headersSent(res)) {
      debug$5("cannot %d after headers sent", status2);
      req2.socket.destroy();
      return;
    }
    send(req2, res, status2, headers, msg);
  };
}
function getErrorHeaders(err) {
  if (!err.headers || typeof err.headers !== "object") {
    return void 0;
  }
  var headers = /* @__PURE__ */ Object.create(null);
  var keys2 = Object.keys(err.headers);
  for (var i = 0; i < keys2.length; i++) {
    var key = keys2[i];
    headers[key] = err.headers[key];
  }
  return headers;
}
function getErrorMessage(err, status2, env3) {
  var msg;
  if (env3 !== "production") {
    msg = err.stack;
    if (!msg && typeof err.toString === "function") {
      msg = err.toString();
    }
  }
  return msg || statuses[status2];
}
function getErrorStatusCode(err) {
  if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
    return err.status;
  }
  if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
    return err.statusCode;
  }
  return void 0;
}
function getResourceName(req2) {
  try {
    return parseUrl$1.original(req2).pathname;
  } catch (e) {
    return "resource";
  }
}
function getResponseStatusCode(res) {
  var status2 = res.statusCode;
  if (typeof status2 !== "number" || status2 < 400 || status2 > 599) {
    status2 = 500;
  }
  return status2;
}
function headersSent(res) {
  return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
}
function send(req2, res, status2, headers, message) {
  function write() {
    var body = createHtmlDocument(message);
    res.statusCode = status2;
    res.statusMessage = statuses[status2];
    setHeaders(res, headers);
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.setHeader("Content-Type", "text/html; charset=utf-8");
    res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
    if (req2.method === "HEAD") {
      res.end();
      return;
    }
    res.end(body, "utf8");
  }
  if (isFinished(req2)) {
    write();
    return;
  }
  unpipe(req2);
  onFinished(req2, write);
  req2.resume();
}
function setHeaders(res, headers) {
  if (!headers) {
    return;
  }
  var keys2 = Object.keys(headers);
  for (var i = 0; i < keys2.length; i++) {
    var key = keys2[i];
    res.setHeader(key, headers[key]);
  }
}
function call(handle2, route, err, req2, res, next) {
  var arity = handle2.length;
  var error2 = err;
  var hasError = Boolean(err);
  debug$4("%s %s : %s", handle2.name || "<anonymous>", route, req2.originalUrl);
  try {
    if (hasError && arity === 4) {
      handle2(err, req2, res, next);
      return;
    } else if (!hasError && arity < 4) {
      handle2(req2, res, next);
      return;
    }
  } catch (e) {
    error2 = e;
  }
  next(error2);
}
function logerror(err) {
  if (env2 !== "test")
    console.error(err.stack || err.toString());
}
function getProtohost(url2) {
  if (url2.length === 0 || url2[0] === "/") {
    return void 0;
  }
  var fqdnIndex = url2.indexOf("://");
  return fqdnIndex !== -1 && url2.lastIndexOf("?", fqdnIndex) === -1 ? url2.substr(0, url2.indexOf("/", 3 + fqdnIndex)) : void 0;
}
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
function append(header, field) {
  if (typeof header !== "string") {
    throw new TypeError("header argument is required");
  }
  if (!field) {
    throw new TypeError("field argument is required");
  }
  var fields = !Array.isArray(field) ? parse$6(String(field)) : field;
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError("field argument contains an invalid header name");
    }
  }
  if (header === "*") {
    return header;
  }
  var val = header;
  var vals = parse$6(header.toLowerCase());
  if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
    return "*";
  }
  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase();
    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val ? val + ", " + fields[i] : fields[i];
    }
  }
  return val;
}
function parse$6(header) {
  var end = 0;
  var list = [];
  var start = 0;
  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 44:
        list.push(header.substring(start, end));
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }
  list.push(header.substring(start, end));
  return list;
}
function vary(res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    throw new TypeError("res argument is required");
  }
  var val = res.getHeader("Vary") || "";
  var header = Array.isArray(val) ? val.join(", ") : String(val);
  if (val = append(header, field)) {
    res.setHeader("Vary", val);
  }
}
function createFsWatchInstance(path4, options2, listener2, errHandler, emitRaw) {
  const handleEvent = (rawEvent, evPath) => {
    listener2(path4);
    emitRaw(rawEvent, evPath, { watchedPath: path4 });
    if (evPath && path4 !== evPath) {
      fsWatchBroadcast(
        sysPath$2.resolve(path4, evPath),
        KEY_LISTENERS,
        sysPath$2.join(path4, evPath)
      );
    }
  };
  try {
    return fs$7.watch(path4, options2, handleEvent);
  } catch (error2) {
    errHandler(error2);
  }
}
function setFSEventsListener(path4, realPath, listener2, rawEmitter) {
  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;
  const parentPath = sysPath$1.dirname(watchPath);
  let cont = FSEventsWatchers.get(watchPath);
  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }
  const resolvedPath = sysPath$1.resolve(path4);
  const hasSymlink = resolvedPath !== realPath;
  const filteredListener = (fullPath, flags, info) => {
    if (hasSymlink)
      fullPath = fullPath.replace(realPath, resolvedPath);
    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath$1.sep))
      listener2(fullPath, flags, info);
  };
  let watchedParent = false;
  for (const watchedPath of FSEventsWatchers.keys()) {
    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {
      watchPath = watchedPath;
      cont = FSEventsWatchers.get(watchPath);
      watchedParent = true;
      break;
    }
  }
  if (cont || watchedParent) {
    cont.listeners.add(filteredListener);
  } else {
    cont = {
      listeners: /* @__PURE__ */ new Set([filteredListener]),
      rawEmitter,
      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
        if (!cont.listeners.size)
          return;
        const info = fsevents.getInfo(fullPath, flags);
        cont.listeners.forEach((list) => {
          list(fullPath, flags, info);
        });
        cont.rawEmitter(info.event, fullPath, info);
      })
    };
    FSEventsWatchers.set(watchPath, cont);
  }
  return () => {
    const lst = cont.listeners;
    lst.delete(filteredListener);
    if (!lst.size) {
      FSEventsWatchers.delete(watchPath);
      if (cont.watcher)
        return cont.watcher.stop().then(() => {
          cont.rawEmitter = cont.watcher = void 0;
          Object.freeze(cont);
        });
    }
  };
}
function parse$5(s, env3, opts) {
  var chunker = new RegExp([
    "(" + CONTROL + ")",
    // control chars
    "(" + BAREWORD + "|" + SINGLE_QUOTE + "|" + DOUBLE_QUOTE + ")*"
  ].join("|"), "g");
  var match = s.match(chunker).filter(Boolean);
  var commented = false;
  if (!match)
    return [];
  if (!env3)
    env3 = {};
  if (!opts)
    opts = {};
  return match.map(function(s2, j) {
    if (commented) {
      return;
    }
    if (RegExp("^" + CONTROL + "$").test(s2)) {
      return { op: s2 };
    }
    var SQ = "'";
    var DQ = '"';
    var DS = "$";
    var BS = opts.escape || "\\";
    var quote = false;
    var esc = false;
    var out = "";
    var isGlob3 = false;
    for (var i = 0, len = s2.length; i < len; i++) {
      var c = s2.charAt(i);
      isGlob3 = isGlob3 || !quote && (c === "*" || c === "?");
      if (esc) {
        out += c;
        esc = false;
      } else if (quote) {
        if (c === quote) {
          quote = false;
        } else if (quote == SQ) {
          out += c;
        } else {
          if (c === BS) {
            i += 1;
            c = s2.charAt(i);
            if (c === DQ || c === BS || c === DS) {
              out += c;
            } else {
              out += BS + c;
            }
          } else if (c === DS) {
            out += parseEnvVar();
          } else {
            out += c;
          }
        }
      } else if (c === DQ || c === SQ) {
        quote = c;
      } else if (RegExp("^" + CONTROL + "$").test(c)) {
        return { op: s2 };
      } else if (RegExp("^#$").test(c)) {
        commented = true;
        if (out.length) {
          return [out, { comment: s2.slice(i + 1) + match.slice(j + 1).join(" ") }];
        }
        return [{ comment: s2.slice(i + 1) + match.slice(j + 1).join(" ") }];
      } else if (c === BS) {
        esc = true;
      } else if (c === DS) {
        out += parseEnvVar();
      } else
        out += c;
    }
    if (isGlob3)
      return { op: "glob", pattern: out };
    return out;
    function parseEnvVar() {
      i += 1;
      var varend, varname;
      if (s2.charAt(i) === "{") {
        i += 1;
        if (s2.charAt(i) === "}") {
          throw new Error("Bad substitution: " + s2.substr(i - 2, 3));
        }
        varend = s2.indexOf("}", i);
        if (varend < 0) {
          throw new Error("Bad substitution: " + s2.substr(i));
        }
        varname = s2.substr(i, varend - i);
        i = varend;
      } else if (/[*@#?$!_\-]/.test(s2.charAt(i))) {
        varname = s2.charAt(i);
        i += 1;
      } else {
        varend = s2.substr(i).match(/[^\w\d_]/);
        if (!varend) {
          varname = s2.substr(i);
          i = s2.length;
        } else {
          varname = s2.substr(i, varend.index);
          i += varend.index - 1;
        }
      }
      return getVar(null, "", varname);
    }
  }).reduce(function(prev, arg) {
    if (arg === void 0) {
      return prev;
    }
    return prev.concat(arg);
  }, []);
  function getVar(_, pre, key) {
    var r = typeof env3 === "function" ? env3(key) : env3[key];
    if (r === void 0 && key != "")
      r = "";
    else if (r === void 0)
      r = "$";
    if (typeof r === "object") {
      return pre + TOKEN + JSON.stringify(r) + TOKEN;
    } else
      return pre + r;
  }
}
function concat$1(list, totalLength) {
  if (list.length === 0)
    return EMPTY_BUFFER$3;
  if (list.length === 1)
    return list[0];
  const target = Buffer.allocUnsafe(totalLength);
  let offset4 = 0;
  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset4);
    offset4 += buf.length;
  }
  if (offset4 < totalLength) {
    return new FastBuffer$2(target.buffer, target.byteOffset, offset4);
  }
  return target;
}
function _mask(source, mask, output, offset4, length) {
  for (let i = 0; i < length; i++) {
    output[offset4 + i] = source[i] ^ mask[i & 3];
  }
}
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}
function toArrayBuffer$1(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }
  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}
function toBuffer$2(data3) {
  toBuffer$2.readOnly = true;
  if (Buffer.isBuffer(data3))
    return data3;
  let buf;
  if (data3 instanceof ArrayBuffer) {
    buf = new FastBuffer$2(data3);
  } else if (ArrayBuffer.isView(data3)) {
    buf = new FastBuffer$2(data3.buffer, data3.byteOffset, data3.byteLength);
  } else {
    buf = Buffer.from(data3);
    toBuffer$2.readOnly = false;
  }
  return buf;
}
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;
  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
    this[kBuffers].push(chunk);
    return;
  }
  this[kError$1] = new RangeError("Max payload size exceeded");
  this[kError$1].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
  this[kError$1][kStatusCode$2] = 1009;
  this.removeListener("data", inflateOnData);
  this.reset();
}
function inflateOnError(err) {
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode$2] = 1007;
  this[kCallback](err);
}
function isValidStatusCode$2(code) {
  return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
}
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;
  while (i < len) {
    if ((buf[i] & 128) === 0) {
      i++;
    } else if ((buf[i] & 224) === 192) {
      if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
        return false;
      }
      i += 2;
    } else if ((buf[i] & 240) === 224) {
      if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
      buf[i] === 237 && (buf[i + 1] & 224) === 160) {
        return false;
      }
      i += 3;
    } else if ((buf[i] & 248) === 240) {
      if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
      buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
        return false;
      }
      i += 4;
    } else {
      return false;
    }
  }
  return true;
}
function error(ErrorCtor, message, prefix, statusCode, errorCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );
  Error.captureStackTrace(err, error);
  err.code = errorCode;
  err[kStatusCode$1] = statusCode;
  return err;
}
function callListener(listener2, thisArg, event) {
  if (typeof listener2 === "object" && listener2.handleEvent) {
    listener2.handleEvent.call(listener2, event);
  } else {
    listener2.call(thisArg, event);
  }
}
function push(dest, name2, elem) {
  if (dest[name2] === void 0)
    dest[name2] = [elem];
  else
    dest[name2].push(elem);
}
function parse$4(header) {
  const offers = /* @__PURE__ */ Object.create(null);
  let params = /* @__PURE__ */ Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;
  for (; i < header.length; i++) {
    code = header.charCodeAt(i);
    if (extensionName === void 0) {
      if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1)
          start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        const name2 = header.slice(start, end);
        if (code === 44) {
          push(offers, name2, params);
          params = /* @__PURE__ */ Object.create(null);
        } else {
          extensionName = name2;
        }
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === void 0) {
      if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1)
          start = i;
      } else if (code === 32 || code === 9) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        push(params, header.slice(start, end), true);
        if (code === 44) {
          push(offers, extensionName, params);
          params = /* @__PURE__ */ Object.create(null);
          extensionName = void 0;
        }
        start = end = -1;
      } else if (code === 61 && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      if (isEscaping) {
        if (tokenChars$1[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1)
          start = i;
        else if (!mustUnescape)
          mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars$1[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 34 && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 92) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
        inQuotes = true;
      } else if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1)
          start = i;
      } else if (start !== -1 && (code === 32 || code === 9)) {
        if (end === -1)
          end = i;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        let value2 = header.slice(start, end);
        if (mustUnescape) {
          value2 = value2.replace(/\\/g, "");
          mustUnescape = false;
        }
        push(params, paramName, value2);
        if (code === 44) {
          push(offers, extensionName, params);
          params = /* @__PURE__ */ Object.create(null);
          extensionName = void 0;
        }
        paramName = void 0;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }
  if (start === -1 || inQuotes || code === 32 || code === 9) {
    throw new SyntaxError("Unexpected end of input");
  }
  if (end === -1)
    end = i;
  const token = header.slice(start, end);
  if (extensionName === void 0) {
    push(offers, token, params);
  } else {
    if (paramName === void 0) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ""));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }
  return offers;
}
function format$1(extensions3) {
  return Object.keys(extensions3).map((extension) => {
    let configurations = extensions3[extension];
    if (!Array.isArray(configurations))
      configurations = [configurations];
    return configurations.map((params) => {
      return [extension].concat(
        Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })
      ).join("; ");
    }).join(", ");
  }).join(", ");
}
function initAsClient(websocket, address, protocols, options2) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options2,
    createConnection: void 0,
    socketPath: void 0,
    hostname: void 0,
    protocol: void 0,
    timeout: void 0,
    method: "GET",
    host: void 0,
    path: void 0,
    port: void 0
  };
  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
    );
  }
  let parsedUrl;
  if (address instanceof URL$2) {
    parsedUrl = address;
    websocket._url = address.href;
  } else {
    try {
      parsedUrl = new URL$2(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
    websocket._url = address;
  }
  const isSecure = parsedUrl.protocol === "wss:";
  const isIpcUrl = parsedUrl.protocol === "ws+unix:";
  let invalidUrlMessage;
  if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
    invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = "The URL contains a fragment identifier";
  }
  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);
    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket, err);
      return;
    }
  }
  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString("base64");
  const request = isSecure ? https$2.request : http$3.request;
  const protocolSet = /* @__PURE__ */ new Set();
  let perMessageDeflate;
  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    "Sec-WebSocket-Version": opts.protocolVersion,
    "Sec-WebSocket-Key": key,
    Connection: "Upgrade",
    Upgrade: "websocket"
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;
  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate$1(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers["Sec-WebSocket-Extensions"] = format({
      [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
        throw new SyntaxError(
          "An invalid or duplicated subprotocol was specified"
        );
      }
      protocolSet.add(protocol);
    }
    opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers["Sec-WebSocket-Origin"] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }
  if (isIpcUrl) {
    const parts = opts.path.split(":");
    opts.socketPath = parts[0];
    opts.path = parts[1];
  }
  let req2;
  if (opts.followRedirects) {
    if (websocket._redirects === 0) {
      websocket._originalIpc = isIpcUrl;
      websocket._originalSecure = isSecure;
      websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
      const headers = options2 && options2.headers;
      options2 = { ...options2, headers: {} };
      if (headers) {
        for (const [key2, value2] of Object.entries(headers)) {
          options2.headers[key2.toLowerCase()] = value2;
        }
      }
    } else if (websocket.listenerCount("redirect") === 0) {
      const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
      if (!isSameHost || websocket._originalSecure && !isSecure) {
        delete opts.headers.authorization;
        delete opts.headers.cookie;
        if (!isSameHost)
          delete opts.headers.host;
        opts.auth = void 0;
      }
    }
    if (opts.auth && !options2.headers.authorization) {
      options2.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
    }
    req2 = websocket._req = request(opts);
    if (websocket._redirects) {
      websocket.emit("redirect", websocket.url, req2);
    }
  } else {
    req2 = websocket._req = request(opts);
  }
  if (opts.timeout) {
    req2.on("timeout", () => {
      abortHandshake$1(websocket, req2, "Opening handshake has timed out");
    });
  }
  req2.on("error", (err) => {
    if (req2 === null || req2[kAborted])
      return;
    req2 = websocket._req = null;
    emitErrorAndClose(websocket, err);
  });
  req2.on("response", (res) => {
    const location2 = res.headers.location;
    const statusCode = res.statusCode;
    if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake$1(websocket, req2, "Maximum redirects exceeded");
        return;
      }
      req2.abort();
      let addr;
      try {
        addr = new URL$2(location2, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location2}`);
        emitErrorAndClose(websocket, err);
        return;
      }
      initAsClient(websocket, addr, protocols, options2);
    } else if (!websocket.emit("unexpected-response", req2, res)) {
      abortHandshake$1(
        websocket,
        req2,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });
  req2.on("upgrade", (res, socket, head) => {
    websocket.emit("upgrade", res);
    if (websocket.readyState !== WebSocket$1.CONNECTING)
      return;
    req2 = websocket._req = null;
    if (res.headers.upgrade.toLowerCase() !== "websocket") {
      abortHandshake$1(websocket, socket, "Invalid Upgrade header");
      return;
    }
    const digest = createHash$12("sha1").update(key + GUID$1).digest("base64");
    if (res.headers["sec-websocket-accept"] !== digest) {
      abortHandshake$1(websocket, socket, "Invalid Sec-WebSocket-Accept header");
      return;
    }
    const serverProt = res.headers["sec-websocket-protocol"];
    let protError;
    if (serverProt !== void 0) {
      if (!protocolSet.size) {
        protError = "Server sent a subprotocol but none was requested";
      } else if (!protocolSet.has(serverProt)) {
        protError = "Server sent an invalid subprotocol";
      }
    } else if (protocolSet.size) {
      protError = "Server sent no subprotocol";
    }
    if (protError) {
      abortHandshake$1(websocket, socket, protError);
      return;
    }
    if (serverProt)
      websocket._protocol = serverProt;
    const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
    if (secWebSocketExtensions !== void 0) {
      if (!perMessageDeflate) {
        const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
        abortHandshake$1(websocket, socket, message);
        return;
      }
      let extensions3;
      try {
        extensions3 = parse$3(secWebSocketExtensions);
      } catch (err) {
        const message = "Invalid Sec-WebSocket-Extensions header";
        abortHandshake$1(websocket, socket, message);
        return;
      }
      const extensionNames = Object.keys(extensions3);
      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {
        const message = "Server indicated an extension that was not requested";
        abortHandshake$1(websocket, socket, message);
        return;
      }
      try {
        perMessageDeflate.accept(extensions3[PerMessageDeflate$1.extensionName]);
      } catch (err) {
        const message = "Invalid Sec-WebSocket-Extensions header";
        abortHandshake$1(websocket, socket, message);
        return;
      }
      websocket._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;
    }
    websocket.setSocket(socket, head, {
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });
  req2.end();
}
function emitErrorAndClose(websocket, err) {
  websocket._readyState = WebSocket$1.CLOSING;
  websocket.emit("error", err);
  websocket.emitClose();
}
function netConnect(options2) {
  options2.path = options2.socketPath;
  return net.connect(options2);
}
function tlsConnect(options2) {
  options2.path = void 0;
  if (!options2.servername && options2.servername !== "") {
    options2.servername = net.isIP(options2.host) ? "" : options2.host;
  }
  return tls.connect(options2);
}
function abortHandshake$1(websocket, stream4, message) {
  websocket._readyState = WebSocket$1.CLOSING;
  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake$1);
  if (stream4.setHeader) {
    stream4[kAborted] = true;
    stream4.abort();
    if (stream4.socket && !stream4.socket.destroyed) {
      stream4.socket.destroy();
    }
    process.nextTick(emitErrorAndClose, websocket, err);
  } else {
    stream4.destroy(err);
    stream4.once("error", websocket.emit.bind(websocket, "error"));
    stream4.once("close", websocket.emitClose.bind(websocket));
  }
}
function sendAfterClose(websocket, data3, cb) {
  if (data3) {
    const length = toBuffer(data3).length;
    if (websocket._socket)
      websocket._sender._bufferedBytes += length;
    else
      websocket._bufferedAmount += length;
  }
  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
    );
    process.nextTick(cb, err);
  }
}
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket$1];
  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;
  if (websocket._socket[kWebSocket$1] === void 0)
    return;
  websocket._socket.removeListener("data", socketOnData);
  process.nextTick(resume, websocket._socket);
  if (code === 1005)
    websocket.close();
  else
    websocket.close(code, reason);
}
function receiverOnDrain() {
  const websocket = this[kWebSocket$1];
  if (!websocket.isPaused)
    websocket._socket.resume();
}
function receiverOnError(err) {
  const websocket = this[kWebSocket$1];
  if (websocket._socket[kWebSocket$1] !== void 0) {
    websocket._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket._socket);
    websocket.close(err[kStatusCode]);
  }
  websocket.emit("error", err);
}
function receiverOnFinish() {
  this[kWebSocket$1].emitClose();
}
function receiverOnMessage(data3, isBinary) {
  this[kWebSocket$1].emit("message", data3, isBinary);
}
function receiverOnPing(data3) {
  const websocket = this[kWebSocket$1];
  websocket.pong(data3, !websocket._isServer, NOOP);
  websocket.emit("ping", data3);
}
function receiverOnPong(data3) {
  this[kWebSocket$1].emit("pong", data3);
}
function resume(stream4) {
  stream4.resume();
}
function socketOnClose() {
  const websocket = this[kWebSocket$1];
  this.removeListener("close", socketOnClose);
  this.removeListener("data", socketOnData);
  this.removeListener("end", socketOnEnd);
  websocket._readyState = WebSocket$1.CLOSING;
  let chunk;
  if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
    websocket._receiver.write(chunk);
  }
  websocket._receiver.end();
  this[kWebSocket$1] = void 0;
  clearTimeout(websocket._closeTimer);
  if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
    websocket.emitClose();
  } else {
    websocket._receiver.on("error", receiverOnFinish);
    websocket._receiver.on("finish", receiverOnFinish);
  }
}
function socketOnData(chunk) {
  if (!this[kWebSocket$1]._receiver.write(chunk)) {
    this.pause();
  }
}
function socketOnEnd() {
  const websocket = this[kWebSocket$1];
  websocket._readyState = WebSocket$1.CLOSING;
  websocket._receiver.end();
  this.end();
}
function socketOnError$1() {
  const websocket = this[kWebSocket$1];
  this.removeListener("error", socketOnError$1);
  this.on("error", NOOP);
  if (websocket) {
    websocket._readyState = WebSocket$1.CLOSING;
    this.destroy();
  }
}
function RedirectableRequest(options2, responseCallback) {
  Writable.call(this);
  this._sanitizeOptions(options2);
  this._options = options2;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];
  if (responseCallback) {
    this.on("response", responseCallback);
  }
  var self2 = this;
  this._onNativeResponse = function(response) {
    self2._processResponse(response);
  };
  this._performRequest();
}
function wrap(protocols) {
  var exports2 = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024
  };
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function(scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
    function request(input, options2, callback) {
      if (typeof input === "string") {
        var urlStr = input;
        try {
          input = urlToOptions(new URL$1(urlStr));
        } catch (err) {
          input = url.parse(urlStr);
        }
      } else if (URL$1 && input instanceof URL$1) {
        input = urlToOptions(input);
      } else {
        callback = options2;
        options2 = input;
        input = { protocol };
      }
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      options2 = Object.assign({
        maxRedirects: exports2.maxRedirects,
        maxBodyLength: exports2.maxBodyLength
      }, input, options2);
      options2.nativeProtocols = nativeProtocols;
      assert.equal(options2.protocol, protocol, "protocol mismatch");
      debug$2("options", options2);
      return new RedirectableRequest(options2, callback);
    }
    function get2(input, options2, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options2, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get2, configurable: true, enumerable: true, writable: true }
    });
  });
  return exports2;
}
function noop$1() {
}
function urlToOptions(urlObject) {
  var options2 = {
    protocol: urlObject.protocol,
    hostname: urlObject.hostname.startsWith("[") ? (
      /* istanbul ignore next */
      urlObject.hostname.slice(1, -1)
    ) : urlObject.hostname,
    hash: urlObject.hash,
    search: urlObject.search,
    pathname: urlObject.pathname,
    path: urlObject.pathname + urlObject.search,
    href: urlObject.href
  };
  if (urlObject.port !== "") {
    options2.port = Number(urlObject.port);
  }
  return options2;
}
function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
}
function createErrorType(code, defaultMessage) {
  function CustomError(cause) {
    Error.captureStackTrace(this, this.constructor);
    if (!cause) {
      this.message = defaultMessage;
    } else {
      this.message = defaultMessage + ": " + cause.message;
      this.cause = cause;
    }
  }
  CustomError.prototype = new Error();
  CustomError.prototype.constructor = CustomError;
  CustomError.prototype.name = "Error [" + code + "]";
  CustomError.prototype.code = code;
  return CustomError;
}
function abortRequest(request) {
  for (var e = 0; e < events.length; e++) {
    request.removeListener(events[e], eventHandlers[events[e]]);
  }
  request.on("error", noop$1);
  request.abort();
}
function isSubdomain(subdomain, domain) {
  const dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
function createProxyServer(options2) {
  return new ProxyServer(options2);
}
function hasDockerEnv() {
  try {
    fs$3.statSync("/.dockerenv");
    return true;
  } catch (_) {
    return false;
  }
}
function hasDockerCGroup() {
  try {
    return fs$3.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
  } catch (_) {
    return false;
  }
}
function isInsideContainer() {
  if (cachedResult === void 0) {
    cachedResult = hasContainerEnv() || isDocker();
  }
  return cachedResult;
}
function detectArchBinary(binary2) {
  if (typeof binary2 === "string" || Array.isArray(binary2)) {
    return binary2;
  }
  const { [arch]: archBinary } = binary2;
  if (!archBinary) {
    throw new Error(`${arch} is not supported`);
  }
  return archBinary;
}
function detectPlatformBinary({ [platform2]: platformBinary }, { wsl }) {
  if (wsl && isWsl) {
    return detectArchBinary(wsl);
  }
  if (!platformBinary) {
    throw new Error(`${platform2} is not supported`);
  }
  return detectArchBinary(platformBinary);
}
function requireWindows() {
  if (hasRequiredWindows)
    return windows;
  hasRequiredWindows = 1;
  windows = isexe2;
  isexe2.sync = sync2;
  var fs2 = import_fs.default;
  function checkPathExt(path4, options2) {
    var pathext = options2.pathExt !== void 0 ? options2.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path4.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat2, path4, options2) {
    if (!stat2.isSymbolicLink() && !stat2.isFile()) {
      return false;
    }
    return checkPathExt(path4, options2);
  }
  function isexe2(path4, options2, cb) {
    fs2.stat(path4, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, path4, options2));
    });
  }
  function sync2(path4, options2) {
    return checkStat(fs2.statSync(path4), path4, options2);
  }
  return windows;
}
function requireMode() {
  if (hasRequiredMode)
    return mode;
  hasRequiredMode = 1;
  mode = isexe2;
  isexe2.sync = sync2;
  var fs2 = import_fs.default;
  function isexe2(path4, options2, cb) {
    fs2.stat(path4, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, options2));
    });
  }
  function sync2(path4, options2) {
    return checkStat(fs2.statSync(path4), options2);
  }
  function checkStat(stat2, options2) {
    return stat2.isFile() && checkMode(stat2, options2);
  }
  function checkMode(stat2, options2) {
    var mod = stat2.mode;
    var uid = stat2.uid;
    var gid = stat2.gid;
    var myUid = options2.uid !== void 0 ? options2.uid : process.getuid && process.getuid();
    var myGid = options2.gid !== void 0 ? options2.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
  return mode;
}
function isexe$1(path4, options2, cb) {
  if (typeof options2 === "function") {
    cb = options2;
    options2 = {};
  }
  if (!cb) {
    if (typeof Promise !== "function") {
      throw new TypeError("callback not provided");
    }
    return new Promise(function(resolve5, reject) {
      isexe$1(path4, options2 || {}, function(er, is) {
        if (er) {
          reject(er);
        } else {
          resolve5(is);
        }
      });
    });
  }
  core(path4, options2 || {}, function(er, is) {
    if (er) {
      if (er.code === "EACCES" || options2 && options2.ignoreErrors) {
        er = null;
        is = false;
      }
    }
    cb(er, is);
  });
}
function sync(path4, options2) {
  try {
    return core.sync(path4, options2 || {});
  } catch (er) {
    if (options2 && options2.ignoreErrors || er.code === "EACCES") {
      return false;
    } else {
      throw er;
    }
  }
}
function resolveCommandAttempt(parsed, withoutPathExt) {
  const env3 = parsed.options.env || process.env;
  const cwd = process.cwd();
  const hasCustomCwd = parsed.options.cwd != null;
  const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
  if (shouldSwitchCwd) {
    try {
      process.chdir(parsed.options.cwd);
    } catch (err) {
    }
  }
  let resolved;
  try {
    resolved = which.sync(parsed.command, {
      path: env3[getPathKey({ env: env3 })],
      pathExt: withoutPathExt ? path$12.delimiter : void 0
    });
  } catch (e) {
  } finally {
    if (shouldSwitchCwd) {
      process.chdir(cwd);
    }
  }
  if (resolved) {
    resolved = path$12.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
  }
  return resolved;
}
function resolveCommand$1(parsed) {
  return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
}
function escapeCommand(arg) {
  arg = arg.replace(metaCharsRegExp, "^$1");
  return arg;
}
function escapeArgument(arg, doubleEscapeMetaChars) {
  arg = `${arg}`;
  arg = arg.replace(/(\\*)"/g, '$1$1\\"');
  arg = arg.replace(/(\\*)$/, "$1$1");
  arg = `"${arg}"`;
  arg = arg.replace(metaCharsRegExp, "^$1");
  if (doubleEscapeMetaChars) {
    arg = arg.replace(metaCharsRegExp, "^$1");
  }
  return arg;
}
function readShebang$1(command) {
  const size = 150;
  const buffer = Buffer.alloc(size);
  let fd;
  try {
    fd = fs.openSync(command, "r");
    fs.readSync(fd, buffer, 0, size, 0);
    fs.closeSync(fd);
  } catch (e) {
  }
  return shebangCommand(buffer.toString());
}
function detectShebang(parsed) {
  parsed.file = resolveCommand(parsed);
  const shebang = parsed.file && readShebang(parsed.file);
  if (shebang) {
    parsed.args.unshift(parsed.file);
    parsed.command = shebang;
    return resolveCommand(parsed);
  }
  return parsed.file;
}
function parseNonShell(parsed) {
  if (!isWin$1) {
    return parsed;
  }
  const commandFile = detectShebang(parsed);
  const needsShell = !isExecutableRegExp.test(commandFile);
  if (parsed.options.forceShell || needsShell) {
    const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
    parsed.command = path3.normalize(parsed.command);
    parsed.command = escape$1.command(parsed.command);
    parsed.args = parsed.args.map((arg) => escape$1.argument(arg, needsDoubleEscapeMetaChars));
    const shellCommand = [parsed.command].concat(parsed.args).join(" ");
    parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
    parsed.command = process.env.comspec || "cmd.exe";
    parsed.options.windowsVerbatimArguments = true;
  }
  return parsed;
}
function parse$12(command, args, options2) {
  if (args && !Array.isArray(args)) {
    options2 = args;
    args = null;
  }
  args = args ? args.slice(0) : [];
  options2 = Object.assign({}, options2);
  const parsed = {
    command,
    args,
    options: options2,
    file: void 0,
    original: {
      command,
      args
    }
  };
  return options2.shell ? parsed : parseNonShell(parsed);
}
function notFoundError(original, syscall) {
  return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
    code: "ENOENT",
    errno: "ENOENT",
    syscall: `${syscall} ${original.command}`,
    path: original.command,
    spawnargs: original.args
  });
}
function hookChildProcess(cp2, parsed) {
  if (!isWin) {
    return;
  }
  const originalEmit = cp2.emit;
  cp2.emit = function(name2, arg1) {
    if (name2 === "exit") {
      const err = verifyENOENT(arg1, parsed);
      if (err) {
        return originalEmit.call(cp2, "error", err);
      }
    }
    return originalEmit.apply(cp2, arguments);
  };
}
function verifyENOENT(status2, parsed) {
  if (isWin && status2 === 1 && !parsed.file) {
    return notFoundError(parsed.original, "spawn");
  }
  return null;
}
function verifyENOENTSync(status2, parsed) {
  if (isWin && status2 === 1 && !parsed.file) {
    return notFoundError(parsed.original, "spawnSync");
  }
  return null;
}
function spawn(command, args, options2) {
  const parsed = parse6(command, args, options2);
  const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
  enoent.hookChildProcess(spawned, parsed);
  return spawned;
}
function spawnSync(command, args, options2) {
  const parsed = parse6(command, args, options2);
  const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
  result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
  return result;
}
var import_node_fs2, import_node_path4, import_node_url2, import_node_perf_hooks3, import_node_module, import_tty, import_esbuild, import_path2, import_fs, import_events, import_assert, import_util, import_net, import_url, import_http, import_stream, import_os, import_child_process, import_node_os, import_node_crypto3, import_node_util, import_node_dns, import_resolve, import_crypto, import_node_buffer, import_promises3, import_module, import_node_assert, import_node_process3, import_node_v8, import_worker_threads, import_zlib, import_buffer, import_https, import_tls, import_node_http, import_node_https, import_node_readline, import_node_child_process, import_node_zlib, import_node_url3, import_node_path5, import_node_module2, import_meta2, __filename2, __dirname2, require2, __require, commonjsGlobal, picocolorsExports, picocolors, tty2, isColorSupported2, formatter, replaceClose2, createColors2, picomatchExports2, picomatch$5, utils$k, path$n, WIN_SLASH2, WIN_NO_SLASH2, DOT_LITERAL2, PLUS_LITERAL2, QMARK_LITERAL2, SLASH_LITERAL2, ONE_CHAR2, QMARK2, END_ANCHOR2, START_ANCHOR2, DOTS_SLASH2, NO_DOT2, NO_DOTS2, NO_DOT_SLASH2, NO_DOTS_SLASH2, QMARK_NO_DOT2, STAR$1, POSIX_CHARS2, WINDOWS_CHARS2, POSIX_REGEX_SOURCE$12, constants$6, utils$j, CHAR_ASTERISK2, CHAR_AT2, CHAR_BACKWARD_SLASH2, CHAR_COMMA$1, CHAR_DOT$1, CHAR_EXCLAMATION_MARK2, CHAR_FORWARD_SLASH2, CHAR_LEFT_CURLY_BRACE$1, CHAR_LEFT_PARENTHESES$1, CHAR_LEFT_SQUARE_BRACKET$1, CHAR_PLUS2, CHAR_QUESTION_MARK2, CHAR_RIGHT_CURLY_BRACE$1, CHAR_RIGHT_PARENTHESES$1, CHAR_RIGHT_SQUARE_BRACKET$1, isPathSeparator2, depth2, scan$2, scan_12, constants$5, utils$i, MAX_LENGTH$1, POSIX_REGEX_SOURCE2, REGEX_NON_SPECIAL_CHARS2, REGEX_SPECIAL_CHARS_BACKREF2, REPLACEMENTS2, expandRange2, syntaxError2, parse$h, parse_1$3, path$m, scan$12, parse$g, utils$h, constants$4, isObject$4, picomatch$4, picomatch_12, reservedWords$12, builtins$1, forbiddenIdentifiers2, old$1, pathModule, isWindows$6, fs$k, DEBUG$1, nextPartRe, splitRootRe, fs_realpath, fs$j, origRealpath, origRealpathSync, version$4, ok, old, isWindows$5, path$k, balancedMatch, balanced, braceExpansion, escSlash, escOpen, escClose, escComma, escPeriod, minimatch$1, minimatch_1, path$j, GLOBSTAR$2, expand$3, plTypes, qmark, star, twoStarDot, twoStarNoDot, charSet, reSpecials, addPatternStartSet, slashSplit, ext, braceExpand, MAX_PATTERN_LENGTH, assertValidPattern, SUBPARSE, globUnescape, regExpEscape, Minimatch$1, inheritsExports, inherits, inherits_browserExports, inherits_browser, hasRequiredInherits_browser, common$c, fs$i, path$i, minimatch, isAbsolute2, Minimatch2, sync$9, hasRequiredSync, wrappy_1, onceExports, once$2, wrappy$1, wrappy, reqs, once, inflight_1, glob_1, hasRequiredGlob, globExports, comma3, semicolon3, chars$12, intToChar3, charToInt3, td2, UrlType, COLUMN, SOURCES_INDEX, SOURCE_LINE, SOURCE_COLUMN, NAMES_INDEX, found, LINE_GTR_ZERO, COL_GTR_EQ_ZERO, LEAST_UPPER_BOUND, GREATEST_LOWER_BOUND, decodedMappings, traceSegment, originalPositionFor$1, get, put, addSegment, setSourceContent, decodedMap, encodedMap, srcExports$1, src$2, browserExports$1, browser$2, ms$1, hasRequiredMs$1, common$b, hasRequiredCommon, hasRequiredBrowser$1, nodeExports$1, node$1, hasRequiredNode$1, _debug, builtins2, isRunningWithYarnPnp, _require$3, filter, DEBUG, isCaseInsensitiveFS, isWindows$4, externalRE, isExternalUrl, dataUrlRE, isDataUrl, internalPrefixes, InternalPrefixRE, removeDir, renameDir, escapedSpaceCharacters, imageSetUrlRE, usingDynamicImport, dynamicImport, blankReplacer, requireResolveFromRootWithFallback, GRACEFUL_RENAME_TIMEOUT, GRACEFUL_REMOVE_DIR_TIMEOUT, groups, singleComment, multiComment, POSIX_SEP_RE, NATIVE_SEP_RE, DEFAULT_EXTENSIONS2, DEFAULT_EXTENSIONS_RE_GROUP, debug$f, dist$1, __importDefault, Worker_1, os_1, worker_threads_1, Worker, isArray$1, BitSet2, Chunk2, btoa$1, SourceMap2, toString$2, Mappings2, n$1, warned2, MagicString2, GIT_LFS_PREFIX, A2, C3, init3, E2, isDebug$6, debug$e, astralIdentifierCodes2, astralIdentifierStartCodes2, nonASCIIidentifierChars2, nonASCIIidentifierStartChars2, reservedWords2, ecma5AndLessKeywords2, keywords$12, keywordRelationalOperator2, nonASCIIidentifierStart2, nonASCIIidentifier2, TokenType3, beforeExpr2, startsExpr2, keywords$2, types$12, lineBreak2, lineBreakG2, nonASCIIwhitespace2, skipWhiteSpace2, ref2, hasOwnProperty$1, toString$1, hasOwn2, isArray2, loneSurrogate2, Position3, SourceLocation3, defaultOptions2, warnedAboutEcmaVersion2, SCOPE_TOP2, SCOPE_FUNCTION2, SCOPE_ASYNC2, SCOPE_GENERATOR2, SCOPE_ARROW2, SCOPE_SIMPLE_CATCH2, SCOPE_SUPER2, SCOPE_DIRECT_SUPER2, SCOPE_CLASS_STATIC_BLOCK2, SCOPE_VAR2, BIND_NONE2, BIND_VAR2, BIND_LEXICAL2, BIND_FUNCTION2, BIND_SIMPLE_CATCH2, BIND_OUTSIDE2, Parser$1, prototypeAccessors2, pp$92, literal2, DestructuringErrors3, pp$82, loopLabel2, switchLabel2, empty$12, FUNC_STATEMENT, FUNC_HANGING_STATEMENT2, FUNC_NULLABLE_ID, pp$72, TokContext3, types$2, pp$62, pp$52, empty2, pp$42, pp$32, Scope4, Node3, pp$22, ecma9BinaryProperties2, ecma10BinaryProperties2, ecma11BinaryProperties2, ecma12BinaryProperties2, ecma13BinaryProperties2, ecma14BinaryProperties2, unicodeBinaryProperties2, unicodeGeneralCategoryValues2, ecma9ScriptValues2, ecma10ScriptValues2, ecma11ScriptValues2, ecma12ScriptValues2, ecma13ScriptValues2, ecma14ScriptValues2, unicodeScriptValues2, data2, ecmaVersion, i$1, list, pp$12, RegExpValidationState3, Token3, pp2, INVALID_TEMPLATE_ESCAPE_ERROR2, version$2, isWindows$3, own$1, messages, nodeInternalPrefix, userStackTraceLimit, captureLargerStackTrace, isDebug$5, debug$d, normalizedClientEntry$1, normalizedEnvEntry$1, isDebug$4, debug$c, externalTypes, tasks, utils$g, array$1, errno$1, fs$h, DirentFromStats$1, path$h, path$g, LEADING_DOT_SEGMENT_CHARACTERS_COUNT, UNESCAPED_GLOB_SYMBOLS_RE, pattern$1, isExtglob$1, isExtglob2, chars3, strictCheck, relaxedCheck, isGlob$2, isGlob$1, pathPosixDirname, isWin32, slash, backslash, enclosure, globby, escaped, globParent$2, utils$f, utils$e, stringify$7, isNumber$2, isNumber$1, toRegexRange$1, toRegexRange_1, util$1, toRegexRange, isObject3, transform$1, isValidValue, isNumber, zeros, stringify$6, pad, toMaxLen, toSequence, toRange, toRegex, rangeError, invalidRange, invalidStep, fillNumbers, fillLetters, fill$2, fillRange, fill$1, utils$d, compile$1, compile_1, fill, stringify$5, utils$c, append$1, expand$2, expand_1$1, constants$3, stringify$4, MAX_LENGTH2, CHAR_BACKSLASH, CHAR_BACKTICK, CHAR_COMMA2, CHAR_DOT2, CHAR_LEFT_PARENTHESES2, CHAR_RIGHT_PARENTHESES2, CHAR_LEFT_CURLY_BRACE2, CHAR_RIGHT_CURLY_BRACE2, CHAR_LEFT_SQUARE_BRACKET2, CHAR_RIGHT_SQUARE_BRACKET2, CHAR_DOUBLE_QUOTE, CHAR_SINGLE_QUOTE, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE, parse$c, parse_1$2, stringify$3, compile, expand$1, parse$b, braces$2, braces_1, util, braces$1, picomatch$2, utils$b, isEmptyString, micromatch$1, micromatch_1, path$f, globParent$1, micromatch, GLOBSTAR$1, ESCAPE_SYMBOL, COMMON_GLOB_SYMBOLS_RE, REGEX_CHARACTER_CLASS_SYMBOLS_RE, REGEX_GROUP_SYMBOLS_RE, GLOB_EXTENSION_SYMBOLS_RE, BRACE_EXPANSION_SEPARATORS_RE, stream$4, Stream, PassThrough, slice, merge2_1, merge2, string$2, array, errno, fs$g, path$e, pattern, stream$3, string$1, utils$a, patterns, DOUBLE_SLASH_RE$1, async$7, async$6, out$3, async$5, async$4, out$2, async$3, out$1, async$2, sync$8, settings$3, fs$f, fs$e, Settings$2, async$1, sync$7, settings_1$3, promise, queueMicrotask_1, runParallel_1, queueMicrotask$1, constants$22, NODE_PROCESS_VERSION_PARTS, MAJOR_VERSION, MINOR_VERSION, SUPPORTED_MAJOR_VERSION, SUPPORTED_MINOR_VERSION, IS_MATCHED_BY_MAJOR, IS_MATCHED_BY_MAJOR_AND_MINOR, utils$9, fs$d, DirentFromStats2, fs$c, common$a, fsStat$5, rpl, constants_1$1, utils$8, common$9, sync$6, fsStat$4, constants_1, utils$7, common$8, settings$2, fs$b, path$d, fsStat$3, fs$a, Settings$1, async, sync$5, settings_1$2, queueExports, queue, reusify_1, reusify, common$7, reader$1, common$6, Reader$1, events_1, fsScandir$2, fastq, common$5, reader_1$4, AsyncReader, async_1$4, AsyncProvider, stream$2, stream_1$5, async_1$3, StreamProvider, sync$4, sync$3, fsScandir$1, common$4, reader_1$3, SyncReader, sync_1$3, SyncProvider, settings$1, path$c, fsScandir, Settings3, async_1$2, stream_1$4, sync_1$2, settings_1$1, reader, path$b, fsStat$2, utils$6, Reader2, stream$1, stream_1$3, fsStat$1, fsWalk$2, reader_1$2, ReaderStream, fsWalk$1, reader_1$1, stream_1$2, ReaderAsync, provider, deep, partial, matcher, utils$5, Matcher, matcher_1, PartialMatcher, utils$4, partial_1, DeepFilter, entry$1, utils$32, EntryFilter, error$2, utils$22, ErrorFilter, entry, utils$12, EntryTransformer, path$a, deep_1, entry_1, error_1, entry_2, Provider, async_1$1, provider_1$2, ProviderAsync, stream, stream_1$1, stream_2, provider_1$1, ProviderStream, sync$2, sync$1, fsStat, fsWalk, reader_1, ReaderSync, sync_1$1, provider_1, ProviderSync, settings, taskManager, patternManager, async_1, stream_1, sync_1, settings_1, utils2, debug$b, _require$2, jsonLangs, jsonLangRE, isDebug$3, debug$a, dist, ALIAS, DOC, MAP, PAIR, SCALAR$1, SEQ, NODE_TYPE, isAlias, isDocument, isMap, isPair, isScalar$1, isSeq, hasAnchor, NodeBase2, BREAK$1, SKIP$1, REMOVE$1, escapeChars, escapeTagName, Directives, Alias, isScalarValue, Scalar, defaultTagPrefix, isEmptyPath, Collection, stringifyComment, lineComment, FOLD_FLOW, FOLD_BLOCK, FOLD_QUOTED, getFoldOptions, containsDocumentMarker, MERGE_KEY, isMergeKey, Pair, YAMLMap, map, YAMLSeq, seq, string, nullTag, boolTag, floatNaN$1, floatExp$1, float$1, intIdentify$2, intResolve$1, intOct$1, int$1, intHex$1, schema$2, stringifyJSON, jsonScalars, jsonError, schema$1, binary, pairs, YAMLOMap, omap, trueTag, falseTag, floatNaN, floatExp, float, intIdentify, intBin, intOct, int, intHex, YAMLSet, set, intTime, floatTime, timestamp, schema, schemas, tagsByName, coreKnownTags, sortMapEntriesByKey, Schema, Document, YAMLError, YAMLParseError, YAMLWarning, prettifyError, startColMsg, blockMsg, isBlock, escapeCodes, CN, Composer, stringify$1, BREAK, SKIP, REMOVE, BOM, DOCUMENT, FLOW_END, SCALAR, isCollection, isScalar, cst, hexDigits, tagChars, invalidFlowScalarChars, invalidAnchorChars, isNotAnchorChar, Lexer, LineCounter, Parser4, YAML, browser$1, require$$3$1, createRequire, createRequireFromPath, req_1, req$1, options, options_1, req, load, plugins, plugins_1, resolve3, url$4, config$1, yaml, loadOptions, loadPlugins, interopRequireDefault, processResult, createContext, importDefault, addTypeScriptLoader, withTypeScriptLoader, rc, mainExports, main$1, name, version$12, description, main, types2, exports, scripts, repository, keywords2, readmeFilename, license, devDependencies, engines, require$$3, fs$9, path$9, os$2, packageJson, version3, LINE, DotenvModule, parse_1$1, modulePreloadPolyfillId, resolvedModulePreloadPolyfillId, moduleScriptRE, modulePreloadLinkRE, importMapAppendRE, cssModuleRE, varRE, cssUrlRE, cssDataUriRE, importCssRE, cssImageSetRE, UrlRewritePostcssPlugin, cssNotProcessedRE, loadedPreprocessors, _require$1, scss, sass, less, ViteLessManager, styl, preProcessors, base2, isMatch$1, scan2, basename2, dirname2, relative2, join, debugHmr, normalizedClientDir, Stats, convertSourceMap, debugLoad, debugTransform, debugCache$1, isDebug$2, isDebug$1, debug$9, clientDir, normalizedClientEntry, normalizedEnvEntry, wasmHelper, wasmHelperCode, debug$8, isDebugEnabled$1, debuggerViteDeps, isDebugEnabled, MAX_TEMP_DIR_AGE_MS, preloadMarker, preloadMarkerWithQuote, srcExports, src, browserExports, browser, debugExports, debug$6, ms, hasRequiredMs, hasRequiredDebug, hasRequiredBrowser, nodeExports, node, hasRequiredNode, encodeurl, ENCODE_CHARS_REGEXP, UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE, matchHtmlRegExp, escapeHtml_1, onFinishedExports, onFinished$2, eeFirst, first, defer$2, parseurlExports, parseurl$1, url$3, parse$7, Url, require$$0$12, codes, statuses$1, unpipe_1, debug$5, encodeUrl, escapeHtml, onFinished, parseUrl$1, statuses, unpipe, DOUBLE_SPACE_REGEXP, NEWLINE_REGEXP, defer$1, isFinished, finalhandler_1, utilsMergeExports, utilsMerge, debug$4, EventEmitter$3, finalhandler, http$4, parseUrl, env2, proto, defer, libExports$1, lib$1, getOwnPropertySymbols, hasOwnProperty2, propIsEnumerable, objectAssign, varyExports, vary$1, FIELD_NAME_REGEXP, chokidar, fs$8, Readable, sysPath$3, promisify$3, picomatch$12, readdir$1, stat$3, lstat$2, realpath$1, BANG$2, RECURSIVE_ERROR_CODE, NORMAL_FLOW_ERRORS, FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE, ALL_TYPES, isNormalFlowError, maj, min, wantBigintFsStats, normalizeFilter, ReaddirpStream, readdirp$1, readdirpPromise, readdirp_1, anymatchExports, anymatch$2, normalizePath$2, picomatch2, normalizePath$1, BANG$1, DEFAULT_OPTIONS, arrify$1, createPattern, matchPatterns, anymatch$1, binaryExtensionsExports, binaryExtensions$1, require$$02, path$8, binaryExtensions, extensions, isBinaryPath$1, constants$12, fs$7, sysPath$2, promisify$2, isBinaryPath, isWindows$2, isLinux, EMPTY_FN$2, EMPTY_STR$1, KEY_LISTENERS, KEY_ERR, KEY_RAW, HANDLER_KEYS, EV_CHANGE$2, EV_ADD$2, EV_ADD_DIR$2, EV_ERROR$2, STR_DATA$1, STR_END$2, BRACE_START$1, STAR2, THROTTLE_MODE_WATCH, open$1, stat$2, lstat$1, close, fsrealpath, statMethods$1, foreach, addAndConvert, clearItem, delFromSet, isEmptySet, FsWatchInstances, fsWatchBroadcast, setFsWatchListener, FsWatchFileInstances, setFsWatchFileListener, NodeFsHandler$1, nodefsHandler, fseventsHandlerExports, fseventsHandler, fs$6, sysPath$1, promisify$1, fsevents, EV_ADD$1, EV_CHANGE$1, EV_ADD_DIR$1, EV_UNLINK$1, EV_ERROR$1, STR_DATA, STR_END$1, FSEVENT_CREATED, FSEVENT_MODIFIED, FSEVENT_DELETED, FSEVENT_MOVED, FSEVENT_UNKNOWN, FSEVENT_TYPE_FILE, FSEVENT_TYPE_DIRECTORY, FSEVENT_TYPE_SYMLINK, ROOT_GLOBSTAR, DIR_SUFFIX, DOT_SLASH, FUNCTION_TYPE$1, EMPTY_FN$1, IDENTITY_FN, Depth, stat$1, lstat2, realpath3, statMethods, FSEventsWatchers, consolidateThreshhold, wrongEventFlags, createFSEventsInstance, couldConsolidate, canUse, calcDepth, sameTypes, FsEventsHandler$1, EventEmitter$2, fs$5, sysPath, promisify, readdirp, anymatch, globParent2, isGlob2, braces, normalizePath, NodeFsHandler2, FsEventsHandler2, EV_ALL, EV_READY, EV_ADD, EV_CHANGE, EV_UNLINK, EV_ADD_DIR, EV_UNLINK_DIR, EV_RAW, EV_ERROR, STR_CLOSE, STR_END, BACK_SLASH_RE, DOUBLE_SLASH_RE, SLASH_OR_BACK_SLASH_RE, DOT_RE, REPLACER_RE, SLASH, SLASH_SLASH, BRACE_START, BANG, ONE_DOT, TWO_DOTS, GLOBSTAR, SLASH_GLOBSTAR, ANYMATCH_OPTS, STRING_TYPE, FUNCTION_TYPE, EMPTY_STR, EMPTY_FN, isWindows$1, isMacos, isIBMi, stat, readdir2, arrify, flatten, unifyPaths, toUnix, normalizePathToUnix, normalizeIgnored, getAbsolutePath, undef, DirEntry, STAT_METHOD_F, STAT_METHOD_L, WatchHelper, FSWatcher, watch2, shellQuote$1, CONTROL, META, BAREWORD, SINGLE_QUOTE, DOUBLE_QUOTE, TOKEN, i, offset3, bufferUtilExports, bufferUtil$1, constants2, EMPTY_BUFFER$3, FastBuffer$2, kDone, kRun, Limiter$1, limiter, zlib, bufferUtil, Limiter2, kStatusCode$2, FastBuffer$1, TRAILER, kPerMessageDeflate, kTotalLength, kCallback, kBuffers, kError$1, zlibLimiter, PerMessageDeflate$4, permessageDeflate, validationExports, validation, isUtf8, tokenChars$2, Writable$1, PerMessageDeflate$3, BINARY_TYPES$1, EMPTY_BUFFER$2, kStatusCode$1, kWebSocket$2, concat, toArrayBuffer, unmask, isValidStatusCode$1, isValidUTF8, FastBuffer, GET_INFO, GET_PAYLOAD_LENGTH_16, GET_PAYLOAD_LENGTH_64, GET_MASK, GET_DATA, INFLATING, Receiver$1, receiver, randomFillSync, PerMessageDeflate$2, EMPTY_BUFFER$1, isValidStatusCode, applyMask, toBuffer$1, kByteLength, maskBuffer, Sender$1, sender, kForOnEventAttribute$1, kListener$1, kCode, kData, kError, kMessage, kReason, kTarget, kType, kWasClean, Event, CloseEvent, ErrorEvent, MessageEvent, EventTarget, eventTarget, tokenChars$1, extension$1, EventEmitter$1, https$2, http$3, net, tls, randomBytes, createHash$12, URL$2, PerMessageDeflate$1, Receiver2, Sender2, BINARY_TYPES, EMPTY_BUFFER, GUID$1, kForOnEventAttribute, kListener, kStatusCode, kWebSocket$1, NOOP, addEventListener, removeEventListener, format, parse$3, toBuffer, closeTimeout, kAborted, protocolVersions, readyStates, subprotocolRegex, WebSocket$1, tokenChars, createHash, GUID, kWebSocket, httpProxyExports$1, httpProxy$3, httpProxyExports, httpProxy$2, eventemitter3Exports, eventemitter3, common$3, requiresPort, url$1, common$2, redirectRegex, webOutgoing, followRedirectsExports, followRedirects$1, debug$3, debug_1, url, URL$1, http$1, https$1, Writable, assert, debug$2, events, eventHandlers, RedirectionError, TooManyRedirectsError, MaxBodyLengthExceededError, WriteAfterEndError, httpNative, httpsNative, web_o, common$1, followRedirects, nativeAgents, webIncoming, http, https, common, wsIncoming, ProxyServer, httpProxy$1, debug$1, libExports, lib, debugCache, isDebug, logTime, isWslExports, isWsl$2, fs$3, isDocker$2, isDocker_1, os, fs$2, isDocker$1, isWsl$1, defineLazyProp, path$3, childProcess, fs$1, fsConstants, isWsl, isDocker, defineLazyProperty, localXdgOpenPath, platform2, arch, hasContainerEnv, cachedResult, getWslDrivesMountPoint, pTryEach, baseOpen, open, openApp, apps, crossSpawnExports, crossSpawn, windows, hasRequiredWindows, mode, hasRequiredMode, core, isexe_1, isWindows2, path$2, COLON, isexe, getNotFoundError, getPathInfo, which$1, whichSync, which_1, pathKeyExports, pathKey$1, pathKey, path$12, which, getPathKey, resolveCommand_1, _escape, metaCharsRegExp, shebangRegex$1, shebangRegex, shebangCommand$1, fs, shebangCommand, readShebang_1, path3, resolveCommand, escape$1, readShebang, isWin$1, isExecutableRegExp, isCmdShimRegExp, parse_12, isWin, enoent$1, cp, parse6, enoent, debug, _require;
var init_dep_79892de8 = __esm({
  "node_modules/vite/dist/node/chunks/dep-79892de8.js"() {
    import_node_fs2 = __toESM(require("fs"), 1);
    import_node_path4 = __toESM(require("path"), 1);
    import_node_url2 = require("url");
    import_node_perf_hooks3 = require("perf_hooks");
    import_node_module = require("module");
    import_tty = __toESM(require("tty"), 1);
    import_esbuild = __toESM(require_main(), 1);
    import_path2 = __toESM(require("path"), 1);
    import_fs = __toESM(require("fs"), 1);
    import_events = __toESM(require("events"), 1);
    import_assert = __toESM(require("assert"), 1);
    import_util = __toESM(require("util"), 1);
    import_net = __toESM(require("net"), 1);
    import_url = __toESM(require("url"), 1);
    import_http = __toESM(require("http"), 1);
    import_stream = __toESM(require("stream"), 1);
    import_os = __toESM(require("os"), 1);
    import_child_process = __toESM(require("child_process"), 1);
    import_node_os = __toESM(require("os"), 1);
    import_node_crypto3 = require("crypto");
    import_node_util = require("util");
    import_node_dns = require("dns");
    import_resolve = __toESM(require_resolve(), 1);
    init_constants();
    import_crypto = __toESM(require("crypto"), 1);
    import_node_buffer = require("buffer");
    import_promises3 = __toESM(require("fs/promises"), 1);
    import_module = __toESM(require("module"), 1);
    import_node_assert = __toESM(require("assert"), 1);
    import_node_process3 = __toESM(require("process"), 1);
    import_node_v8 = __toESM(require("v8"), 1);
    import_worker_threads = __toESM(require("worker_threads"), 1);
    import_zlib = __toESM(require("zlib"), 1);
    import_buffer = __toESM(require("buffer"), 1);
    import_https = __toESM(require("https"), 1);
    import_tls = __toESM(require("tls"), 1);
    import_node_http = require("http");
    import_node_https = require("https");
    init_rollup();
    import_node_readline = __toESM(require("readline"), 1);
    import_node_child_process = require("child_process");
    import_node_zlib = __toESM(require("zlib"), 1);
    import_node_url3 = require("url");
    import_node_path5 = require("path");
    import_node_module2 = require("module");
    import_meta2 = {};
    __filename2 = (0, import_node_url3.fileURLToPath)(import_meta2.url);
    __dirname2 = (0, import_node_path5.dirname)(__filename2);
    require2 = (0, import_node_module2.createRequire)(import_meta2.url);
    __require = require2;
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    picocolorsExports = {};
    picocolors = {
      get exports() {
        return picocolorsExports;
      },
      set exports(v) {
        picocolorsExports = v;
      }
    };
    tty2 = import_tty.default;
    isColorSupported2 = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.argv.includes("--color") || process.platform === "win32" || tty2.isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env);
    formatter = (open2, close2, replace = open2) => (input) => {
      let string2 = "" + input;
      let index = string2.indexOf(close2, open2.length);
      return ~index ? open2 + replaceClose2(string2, close2, replace, index) + close2 : open2 + string2 + close2;
    };
    replaceClose2 = (string2, close2, replace, index) => {
      let start = string2.substring(0, index) + replace;
      let end = string2.substring(index + close2.length);
      let nextIndex3 = end.indexOf(close2);
      return ~nextIndex3 ? start + replaceClose2(end, close2, replace, nextIndex3) : start + end;
    };
    createColors2 = (enabled = isColorSupported2) => ({
      isColorSupported: enabled,
      reset: enabled ? (s) => `\x1B[0m${s}\x1B[0m` : String,
      bold: enabled ? formatter("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m") : String,
      dim: enabled ? formatter("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m") : String,
      italic: enabled ? formatter("\x1B[3m", "\x1B[23m") : String,
      underline: enabled ? formatter("\x1B[4m", "\x1B[24m") : String,
      inverse: enabled ? formatter("\x1B[7m", "\x1B[27m") : String,
      hidden: enabled ? formatter("\x1B[8m", "\x1B[28m") : String,
      strikethrough: enabled ? formatter("\x1B[9m", "\x1B[29m") : String,
      black: enabled ? formatter("\x1B[30m", "\x1B[39m") : String,
      red: enabled ? formatter("\x1B[31m", "\x1B[39m") : String,
      green: enabled ? formatter("\x1B[32m", "\x1B[39m") : String,
      yellow: enabled ? formatter("\x1B[33m", "\x1B[39m") : String,
      blue: enabled ? formatter("\x1B[34m", "\x1B[39m") : String,
      magenta: enabled ? formatter("\x1B[35m", "\x1B[39m") : String,
      cyan: enabled ? formatter("\x1B[36m", "\x1B[39m") : String,
      white: enabled ? formatter("\x1B[37m", "\x1B[39m") : String,
      gray: enabled ? formatter("\x1B[90m", "\x1B[39m") : String,
      bgBlack: enabled ? formatter("\x1B[40m", "\x1B[49m") : String,
      bgRed: enabled ? formatter("\x1B[41m", "\x1B[49m") : String,
      bgGreen: enabled ? formatter("\x1B[42m", "\x1B[49m") : String,
      bgYellow: enabled ? formatter("\x1B[43m", "\x1B[49m") : String,
      bgBlue: enabled ? formatter("\x1B[44m", "\x1B[49m") : String,
      bgMagenta: enabled ? formatter("\x1B[45m", "\x1B[49m") : String,
      bgCyan: enabled ? formatter("\x1B[46m", "\x1B[49m") : String,
      bgWhite: enabled ? formatter("\x1B[47m", "\x1B[49m") : String
    });
    picocolors.exports = createColors2();
    picocolorsExports.createColors = createColors2;
    picomatchExports2 = {};
    picomatch$5 = {
      get exports() {
        return picomatchExports2;
      },
      set exports(v) {
        picomatchExports2 = v;
      }
    };
    utils$k = {};
    path$n = import_path2.default;
    WIN_SLASH2 = "\\\\/";
    WIN_NO_SLASH2 = `[^${WIN_SLASH2}]`;
    DOT_LITERAL2 = "\\.";
    PLUS_LITERAL2 = "\\+";
    QMARK_LITERAL2 = "\\?";
    SLASH_LITERAL2 = "\\/";
    ONE_CHAR2 = "(?=.)";
    QMARK2 = "[^/]";
    END_ANCHOR2 = `(?:${SLASH_LITERAL2}|$)`;
    START_ANCHOR2 = `(?:^|${SLASH_LITERAL2})`;
    DOTS_SLASH2 = `${DOT_LITERAL2}{1,2}${END_ANCHOR2}`;
    NO_DOT2 = `(?!${DOT_LITERAL2})`;
    NO_DOTS2 = `(?!${START_ANCHOR2}${DOTS_SLASH2})`;
    NO_DOT_SLASH2 = `(?!${DOT_LITERAL2}{0,1}${END_ANCHOR2})`;
    NO_DOTS_SLASH2 = `(?!${DOTS_SLASH2})`;
    QMARK_NO_DOT2 = `[^.${SLASH_LITERAL2}]`;
    STAR$1 = `${QMARK2}*?`;
    POSIX_CHARS2 = {
      DOT_LITERAL: DOT_LITERAL2,
      PLUS_LITERAL: PLUS_LITERAL2,
      QMARK_LITERAL: QMARK_LITERAL2,
      SLASH_LITERAL: SLASH_LITERAL2,
      ONE_CHAR: ONE_CHAR2,
      QMARK: QMARK2,
      END_ANCHOR: END_ANCHOR2,
      DOTS_SLASH: DOTS_SLASH2,
      NO_DOT: NO_DOT2,
      NO_DOTS: NO_DOTS2,
      NO_DOT_SLASH: NO_DOT_SLASH2,
      NO_DOTS_SLASH: NO_DOTS_SLASH2,
      QMARK_NO_DOT: QMARK_NO_DOT2,
      STAR: STAR$1,
      START_ANCHOR: START_ANCHOR2
    };
    WINDOWS_CHARS2 = {
      ...POSIX_CHARS2,
      SLASH_LITERAL: `[${WIN_SLASH2}]`,
      QMARK: WIN_NO_SLASH2,
      STAR: `${WIN_NO_SLASH2}*?`,
      DOTS_SLASH: `${DOT_LITERAL2}{1,2}(?:[${WIN_SLASH2}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL2})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH2}])${DOT_LITERAL2}{1,2}(?:[${WIN_SLASH2}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL2}{0,1}(?:[${WIN_SLASH2}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL2}{1,2}(?:[${WIN_SLASH2}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH2}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH2}])`,
      END_ANCHOR: `(?:[${WIN_SLASH2}]|$)`
    };
    POSIX_REGEX_SOURCE$12 = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    constants$6 = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$12,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path$n.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars4) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars4.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win323) {
        return win323 === true ? WINDOWS_CHARS2 : POSIX_CHARS2;
      }
    };
    (function(exports2) {
      const path4 = import_path2.default;
      const win323 = process.platform === "win32";
      const {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL
      } = constants$6;
      exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
      exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
      exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
      exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
      exports2.removeBackslashes = (str) => {
        return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
          return match === "\\" ? "" : match;
        });
      };
      exports2.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split(".").map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
          return true;
        }
        return false;
      };
      exports2.isWindows = (options2) => {
        if (options2 && typeof options2.windows === "boolean") {
          return options2.windows;
        }
        return win323 === true || path4.sep === "\\";
      };
      exports2.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1)
          return input;
        if (input[idx - 1] === "\\")
          return exports2.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
      };
      exports2.removePrefix = (input, state = {}) => {
        let output = input;
        if (output.startsWith("./")) {
          output = output.slice(2);
          state.prefix = "./";
        }
        return output;
      };
      exports2.wrapOutput = (input, state = {}, options2 = {}) => {
        const prepend = options2.contains ? "" : "^";
        const append2 = options2.contains ? "" : "$";
        let output = `${prepend}(?:${input})${append2}`;
        if (state.negated === true) {
          output = `(?:^(?!${output}).*$)`;
        }
        return output;
      };
    })(utils$k);
    utils$j = utils$k;
    ({
      CHAR_ASTERISK: CHAR_ASTERISK2,
      CHAR_AT: (
        /* * */
        CHAR_AT2
      ),
      CHAR_BACKWARD_SLASH: (
        /* @ */
        CHAR_BACKWARD_SLASH2
      ),
      CHAR_COMMA: CHAR_COMMA$1,
      CHAR_DOT: CHAR_DOT$1,
      CHAR_EXCLAMATION_MARK: (
        /* . */
        CHAR_EXCLAMATION_MARK2
      ),
      CHAR_FORWARD_SLASH: (
        /* ! */
        CHAR_FORWARD_SLASH2
      ),
      CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1,
      CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1,
      CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1,
      CHAR_PLUS: (
        /* [ */
        CHAR_PLUS2
      ),
      CHAR_QUESTION_MARK: (
        /* + */
        CHAR_QUESTION_MARK2
      ),
      CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1,
      CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1,
      CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1
    } = constants$6);
    isPathSeparator2 = (code) => {
      return code === CHAR_FORWARD_SLASH2 || code === CHAR_BACKWARD_SLASH2;
    };
    depth2 = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    scan$2 = (input, options2) => {
      const opts = options2 || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob3 = false;
      let isExtglob3 = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces2 = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance3 = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance3();
        let next;
        if (code === CHAR_BACKWARD_SLASH2) {
          backslashes = token.backslashes = true;
          code = advance3();
          if (code === CHAR_LEFT_CURLY_BRACE$1) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE$1) {
          braces2++;
          while (eos() !== true && (code = advance3())) {
            if (code === CHAR_BACKWARD_SLASH2) {
              backslashes = token.backslashes = true;
              advance3();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE$1) {
              braces2++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT$1 && (code = advance3()) === CHAR_DOT$1) {
              isBrace = token.isBrace = true;
              isGlob3 = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA$1) {
              isBrace = token.isBrace = true;
              isGlob3 = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE$1) {
              braces2--;
              if (braces2 === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH2) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT$1 && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS2 || code === CHAR_AT2 || code === CHAR_ASTERISK2 || code === CHAR_QUESTION_MARK2 || code === CHAR_EXCLAMATION_MARK2;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES$1) {
            isGlob3 = token.isGlob = true;
            isExtglob3 = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK2 && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance3())) {
                if (code === CHAR_BACKWARD_SLASH2) {
                  backslashes = token.backslashes = true;
                  code = advance3();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES$1) {
                  isGlob3 = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK2) {
          if (prev === CHAR_ASTERISK2)
            isGlobstar = token.isGlobstar = true;
          isGlob3 = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK2) {
          isGlob3 = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET$1) {
          while (eos() !== true && (next = advance3())) {
            if (next === CHAR_BACKWARD_SLASH2) {
              backslashes = token.backslashes = true;
              advance3();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {
              isBracket = token.isBracket = true;
              isGlob3 = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK2 && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES$1) {
          isGlob3 = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance3())) {
              if (code === CHAR_LEFT_PARENTHESES$1) {
                backslashes = token.backslashes = true;
                code = advance3();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES$1) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob3 === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob3 = false;
        isGlob3 = false;
      }
      let base3 = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base3 && isGlob3 === true && lastIndex > 0) {
        base3 = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob3 === true) {
        base3 = "";
        glob = str;
      } else {
        base3 = str;
      }
      if (base3 && base3 !== "" && base3 !== "/" && base3 !== str) {
        if (isPathSeparator2(base3.charCodeAt(base3.length - 1))) {
          base3 = base3.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils$j.removeBackslashes(glob);
        if (base3 && backslashes === true) {
          base3 = utils$j.removeBackslashes(base3);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base: base3,
        glob,
        isBrace,
        isBracket,
        isGlob: isGlob3,
        isExtglob: isExtglob3,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator2(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n2 = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value2 = input.slice(n2, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value2;
            }
            depth2(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value2 !== "") {
            parts.push(value2);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value2 = input.slice(prevIndex + 1);
          parts.push(value2);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value2;
            depth2(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    scan_12 = scan$2;
    constants$5 = constants$6;
    utils$i = utils$k;
    ({
      MAX_LENGTH: MAX_LENGTH$1,
      POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE2,
      REGEX_NON_SPECIAL_CHARS: REGEX_NON_SPECIAL_CHARS2,
      REGEX_SPECIAL_CHARS_BACKREF: REGEX_SPECIAL_CHARS_BACKREF2,
      REPLACEMENTS: REPLACEMENTS2
    } = constants$5);
    expandRange2 = (args, options2) => {
      if (typeof options2.expandRange === "function") {
        return options2.expandRange(...args, options2);
      }
      args.sort();
      const value2 = `[${args.join("-")}]`;
      return value2;
    };
    syntaxError2 = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    parse$h = (input, options2) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS2[input] || input;
      const opts = { ...options2 };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win323 = utils$i.isWindows(options2);
      const PLATFORM_CHARS = constants$5.globChars(win323);
      const EXTGLOB_CHARS = constants$5.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL: DOT_LITERAL3,
        PLUS_LITERAL: PLUS_LITERAL3,
        SLASH_LITERAL: SLASH_LITERAL3,
        ONE_CHAR: ONE_CHAR3,
        DOTS_SLASH: DOTS_SLASH3,
        NO_DOT: NO_DOT3,
        NO_DOT_SLASH: NO_DOT_SLASH3,
        NO_DOTS_SLASH: NO_DOTS_SLASH3,
        QMARK: QMARK3,
        QMARK_NO_DOT: QMARK_NO_DOT3,
        STAR: STAR3,
        START_ANCHOR: START_ANCHOR3
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR3}${opts2.dot ? DOTS_SLASH3 : DOT_LITERAL3}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT3;
      const qmarkNoDot = opts.dot ? QMARK3 : QMARK_NO_DOT3;
      let star2 = opts.bash === true ? globstar(opts) : STAR3;
      if (opts.capture) {
        star2 = `(${star2})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils$i.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces2 = [];
      const stack = [];
      let prev = bos;
      let value2;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n2 = 1) => input[state.index + n2];
      const advance3 = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value3 = "", num = 0) => {
        state.consumed += value3;
        state.index += num;
      };
      const append2 = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance3();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push2 = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob3 = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob3) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star2;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append2(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value3) => {
        const token = { ...EXTGLOB_CHARS[value3], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push2({ type, value: value3, output: state.output ? "" : ONE_CHAR3 });
        push2({ type: "paren", extglob: true, value: advance3(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star2;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star2 || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse$h(rest, { ...options2, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push2({ type: "paren", extglob: true, value: value2, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF2, (m, esc, chars4, first2, rest, index) => {
          if (first2 === "\\") {
            backslashes = true;
            return m;
          }
          if (first2 === "?") {
            if (esc) {
              return esc + first2 + (rest ? QMARK3.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK3.repeat(rest.length) : "");
            }
            return QMARK3.repeat(chars4.length);
          }
          if (first2 === ".") {
            return DOT_LITERAL3.repeat(chars4.length);
          }
          if (first2 === "*") {
            if (esc) {
              return esc + first2 + (rest ? star2 : "");
            }
            return star2;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils$i.wrapOutput(output, state, options2);
        return state;
      }
      while (!eos()) {
        value2 = advance3();
        if (value2 === "\0") {
          continue;
        }
        if (value2 === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value2 += "\\";
            push2({ type: "text", value: value2 });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value2 += "\\";
            }
          }
          if (opts.unescape === true) {
            value2 = advance3();
          } else {
            value2 += advance3();
          }
          if (state.brackets === 0) {
            push2({ type: "text", value: value2 });
            continue;
          }
        }
        if (state.brackets > 0 && (value2 !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value2 === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix3 = POSIX_REGEX_SOURCE2[rest2];
                if (posix3) {
                  prev.value = pre + posix3;
                  state.backtrack = true;
                  advance3();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR3;
                  }
                  continue;
                }
              }
            }
          }
          if (value2 === "[" && peek() !== ":" || value2 === "-" && peek() === "]") {
            value2 = `\\${value2}`;
          }
          if (value2 === "]" && (prev.value === "[" || prev.value === "[^")) {
            value2 = `\\${value2}`;
          }
          if (opts.posix === true && value2 === "!" && prev.value === "[") {
            value2 = "^";
          }
          prev.value += value2;
          append2({ value: value2 });
          continue;
        }
        if (state.quotes === 1 && value2 !== '"') {
          value2 = utils$i.escapeRegex(value2);
          prev.value += value2;
          append2({ value: value2 });
          continue;
        }
        if (value2 === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push2({ type: "text", value: value2 });
          }
          continue;
        }
        if (value2 === "(") {
          increment("parens");
          push2({ type: "paren", value: value2 });
          continue;
        }
        if (value2 === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError2("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push2({ type: "paren", value: value2, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value2 === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError2("closing", "]"));
            }
            value2 = `\\${value2}`;
          } else {
            increment("brackets");
          }
          push2({ type: "bracket", value: value2 });
          continue;
        }
        if (value2 === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push2({ type: "text", value: value2, output: `\\${value2}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError2("opening", "["));
            }
            push2({ type: "text", value: value2, output: `\\${value2}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value2 = `/${value2}`;
          }
          prev.value += value2;
          append2({ value: value2 });
          if (opts.literalBrackets === false || utils$i.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped2 = utils$i.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped2;
            prev.value = escaped2;
            continue;
          }
          prev.value = `(${capture}${escaped2}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value2 === "{" && opts.nobrace !== true) {
          increment("braces");
          const open2 = {
            type: "brace",
            value: value2,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces2.push(open2);
          push2(open2);
          continue;
        }
        if (value2 === "}") {
          const brace = braces2[braces2.length - 1];
          if (opts.nobrace === true || !brace) {
            push2({ type: "text", value: value2, output: value2 });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange2(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value2 = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push2({ type: "brace", value: value2, output });
          decrement("braces");
          braces2.pop();
          continue;
        }
        if (value2 === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === ",") {
          let output = value2;
          const brace = braces2[braces2.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push2({ type: "comma", value: value2, output });
          continue;
        }
        if (value2 === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push2({ type: "slash", value: value2, output: SLASH_LITERAL3 });
          continue;
        }
        if (value2 === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL3;
            const brace = braces2[braces2.length - 1];
            prev.type = "dots";
            prev.output += value2;
            prev.value += value2;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push2({ type: "text", value: value2, output: DOT_LITERAL3 });
            continue;
          }
          push2({ type: "dot", value: value2, output: DOT_LITERAL3 });
          continue;
        }
        if (value2 === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value2);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value2;
            if (next === "<" && !utils$i.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value2}`;
            }
            push2({ type: "text", value: value2, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push2({ type: "qmark", value: value2, output: QMARK_NO_DOT3 });
            continue;
          }
          push2({ type: "qmark", value: value2, output: QMARK3 });
          continue;
        }
        if (value2 === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value2);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value2 === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value2);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push2({ type: "plus", value: value2, output: PLUS_LITERAL3 });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push2({ type: "plus", value: value2 });
            continue;
          }
          push2({ type: "plus", value: PLUS_LITERAL3 });
          continue;
        }
        if (value2 === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push2({ type: "at", extglob: true, value: value2, output: "" });
            continue;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 !== "*") {
          if (value2 === "$" || value2 === "^") {
            value2 = `\\${value2}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS2.exec(remaining());
          if (match) {
            value2 += match[0];
            state.index += match[0].length;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value2;
          prev.output = star2;
          state.backtrack = true;
          state.globstar = true;
          consume(value2);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value2);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value2);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push2({ type: "star", value: value2, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob3 = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob3) {
            push2({ type: "star", value: value2, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value2;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value2);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value2;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value2);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL3}|${SLASH_LITERAL3}${end})`;
            prev.value += value2;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value2 + advance3());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value2;
            prev.output = `(?:^|${SLASH_LITERAL3}|${globstar(opts)}${SLASH_LITERAL3})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value2 + advance3());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value2;
          state.output += prev.output;
          state.globstar = true;
          consume(value2);
          continue;
        }
        const token = { type: "star", value: value2, output: star2 };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push2(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value2;
          push2(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH3;
            prev.output += NO_DOT_SLASH3;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH3;
            prev.output += NO_DOTS_SLASH3;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR3;
            prev.output += ONE_CHAR3;
          }
        }
        push2(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError2("closing", "]"));
        state.output = utils$i.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError2("closing", ")"));
        state.output = utils$i.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError2("closing", "}"));
        state.output = utils$i.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL3}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse$h.fastpaths = (input, options2) => {
      const opts = { ...options2 };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS2[input] || input;
      const win323 = utils$i.isWindows(options2);
      const {
        DOT_LITERAL: DOT_LITERAL3,
        SLASH_LITERAL: SLASH_LITERAL3,
        ONE_CHAR: ONE_CHAR3,
        DOTS_SLASH: DOTS_SLASH3,
        NO_DOT: NO_DOT3,
        NO_DOTS: NO_DOTS3,
        NO_DOTS_SLASH: NO_DOTS_SLASH3,
        STAR: STAR3,
        START_ANCHOR: START_ANCHOR3
      } = constants$5.globChars(win323);
      const nodot = opts.dot ? NO_DOTS3 : NO_DOT3;
      const slashDot = opts.dot ? NO_DOTS_SLASH3 : NO_DOT3;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star2 = opts.bash === true ? ".*?" : STAR3;
      if (opts.capture) {
        star2 = `(${star2})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star2;
        return `(${capture}(?:(?!${START_ANCHOR3}${opts2.dot ? DOTS_SLASH3 : DOT_LITERAL3}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR3}${star2}`;
          case ".*":
            return `${DOT_LITERAL3}${ONE_CHAR3}${star2}`;
          case "*.*":
            return `${nodot}${star2}${DOT_LITERAL3}${ONE_CHAR3}${star2}`;
          case "*/*":
            return `${nodot}${star2}${SLASH_LITERAL3}${ONE_CHAR3}${slashDot}${star2}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL3})?${slashDot}${ONE_CHAR3}${star2}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL3})?${slashDot}${star2}${DOT_LITERAL3}${ONE_CHAR3}${star2}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL3})?${DOT_LITERAL3}${ONE_CHAR3}${star2}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL3 + match[2];
          }
        }
      };
      const output = utils$i.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL3}?`;
      }
      return source;
    };
    parse_1$3 = parse$h;
    path$m = import_path2.default;
    scan$12 = scan_12;
    parse$g = parse_1$3;
    utils$h = utils$k;
    constants$4 = constants$6;
    isObject$4 = (val) => val && typeof val === "object" && !Array.isArray(val);
    picomatch$4 = (glob, options2, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch$4(input, options2, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject$4(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options2 || {};
      const posix3 = utils$h.isWindows(options2);
      const regex = isState ? picomatch$4.compileRe(glob, options2) : picomatch$4.makeRe(glob, options2, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored2 = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options2, ignore: null, onMatch: null, onResult: null };
        isIgnored2 = picomatch$4(opts.ignore, ignoreOpts, returnState);
      }
      const matcher2 = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch$4.test(input, regex, options2, { glob, posix: posix3 });
        const result = { glob, state, regex, posix: posix3, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored2(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher2.state = state;
      }
      return matcher2;
    };
    picomatch$4.test = (input, regex, options2, { glob, posix: posix3 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options2 || {};
      const format2 = opts.format || (posix3 ? utils$h.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format2 ? format2(input) : input;
      if (match === false) {
        output = format2 ? format2(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch$4.matchBase(input, regex, options2, posix3);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch$4.matchBase = (input, glob, options2, posix3 = utils$h.isWindows(options2)) => {
      const regex = glob instanceof RegExp ? glob : picomatch$4.makeRe(glob, options2);
      return regex.test(path$m.basename(input));
    };
    picomatch$4.isMatch = (str, patterns2, options2) => picomatch$4(patterns2, options2)(str);
    picomatch$4.parse = (pattern2, options2) => {
      if (Array.isArray(pattern2))
        return pattern2.map((p) => picomatch$4.parse(p, options2));
      return parse$g(pattern2, { ...options2, fastpaths: false });
    };
    picomatch$4.scan = (input, options2) => scan$12(input, options2);
    picomatch$4.compileRe = (state, options2, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options2 || {};
      const prepend = opts.contains ? "" : "^";
      const append2 = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append2}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch$4.toRegex(source, options2);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch$4.makeRe = (input, options2 = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options2.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse$g.fastpaths(input, options2);
      }
      if (!parsed.output) {
        parsed = parse$g(input, options2);
      }
      return picomatch$4.compileRe(parsed, options2, returnOutput, returnState);
    };
    picomatch$4.toRegex = (source, options2) => {
      try {
        const opts = options2 || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options2 && options2.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch$4.constants = constants$4;
    picomatch_12 = picomatch$4;
    (function(module2) {
      module2.exports = picomatch_12;
    })(picomatch$5);
    reservedWords$12 = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
    builtins$1 = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
    forbiddenIdentifiers2 = new Set(`${reservedWords$12} ${builtins$1}`.split(" "));
    forbiddenIdentifiers2.add("");
    old$1 = {};
    pathModule = import_path2.default;
    isWindows$6 = process.platform === "win32";
    fs$k = import_fs.default;
    DEBUG$1 = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    if (isWindows$6) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    if (isWindows$6) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    old$1.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current3;
      var base3;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current3 = m[0];
        base3 = m[0];
        previous = "";
        if (isWindows$6 && !knownHard[base3]) {
          fs$k.lstatSync(base3);
          knownHard[base3] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current3;
        current3 += result[0];
        base3 = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base3] || cache && cache[base3] === base3) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base3)) {
          resolvedLink = cache[base3];
        } else {
          var stat2 = fs$k.lstatSync(base3);
          if (!stat2.isSymbolicLink()) {
            knownHard[base3] = true;
            if (cache)
              cache[base3] = base3;
            continue;
          }
          var linkTarget = null;
          if (!isWindows$6) {
            var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs$k.statSync(base3);
            linkTarget = fs$k.readlinkSync(base3);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base3] = resolvedLink;
          if (!isWindows$6)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    old$1.realpath = function realpath2(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current3;
      var base3;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current3 = m[0];
        base3 = m[0];
        previous = "";
        if (isWindows$6 && !knownHard[base3]) {
          fs$k.lstat(base3, function(err) {
            if (err)
              return cb(err);
            knownHard[base3] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current3;
        current3 += result[0];
        base3 = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base3] || cache && cache[base3] === base3) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base3)) {
          return gotResolvedLink(cache[base3]);
        }
        return fs$k.lstat(base3, gotStat);
      }
      function gotStat(err, stat2) {
        if (err)
          return cb(err);
        if (!stat2.isSymbolicLink()) {
          knownHard[base3] = true;
          if (cache)
            cache[base3] = base3;
          return process.nextTick(LOOP);
        }
        if (!isWindows$6) {
          var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base3);
          }
        }
        fs$k.stat(base3, function(err2) {
          if (err2)
            return cb(err2);
          fs$k.readlink(base3, function(err3, target) {
            if (!isWindows$6)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base4) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base4] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
    fs_realpath = realpath$2;
    realpath$2.realpath = realpath$2;
    realpath$2.sync = realpathSync2;
    realpath$2.realpathSync = realpathSync2;
    realpath$2.monkeypatch = monkeypatch;
    realpath$2.unmonkeypatch = unmonkeypatch;
    fs$j = import_fs.default;
    origRealpath = fs$j.realpath;
    origRealpathSync = fs$j.realpathSync;
    version$4 = process.version;
    ok = /^v[0-5]\./.test(version$4);
    old = old$1;
    isWindows$5 = typeof process === "object" && process && process.platform === "win32";
    path$k = isWindows$5 ? { sep: "\\" } : { sep: "/" };
    balancedMatch = balanced$1;
    balanced$1.range = range$1;
    balanced = balancedMatch;
    braceExpansion = expandTop;
    escSlash = "\0SLASH" + Math.random() + "\0";
    escOpen = "\0OPEN" + Math.random() + "\0";
    escClose = "\0CLOSE" + Math.random() + "\0";
    escComma = "\0COMMA" + Math.random() + "\0";
    escPeriod = "\0PERIOD" + Math.random() + "\0";
    minimatch$1 = minimatch_1 = (p, pattern2, options2 = {}) => {
      assertValidPattern(pattern2);
      if (!options2.nocomment && pattern2.charAt(0) === "#") {
        return false;
      }
      return new Minimatch$1(pattern2, options2).match(p);
    };
    minimatch_1 = minimatch$1;
    path$j = path$k;
    minimatch$1.sep = path$j.sep;
    GLOBSTAR$2 = Symbol("globstar **");
    minimatch$1.GLOBSTAR = GLOBSTAR$2;
    expand$3 = braceExpansion;
    plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    qmark = "[^/]";
    star = qmark + "*?";
    twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    charSet = (s) => s.split("").reduce((set2, c) => {
      set2[c] = true;
      return set2;
    }, {});
    reSpecials = charSet("().*{}+?[]^$\\!");
    addPatternStartSet = charSet("[.(");
    slashSplit = /\/+/;
    minimatch$1.filter = (pattern2, options2 = {}) => (p, i, list) => minimatch$1(p, pattern2, options2);
    ext = (a, b = {}) => {
      const t = {};
      Object.keys(a).forEach((k) => t[k] = a[k]);
      Object.keys(b).forEach((k) => t[k] = b[k]);
      return t;
    };
    minimatch$1.defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch$1;
      }
      const orig = minimatch$1;
      const m = (p, pattern2, options2) => orig(p, pattern2, ext(def, options2));
      m.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern2, options2) {
          super(pattern2, ext(def, options2));
        }
      };
      m.Minimatch.defaults = (options2) => orig.defaults(ext(def, options2)).Minimatch;
      m.filter = (pattern2, options2) => orig.filter(pattern2, ext(def, options2));
      m.defaults = (options2) => orig.defaults(ext(def, options2));
      m.makeRe = (pattern2, options2) => orig.makeRe(pattern2, ext(def, options2));
      m.braceExpand = (pattern2, options2) => orig.braceExpand(pattern2, ext(def, options2));
      m.match = (list, pattern2, options2) => orig.match(list, pattern2, ext(def, options2));
      return m;
    };
    minimatch$1.braceExpand = (pattern2, options2) => braceExpand(pattern2, options2);
    braceExpand = (pattern2, options2 = {}) => {
      assertValidPattern(pattern2);
      if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern2)) {
        return [pattern2];
      }
      return expand$3(pattern2);
    };
    MAX_PATTERN_LENGTH = 1024 * 64;
    assertValidPattern = (pattern2) => {
      if (typeof pattern2 !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern2.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    SUBPARSE = Symbol("subparse");
    minimatch$1.makeRe = (pattern2, options2) => new Minimatch$1(pattern2, options2 || {}).makeRe();
    minimatch$1.match = (list, pattern2, options2 = {}) => {
      const mm = new Minimatch$1(pattern2, options2);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern2);
      }
      return list;
    };
    globUnescape = (s) => s.replace(/\\(.)/g, "$1");
    regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    Minimatch$1 = class Minimatch {
      constructor(pattern2, options2) {
        assertValidPattern(pattern2);
        if (!options2)
          options2 = {};
        this.options = options2;
        this.set = [];
        this.pattern = pattern2;
        this.windowsPathsNoEscape = !!options2.windowsPathsNoEscape || options2.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options2.partial;
        this.make();
      }
      debug() {
      }
      make() {
        const pattern2 = this.pattern;
        const options2 = this.options;
        if (!options2.nocomment && pattern2.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern2) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        let set2 = this.globSet = this.braceExpand();
        if (options2.debug)
          this.debug = (...args) => console.error(...args);
        this.debug(this.pattern, set2);
        set2 = this.globParts = set2.map((s) => s.split(slashSplit));
        this.debug(this.pattern, set2);
        set2 = set2.map((s, si, set3) => s.map(this.parse, this));
        this.debug(this.pattern, set2);
        set2 = set2.filter((s) => s.indexOf(false) === -1);
        this.debug(this.pattern, set2);
        this.set = set2;
      }
      parseNegate() {
        if (this.options.nonegate)
          return;
        const pattern2 = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern2.length && pattern2.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern2.substr(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern2, partial2) {
        var options2 = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern: pattern2 }
        );
        this.debug("matchOne", file.length, pattern2.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern2.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern2[pi];
          var f = file[fi];
          this.debug(pattern2, p, f);
          if (p === false)
            return false;
          if (p === GLOBSTAR$2) {
            this.debug("GLOBSTAR", [pattern2, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern2, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern2.slice(pr), partial2)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern2, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial2) {
              this.debug("\n>>> no match, partial?", file, fr, pattern2, pr);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial2;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern2, isSub) {
        assertValidPattern(pattern2);
        const options2 = this.options;
        if (pattern2 === "**") {
          if (!options2.noglobstar)
            return GLOBSTAR$2;
          else
            pattern2 = "*";
        }
        if (pattern2 === "")
          return "";
        let re = "";
        let hasMagic = !!options2.nocase;
        let escaping = false;
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        const patternStart = pattern2.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = () => {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            this.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        };
        for (let i = 0, c; i < pattern2.length && (c = pattern2.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern2, i, re, c);
          if (escaping) {
            if (c === "/") {
              return false;
            }
            if (reSpecials[c]) {
              re += "\\";
            }
            re += c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/": {
              return false;
            }
            case "\\":
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern2, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1)
                  c = "^";
                re += c;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options2.noext)
                clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              patternListStack.push({
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              });
              re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }
              clearStateChar();
              hasMagic = true;
              pl = patternListStack.pop();
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(pl);
              }
              pl.reEnd = re.length;
              continue;
            case "|":
              if (inClass || !patternListStack.length) {
                re += "\\|";
                continue;
              }
              clearStateChar();
              re += "|";
              continue;
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                continue;
              }
              cs = pattern2.substring(classStart + 1, i);
              hasMagic = true;
              inClass = false;
              re += c;
              continue;
            default:
              clearStateChar();
              if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
              break;
          }
        }
        if (inClass) {
          cs = pattern2.substr(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substr(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        const addPatternStart = addPatternStartSet[re.charAt(0)];
        for (let n2 = negativeLists.length - 1; n2 > -1; n2--) {
          const nl = negativeLists[n2];
          const nlBefore = re.slice(0, nl.reStart);
          const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          let nlAfter = re.slice(nl.reEnd);
          const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
          const openParensBefore = nlBefore.split("(").length - 1;
          let cleanAfter = nlAfter;
          for (let i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          const dollar = nlAfter === "" && isSub !== SUBPARSE ? "$" : "";
          re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (!hasMagic) {
          return globUnescape(pattern2);
        }
        const flags = options2.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re + "$", flags), {
            _glob: pattern2,
            _src: re
          });
        } catch (er) {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set2 = this.set;
        if (!set2.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options2 = this.options;
        const twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
        const flags = options2.nocase ? "i" : "";
        let re = set2.map((pattern2) => {
          pattern2 = pattern2.map(
            (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR$2 ? GLOBSTAR$2 : p._src
          ).reduce((set3, p) => {
            if (!(set3[set3.length - 1] === GLOBSTAR$2 && p === GLOBSTAR$2)) {
              set3.push(p);
            }
            return set3;
          }, []);
          pattern2.forEach((p, i) => {
            if (p !== GLOBSTAR$2 || pattern2[i - 1] === GLOBSTAR$2) {
              return;
            }
            if (i === 0) {
              if (pattern2.length > 1) {
                pattern2[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern2[i + 1];
              } else {
                pattern2[i] = twoStar;
              }
            } else if (i === pattern2.length - 1) {
              pattern2[i - 1] += "(?:\\/|" + twoStar + ")?";
            } else {
              pattern2[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern2[i + 1];
              pattern2[i + 1] = GLOBSTAR$2;
            }
          });
          return pattern2.filter((p) => p !== GLOBSTAR$2).join("/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate)
          re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      match(f, partial2 = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f === "";
        if (f === "/" && partial2)
          return true;
        const options2 = this.options;
        if (path$j.sep !== "/") {
          f = f.split(path$j.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        const set2 = this.set;
        this.debug(this.pattern, "set", set2);
        let filename;
        for (let i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename)
            break;
        }
        for (let i = 0; i < set2.length; i++) {
          const pattern2 = set2[i];
          let file = f;
          if (options2.matchBase && pattern2.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern2, partial2);
          if (hit) {
            if (options2.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options2.flipNegate)
          return false;
        return this.negate;
      }
      static defaults(def) {
        return minimatch$1.defaults(def).Minimatch;
      }
    };
    minimatch$1.Minimatch = Minimatch$1;
    inheritsExports = {};
    inherits = {
      get exports() {
        return inheritsExports;
      },
      set exports(v) {
        inheritsExports = v;
      }
    };
    inherits_browserExports = {};
    inherits_browser = {
      get exports() {
        return inherits_browserExports;
      },
      set exports(v) {
        inherits_browserExports = v;
      }
    };
    (function(module2) {
      try {
        var util2 = require2("util");
        if (typeof util2.inherits !== "function")
          throw "";
        module2.exports = util2.inherits;
      } catch (e) {
        module2.exports = requireInherits_browser();
      }
    })(inherits);
    common$c = {};
    common$c.setopts = setopts;
    common$c.ownProp = ownProp;
    common$c.makeAbs = makeAbs;
    common$c.finish = finish;
    common$c.mark = mark;
    common$c.isIgnored = isIgnored;
    common$c.childrenIgnored = childrenIgnored;
    fs$i = import_fs.default;
    path$i = import_path2.default;
    minimatch = minimatch_1;
    isAbsolute2 = import_path2.default.isAbsolute;
    Minimatch2 = minimatch.Minimatch;
    wrappy_1 = wrappy$2;
    onceExports = {};
    once$2 = {
      get exports() {
        return onceExports;
      },
      set exports(v) {
        onceExports = v;
      }
    };
    wrappy$1 = wrappy_1;
    once$2.exports = wrappy$1(once$1);
    onceExports.strict = wrappy$1(onceStrict);
    once$1.proto = once$1(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once$1(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    wrappy = wrappy_1;
    reqs = /* @__PURE__ */ Object.create(null);
    once = onceExports;
    inflight_1 = wrappy(inflight);
    globExports = requireGlob();
    comma3 = ",".charCodeAt(0);
    semicolon3 = ";".charCodeAt(0);
    chars$12 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    intToChar3 = new Uint8Array(64);
    charToInt3 = new Uint8Array(128);
    for (let i = 0; i < chars$12.length; i++) {
      const c = chars$12.charCodeAt(i);
      intToChar3[i] = c;
      charToInt3[c] = i;
    }
    td2 = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
      decode(buf) {
        const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
        return out.toString();
      }
    } : {
      decode(buf) {
        let out = "";
        for (let i = 0; i < buf.length; i++) {
          out += String.fromCharCode(buf[i]);
        }
        return out;
      }
    };
    (function(UrlType2) {
      UrlType2[UrlType2["Empty"] = 1] = "Empty";
      UrlType2[UrlType2["Hash"] = 2] = "Hash";
      UrlType2[UrlType2["Query"] = 3] = "Query";
      UrlType2[UrlType2["RelativePath"] = 4] = "RelativePath";
      UrlType2[UrlType2["AbsolutePath"] = 5] = "AbsolutePath";
      UrlType2[UrlType2["SchemeRelative"] = 6] = "SchemeRelative";
      UrlType2[UrlType2["Absolute"] = 7] = "Absolute";
    })(UrlType || (UrlType = {}));
    COLUMN = 0;
    SOURCES_INDEX = 1;
    SOURCE_LINE = 2;
    SOURCE_COLUMN = 3;
    NAMES_INDEX = 4;
    found = false;
    LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
    COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
    LEAST_UPPER_BOUND = -1;
    GREATEST_LOWER_BOUND = 1;
    (() => {
      decodedMappings = (map2) => {
        return map2._decoded || (map2._decoded = decode(map2._encoded));
      };
      traceSegment = (map2, line, column) => {
        const decoded = decodedMappings(map2);
        if (line >= decoded.length)
          return null;
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, map2._decodedMemo, line, column, GREATEST_LOWER_BOUND);
        return index === -1 ? null : segments[index];
      };
      originalPositionFor$1 = (map2, { line, column, bias }) => {
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO);
        const decoded = decodedMappings(map2);
        if (line >= decoded.length)
          return OMapping(null, null, null, null);
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, map2._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
        if (index === -1)
          return OMapping(null, null, null, null);
        const segment = segments[index];
        if (segment.length === 1)
          return OMapping(null, null, null, null);
        const { names, resolvedSources } = map2;
        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
      };
    })();
    (() => {
      get = (strarr, key) => strarr._indexes[key];
      put = (strarr, key) => {
        const index = get(strarr, key);
        if (index !== void 0)
          return index;
        const { array: array2, _indexes: indexes } = strarr;
        return indexes[key] = array2.push(key) - 1;
      };
    })();
    (() => {
      addSegment = (map2, genLine, genColumn, source, sourceLine, sourceColumn, name2) => {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map2;
        const line = getLine(mappings, genLine);
        if (source == null) {
          const seg2 = [genColumn];
          const index2 = getColumnIndex(line, genColumn, seg2);
          return insert(line, index2, seg2);
        }
        const sourcesIndex = put(sources, source);
        const seg = name2 ? [genColumn, sourcesIndex, sourceLine, sourceColumn, put(names, name2)] : [genColumn, sourcesIndex, sourceLine, sourceColumn];
        const index = getColumnIndex(line, genColumn, seg);
        if (sourcesIndex === sourcesContent.length)
          sourcesContent[sourcesIndex] = null;
        insert(line, index, seg);
      };
      setSourceContent = (map2, source, content) => {
        const { _sources: sources, _sourcesContent: sourcesContent } = map2;
        sourcesContent[put(sources, source)] = content;
      };
      decodedMap = (map2) => {
        const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map2;
        return {
          version: 3,
          file,
          names: names.array,
          sourceRoot: sourceRoot || void 0,
          sources: sources.array,
          sourcesContent,
          mappings
        };
      };
      encodedMap = (map2) => {
        const decoded = decodedMap(map2);
        return Object.assign(Object.assign({}, decoded), { mappings: encode$1(decoded.mappings) });
      };
    })();
    srcExports$1 = {};
    src$2 = {
      get exports() {
        return srcExports$1;
      },
      set exports(v) {
        srcExports$1 = v;
      }
    };
    browserExports$1 = {};
    browser$2 = {
      get exports() {
        return browserExports$1;
      },
      set exports(v) {
        browserExports$1 = v;
      }
    };
    nodeExports$1 = {};
    node$1 = {
      get exports() {
        return nodeExports$1;
      },
      set exports(v) {
        nodeExports$1 = v;
      }
    };
    (function(module2) {
      if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
        module2.exports = requireBrowser$1();
      } else {
        module2.exports = requireNode$1();
      }
    })(src$2);
    _debug = /* @__PURE__ */ getDefaultExportFromCjs2(srcExports$1);
    builtins2 = /* @__PURE__ */ new Set([
      ...import_node_module.builtinModules,
      "assert/strict",
      "diagnostics_channel",
      "dns/promises",
      "fs/promises",
      "path/posix",
      "path/win32",
      "readline/promises",
      "stream/consumers",
      "stream/promises",
      "stream/web",
      "timers/promises",
      "util/types",
      "wasi"
    ]);
    _require$3 = (0, import_node_module.createRequire)(import_meta2.url);
    try {
      isRunningWithYarnPnp = Boolean(_require$3("pnpapi"));
    } catch {
    }
    filter = process.env.VITE_DEBUG_FILTER;
    DEBUG = process.env.DEBUG;
    isCaseInsensitiveFS = testCaseInsensitiveFS();
    isWindows$4 = import_node_os.default.platform() === "win32";
    externalRE = /^(https?:)?\/\//;
    isExternalUrl = (url2) => externalRE.test(url2);
    dataUrlRE = /^\s*data:/i;
    isDataUrl = (url2) => dataUrlRE.test(url2);
    internalPrefixes = [
      FS_PREFIX,
      VALID_ID_PREFIX,
      CLIENT_PUBLIC_PATH,
      ENV_PUBLIC_PATH
    ];
    InternalPrefixRE = new RegExp(`^(?:${internalPrefixes.join("|")})`);
    removeDir = isWindows$4 ? (0, import_node_util.promisify)(gracefulRemoveDir) : function removeDirSync(dir) {
      if (import_node_fs2.default.existsSync(dir)) {
        import_node_fs2.default.rmSync(dir, { recursive: true, force: true });
      }
    };
    renameDir = isWindows$4 ? (0, import_node_util.promisify)(gracefulRename) : import_node_fs2.default.renameSync;
    escapedSpaceCharacters = /( |\\t|\\n|\\f|\\r)+/g;
    imageSetUrlRE = /^(?:[\w\-]+\(.*?\)|'.*?'|".*?"|\S*)/;
    usingDynamicImport = typeof jest === "undefined";
    dynamicImport = usingDynamicImport ? new Function("file", "return import(file)") : _require$3;
    blankReplacer = (match) => " ".repeat(match.length);
    requireResolveFromRootWithFallback = (root, id) => {
      const paths = _require$3.resolve.paths?.(id) || [];
      paths.unshift(root);
      import_resolve.default.sync(id, { basedir: root, paths });
      return _require$3.resolve(id, { paths });
    };
    GRACEFUL_RENAME_TIMEOUT = 5e3;
    GRACEFUL_REMOVE_DIR_TIMEOUT = 5e3;
    groups = [
      { name: "Assets", color: picocolorsExports.green },
      { name: "CSS", color: picocolorsExports.magenta },
      { name: "JS", color: picocolorsExports.cyan }
    ];
    singleComment = Symbol("singleComment");
    multiComment = Symbol("multiComment");
    POSIX_SEP_RE = new RegExp("\\" + import_path2.default.posix.sep, "g");
    NATIVE_SEP_RE = new RegExp("\\" + import_path2.default.sep, "g");
    DEFAULT_EXTENSIONS2 = [".ts", ".tsx", ".mts", ".cts"];
    DEFAULT_EXTENSIONS_RE_GROUP = `\\.(?:${DEFAULT_EXTENSIONS2.map((ext2) => ext2.substring(1)).join(
      "|"
    )})`;
    new Function("path", "return import(path).then(m => m.default)");
    debug$f = createDebugger("vite:esbuild");
    dist$1 = {};
    __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(dist$1, "__esModule", { value: true });
    Worker_1 = dist$1.Worker = void 0;
    os_1 = __importDefault(import_os.default);
    worker_threads_1 = import_worker_threads.default;
    Worker = class {
      constructor(fn, options2 = {}) {
        this.code = genWorkerCode(fn);
        this.max = options2.max || Math.max(1, os_1.default.cpus().length - 1);
        this.pool = [];
        this.idlePool = [];
        this.queue = [];
      }
      async run(...args) {
        const worker = await this._getAvailableWorker();
        return new Promise((resolve5, reject) => {
          worker.currentResolve = resolve5;
          worker.currentReject = reject;
          worker.postMessage(args);
        });
      }
      stop() {
        this.pool.forEach((w) => w.unref());
        this.queue.forEach(([_, reject]) => reject(new Error("Main worker pool stopped before a worker was available.")));
        this.pool = [];
        this.idlePool = [];
        this.queue = [];
      }
      async _getAvailableWorker() {
        if (this.idlePool.length) {
          return this.idlePool.shift();
        }
        if (this.pool.length < this.max) {
          const worker = new worker_threads_1.Worker(this.code, { eval: true });
          worker.on("message", (res) => {
            worker.currentResolve && worker.currentResolve(res);
            worker.currentResolve = null;
            this._assignDoneWorker(worker);
          });
          worker.on("error", (err) => {
            worker.currentReject && worker.currentReject(err);
            worker.currentReject = null;
          });
          worker.on("exit", (code) => {
            const i = this.pool.indexOf(worker);
            if (i > -1)
              this.pool.splice(i, 1);
            if (code !== 0 && worker.currentReject) {
              worker.currentReject(new Error(`Wroker stopped with non-0 exit code ${code}`));
              worker.currentReject = null;
            }
          });
          this.pool.push(worker);
          return worker;
        }
        let resolve5;
        let reject;
        const onWorkerAvailablePromise = new Promise((r, rj) => {
          resolve5 = r;
          reject = rj;
        });
        this.queue.push([resolve5, reject]);
        return onWorkerAvailablePromise;
      }
      _assignDoneWorker(worker) {
        if (this.queue.length) {
          const [resolve5] = this.queue.shift();
          resolve5(worker);
          return;
        }
        this.idlePool.push(worker);
      }
    };
    Worker_1 = dist$1.Worker = Worker;
    isArray$1 = Array.isArray || function(x) {
      return {}.toString.call(x) === "[object Array]";
    };
    BitSet2 = class {
      constructor(arg) {
        this.bits = arg instanceof BitSet2 ? arg.bits.slice() : [];
      }
      add(n2) {
        this.bits[n2 >> 5] |= 1 << (n2 & 31);
      }
      has(n2) {
        return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
      }
    };
    Chunk2 = class {
      constructor(start, end, content) {
        this.start = start;
        this.end = end;
        this.original = content;
        this.intro = "";
        this.outro = "";
        this.content = content;
        this.storeName = false;
        this.edited = false;
        {
          this.previous = null;
          this.next = null;
        }
      }
      appendLeft(content) {
        this.outro += content;
      }
      appendRight(content) {
        this.intro = this.intro + content;
      }
      clone() {
        const chunk = new Chunk2(this.start, this.end, this.original);
        chunk.intro = this.intro;
        chunk.outro = this.outro;
        chunk.content = this.content;
        chunk.storeName = this.storeName;
        chunk.edited = this.edited;
        return chunk;
      }
      contains(index) {
        return this.start < index && index < this.end;
      }
      eachNext(fn) {
        let chunk = this;
        while (chunk) {
          fn(chunk);
          chunk = chunk.next;
        }
      }
      eachPrevious(fn) {
        let chunk = this;
        while (chunk) {
          fn(chunk);
          chunk = chunk.previous;
        }
      }
      edit(content, storeName, contentOnly) {
        this.content = content;
        if (!contentOnly) {
          this.intro = "";
          this.outro = "";
        }
        this.storeName = storeName;
        this.edited = true;
        return this;
      }
      prependLeft(content) {
        this.outro = content + this.outro;
      }
      prependRight(content) {
        this.intro = content + this.intro;
      }
      split(index) {
        const sliceIndex = index - this.start;
        const originalBefore = this.original.slice(0, sliceIndex);
        const originalAfter = this.original.slice(sliceIndex);
        this.original = originalBefore;
        const newChunk = new Chunk2(index, this.end, originalAfter);
        newChunk.outro = this.outro;
        this.outro = "";
        this.end = index;
        if (this.edited) {
          newChunk.edit("", false);
          this.content = "";
        } else {
          this.content = originalBefore;
        }
        newChunk.next = this.next;
        if (newChunk.next)
          newChunk.next.previous = newChunk;
        newChunk.previous = this;
        this.next = newChunk;
        return newChunk;
      }
      toString() {
        return this.intro + this.content + this.outro;
      }
      trimEnd(rx) {
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length)
          return true;
        const trimmed = this.content.replace(rx, "");
        if (trimmed.length) {
          if (trimmed !== this.content) {
            this.split(this.start + trimmed.length).edit("", void 0, true);
          }
          return true;
        } else {
          this.edit("", void 0, true);
          this.intro = this.intro.replace(rx, "");
          if (this.intro.length)
            return true;
        }
      }
      trimStart(rx) {
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length)
          return true;
        const trimmed = this.content.replace(rx, "");
        if (trimmed.length) {
          if (trimmed !== this.content) {
            this.split(this.end - trimmed.length);
            this.edit("", void 0, true);
          }
          return true;
        } else {
          this.edit("", void 0, true);
          this.outro = this.outro.replace(rx, "");
          if (this.outro.length)
            return true;
        }
      }
    };
    btoa$1 = /* @__PURE__ */ getBtoa2();
    SourceMap2 = class {
      constructor(properties) {
        this.version = 3;
        this.file = properties.file;
        this.sources = properties.sources;
        this.sourcesContent = properties.sourcesContent;
        this.names = properties.names;
        this.mappings = encode$1(properties.mappings);
        if (typeof properties.x_google_ignoreList !== "undefined") {
          this.x_google_ignoreList = properties.x_google_ignoreList;
        }
      }
      toString() {
        return JSON.stringify(this);
      }
      toUrl() {
        return "data:application/json;charset=utf-8;base64," + btoa$1(this.toString());
      }
    };
    toString$2 = Object.prototype.toString;
    Mappings2 = class {
      constructor(hires) {
        this.hires = hires;
        this.generatedCodeLine = 0;
        this.generatedCodeColumn = 0;
        this.raw = [];
        this.rawSegments = this.raw[this.generatedCodeLine] = [];
        this.pending = null;
      }
      addEdit(sourceIndex, content, loc, nameIndex) {
        if (content.length) {
          const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
          if (nameIndex >= 0) {
            segment.push(nameIndex);
          }
          this.rawSegments.push(segment);
        } else if (this.pending) {
          this.rawSegments.push(this.pending);
        }
        this.advance(content);
        this.pending = null;
      }
      addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
        let originalCharIndex = chunk.start;
        let first2 = true;
        while (originalCharIndex < chunk.end) {
          if (this.hires || first2 || sourcemapLocations.has(originalCharIndex)) {
            this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
          }
          if (original[originalCharIndex] === "\n") {
            loc.line += 1;
            loc.column = 0;
            this.generatedCodeLine += 1;
            this.raw[this.generatedCodeLine] = this.rawSegments = [];
            this.generatedCodeColumn = 0;
            first2 = true;
          } else {
            loc.column += 1;
            this.generatedCodeColumn += 1;
            first2 = false;
          }
          originalCharIndex += 1;
        }
        this.pending = null;
      }
      advance(str) {
        if (!str)
          return;
        const lines = str.split("\n");
        if (lines.length > 1) {
          for (let i = 0; i < lines.length - 1; i++) {
            this.generatedCodeLine++;
            this.raw[this.generatedCodeLine] = this.rawSegments = [];
          }
          this.generatedCodeColumn = 0;
        }
        this.generatedCodeColumn += lines[lines.length - 1].length;
      }
    };
    n$1 = "\n";
    warned2 = {
      insertLeft: false,
      insertRight: false,
      storeName: false
    };
    MagicString2 = class {
      constructor(string2, options2 = {}) {
        const chunk = new Chunk2(0, string2.length, string2);
        Object.defineProperties(this, {
          original: { writable: true, value: string2 },
          outro: { writable: true, value: "" },
          intro: { writable: true, value: "" },
          firstChunk: { writable: true, value: chunk },
          lastChunk: { writable: true, value: chunk },
          lastSearchedChunk: { writable: true, value: chunk },
          byStart: { writable: true, value: {} },
          byEnd: { writable: true, value: {} },
          filename: { writable: true, value: options2.filename },
          indentExclusionRanges: { writable: true, value: options2.indentExclusionRanges },
          sourcemapLocations: { writable: true, value: new BitSet2() },
          storedNames: { writable: true, value: {} },
          indentStr: { writable: true, value: void 0 },
          ignoreList: { writable: true, value: options2.ignoreList }
        });
        this.byStart[0] = chunk;
        this.byEnd[string2.length] = chunk;
      }
      addSourcemapLocation(char) {
        this.sourcemapLocations.add(char);
      }
      append(content) {
        if (typeof content !== "string")
          throw new TypeError("outro content must be a string");
        this.outro += content;
        return this;
      }
      appendLeft(index, content) {
        if (typeof content !== "string")
          throw new TypeError("inserted content must be a string");
        this._split(index);
        const chunk = this.byEnd[index];
        if (chunk) {
          chunk.appendLeft(content);
        } else {
          this.intro += content;
        }
        return this;
      }
      appendRight(index, content) {
        if (typeof content !== "string")
          throw new TypeError("inserted content must be a string");
        this._split(index);
        const chunk = this.byStart[index];
        if (chunk) {
          chunk.appendRight(content);
        } else {
          this.outro += content;
        }
        return this;
      }
      clone() {
        const cloned = new MagicString2(this.original, { filename: this.filename });
        let originalChunk = this.firstChunk;
        let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
        while (originalChunk) {
          cloned.byStart[clonedChunk.start] = clonedChunk;
          cloned.byEnd[clonedChunk.end] = clonedChunk;
          const nextOriginalChunk = originalChunk.next;
          const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
          if (nextClonedChunk) {
            clonedChunk.next = nextClonedChunk;
            nextClonedChunk.previous = clonedChunk;
            clonedChunk = nextClonedChunk;
          }
          originalChunk = nextOriginalChunk;
        }
        cloned.lastChunk = clonedChunk;
        if (this.indentExclusionRanges) {
          cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
        }
        cloned.sourcemapLocations = new BitSet2(this.sourcemapLocations);
        cloned.intro = this.intro;
        cloned.outro = this.outro;
        return cloned;
      }
      generateDecodedMap(options2) {
        options2 = options2 || {};
        const sourceIndex = 0;
        const names = Object.keys(this.storedNames);
        const mappings = new Mappings2(options2.hires);
        const locate = getLocator2(this.original);
        if (this.intro) {
          mappings.advance(this.intro);
        }
        this.firstChunk.eachNext((chunk) => {
          const loc = locate(chunk.start);
          if (chunk.intro.length)
            mappings.advance(chunk.intro);
          if (chunk.edited) {
            mappings.addEdit(
              sourceIndex,
              chunk.content,
              loc,
              chunk.storeName ? names.indexOf(chunk.original) : -1
            );
          } else {
            mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
          }
          if (chunk.outro.length)
            mappings.advance(chunk.outro);
        });
        return {
          file: options2.file ? options2.file.split(/[/\\]/).pop() : void 0,
          sources: [options2.source ? getRelativePath2(options2.file || "", options2.source) : options2.file || ""],
          sourcesContent: options2.includeContent ? [this.original] : void 0,
          names,
          mappings: mappings.raw,
          x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
        };
      }
      generateMap(options2) {
        return new SourceMap2(this.generateDecodedMap(options2));
      }
      _ensureindentStr() {
        if (this.indentStr === void 0) {
          this.indentStr = guessIndent2(this.original);
        }
      }
      _getRawIndentString() {
        this._ensureindentStr();
        return this.indentStr;
      }
      getIndentString() {
        this._ensureindentStr();
        return this.indentStr === null ? "	" : this.indentStr;
      }
      indent(indentStr, options2) {
        const pattern2 = /^[^\r\n]/gm;
        if (isObject$1(indentStr)) {
          options2 = indentStr;
          indentStr = void 0;
        }
        if (indentStr === void 0) {
          this._ensureindentStr();
          indentStr = this.indentStr || "	";
        }
        if (indentStr === "")
          return this;
        options2 = options2 || {};
        const isExcluded = {};
        if (options2.exclude) {
          const exclusions = typeof options2.exclude[0] === "number" ? [options2.exclude] : options2.exclude;
          exclusions.forEach((exclusion) => {
            for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
              isExcluded[i] = true;
            }
          });
        }
        let shouldIndentNextCharacter = options2.indentStart !== false;
        const replacer = (match) => {
          if (shouldIndentNextCharacter)
            return `${indentStr}${match}`;
          shouldIndentNextCharacter = true;
          return match;
        };
        this.intro = this.intro.replace(pattern2, replacer);
        let charIndex = 0;
        let chunk = this.firstChunk;
        while (chunk) {
          const end = chunk.end;
          if (chunk.edited) {
            if (!isExcluded[charIndex]) {
              chunk.content = chunk.content.replace(pattern2, replacer);
              if (chunk.content.length) {
                shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
              }
            }
          } else {
            charIndex = chunk.start;
            while (charIndex < end) {
              if (!isExcluded[charIndex]) {
                const char = this.original[charIndex];
                if (char === "\n") {
                  shouldIndentNextCharacter = true;
                } else if (char !== "\r" && shouldIndentNextCharacter) {
                  shouldIndentNextCharacter = false;
                  if (charIndex === chunk.start) {
                    chunk.prependRight(indentStr);
                  } else {
                    this._splitChunk(chunk, charIndex);
                    chunk = chunk.next;
                    chunk.prependRight(indentStr);
                  }
                }
              }
              charIndex += 1;
            }
          }
          charIndex = chunk.end;
          chunk = chunk.next;
        }
        this.outro = this.outro.replace(pattern2, replacer);
        return this;
      }
      insert() {
        throw new Error(
          "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
        );
      }
      insertLeft(index, content) {
        if (!warned2.insertLeft) {
          console.warn(
            "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
          );
          warned2.insertLeft = true;
        }
        return this.appendLeft(index, content);
      }
      insertRight(index, content) {
        if (!warned2.insertRight) {
          console.warn(
            "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
          );
          warned2.insertRight = true;
        }
        return this.prependRight(index, content);
      }
      move(start, end, index) {
        if (index >= start && index <= end)
          throw new Error("Cannot move a selection inside itself");
        this._split(start);
        this._split(end);
        this._split(index);
        const first2 = this.byStart[start];
        const last = this.byEnd[end];
        const oldLeft = first2.previous;
        const oldRight = last.next;
        const newRight = this.byStart[index];
        if (!newRight && last === this.lastChunk)
          return this;
        const newLeft = newRight ? newRight.previous : this.lastChunk;
        if (oldLeft)
          oldLeft.next = oldRight;
        if (oldRight)
          oldRight.previous = oldLeft;
        if (newLeft)
          newLeft.next = first2;
        if (newRight)
          newRight.previous = last;
        if (!first2.previous)
          this.firstChunk = last.next;
        if (!last.next) {
          this.lastChunk = first2.previous;
          this.lastChunk.next = null;
        }
        first2.previous = newLeft;
        last.next = newRight || null;
        if (!newLeft)
          this.firstChunk = first2;
        if (!newRight)
          this.lastChunk = last;
        return this;
      }
      overwrite(start, end, content, options2) {
        options2 = options2 || {};
        return this.update(start, end, content, { ...options2, overwrite: !options2.contentOnly });
      }
      update(start, end, content, options2) {
        if (typeof content !== "string")
          throw new TypeError("replacement content must be a string");
        while (start < 0)
          start += this.original.length;
        while (end < 0)
          end += this.original.length;
        if (end > this.original.length)
          throw new Error("end is out of bounds");
        if (start === end)
          throw new Error(
            "Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead"
          );
        this._split(start);
        this._split(end);
        if (options2 === true) {
          if (!warned2.storeName) {
            console.warn(
              "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
            );
            warned2.storeName = true;
          }
          options2 = { storeName: true };
        }
        const storeName = options2 !== void 0 ? options2.storeName : false;
        const overwrite = options2 !== void 0 ? options2.overwrite : false;
        if (storeName) {
          const original = this.original.slice(start, end);
          Object.defineProperty(this.storedNames, original, {
            writable: true,
            value: true,
            enumerable: true
          });
        }
        const first2 = this.byStart[start];
        const last = this.byEnd[end];
        if (first2) {
          let chunk = first2;
          while (chunk !== last) {
            if (chunk.next !== this.byStart[chunk.end]) {
              throw new Error("Cannot overwrite across a split point");
            }
            chunk = chunk.next;
            chunk.edit("", false);
          }
          first2.edit(content, storeName, !overwrite);
        } else {
          const newChunk = new Chunk2(start, end, "").edit(content, storeName);
          last.next = newChunk;
          newChunk.previous = last;
        }
        return this;
      }
      prepend(content) {
        if (typeof content !== "string")
          throw new TypeError("outro content must be a string");
        this.intro = content + this.intro;
        return this;
      }
      prependLeft(index, content) {
        if (typeof content !== "string")
          throw new TypeError("inserted content must be a string");
        this._split(index);
        const chunk = this.byEnd[index];
        if (chunk) {
          chunk.prependLeft(content);
        } else {
          this.intro = content + this.intro;
        }
        return this;
      }
      prependRight(index, content) {
        if (typeof content !== "string")
          throw new TypeError("inserted content must be a string");
        this._split(index);
        const chunk = this.byStart[index];
        if (chunk) {
          chunk.prependRight(content);
        } else {
          this.outro = content + this.outro;
        }
        return this;
      }
      remove(start, end) {
        while (start < 0)
          start += this.original.length;
        while (end < 0)
          end += this.original.length;
        if (start === end)
          return this;
        if (start < 0 || end > this.original.length)
          throw new Error("Character is out of bounds");
        if (start > end)
          throw new Error("end must be greater than start");
        this._split(start);
        this._split(end);
        let chunk = this.byStart[start];
        while (chunk) {
          chunk.intro = "";
          chunk.outro = "";
          chunk.edit("");
          chunk = end > chunk.end ? this.byStart[chunk.end] : null;
        }
        return this;
      }
      lastChar() {
        if (this.outro.length)
          return this.outro[this.outro.length - 1];
        let chunk = this.lastChunk;
        do {
          if (chunk.outro.length)
            return chunk.outro[chunk.outro.length - 1];
          if (chunk.content.length)
            return chunk.content[chunk.content.length - 1];
          if (chunk.intro.length)
            return chunk.intro[chunk.intro.length - 1];
        } while (chunk = chunk.previous);
        if (this.intro.length)
          return this.intro[this.intro.length - 1];
        return "";
      }
      lastLine() {
        let lineIndex = this.outro.lastIndexOf(n$1);
        if (lineIndex !== -1)
          return this.outro.substr(lineIndex + 1);
        let lineStr = this.outro;
        let chunk = this.lastChunk;
        do {
          if (chunk.outro.length > 0) {
            lineIndex = chunk.outro.lastIndexOf(n$1);
            if (lineIndex !== -1)
              return chunk.outro.substr(lineIndex + 1) + lineStr;
            lineStr = chunk.outro + lineStr;
          }
          if (chunk.content.length > 0) {
            lineIndex = chunk.content.lastIndexOf(n$1);
            if (lineIndex !== -1)
              return chunk.content.substr(lineIndex + 1) + lineStr;
            lineStr = chunk.content + lineStr;
          }
          if (chunk.intro.length > 0) {
            lineIndex = chunk.intro.lastIndexOf(n$1);
            if (lineIndex !== -1)
              return chunk.intro.substr(lineIndex + 1) + lineStr;
            lineStr = chunk.intro + lineStr;
          }
        } while (chunk = chunk.previous);
        lineIndex = this.intro.lastIndexOf(n$1);
        if (lineIndex !== -1)
          return this.intro.substr(lineIndex + 1) + lineStr;
        return this.intro + lineStr;
      }
      slice(start = 0, end = this.original.length) {
        while (start < 0)
          start += this.original.length;
        while (end < 0)
          end += this.original.length;
        let result = "";
        let chunk = this.firstChunk;
        while (chunk && (chunk.start > start || chunk.end <= start)) {
          if (chunk.start < end && chunk.end >= end) {
            return result;
          }
          chunk = chunk.next;
        }
        if (chunk && chunk.edited && chunk.start !== start)
          throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
        const startChunk = chunk;
        while (chunk) {
          if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
            result += chunk.intro;
          }
          const containsEnd = chunk.start < end && chunk.end >= end;
          if (containsEnd && chunk.edited && chunk.end !== end)
            throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
          const sliceStart = startChunk === chunk ? start - chunk.start : 0;
          const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
          result += chunk.content.slice(sliceStart, sliceEnd);
          if (chunk.outro && (!containsEnd || chunk.end === end)) {
            result += chunk.outro;
          }
          if (containsEnd) {
            break;
          }
          chunk = chunk.next;
        }
        return result;
      }
      // TODO deprecate this? not really very useful
      snip(start, end) {
        const clone = this.clone();
        clone.remove(0, start);
        clone.remove(end, clone.original.length);
        return clone;
      }
      _split(index) {
        if (this.byStart[index] || this.byEnd[index])
          return;
        let chunk = this.lastSearchedChunk;
        const searchForward = index > chunk.end;
        while (chunk) {
          if (chunk.contains(index))
            return this._splitChunk(chunk, index);
          chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
        }
      }
      _splitChunk(chunk, index) {
        if (chunk.edited && chunk.content.length) {
          const loc = getLocator2(this.original)(index);
          throw new Error(
            `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \u2013 "${chunk.original}")`
          );
        }
        const newChunk = chunk.split(index);
        this.byEnd[index] = chunk;
        this.byStart[index] = newChunk;
        this.byEnd[newChunk.end] = newChunk;
        if (chunk === this.lastChunk)
          this.lastChunk = newChunk;
        this.lastSearchedChunk = chunk;
        return true;
      }
      toString() {
        let str = this.intro;
        let chunk = this.firstChunk;
        while (chunk) {
          str += chunk.toString();
          chunk = chunk.next;
        }
        return str + this.outro;
      }
      isEmpty() {
        let chunk = this.firstChunk;
        do {
          if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
            return false;
        } while (chunk = chunk.next);
        return true;
      }
      length() {
        let chunk = this.firstChunk;
        let length = 0;
        do {
          length += chunk.intro.length + chunk.content.length + chunk.outro.length;
        } while (chunk = chunk.next);
        return length;
      }
      trimLines() {
        return this.trim("[\\r\\n]");
      }
      trim(charType) {
        return this.trimStart(charType).trimEnd(charType);
      }
      trimEndAborted(charType) {
        const rx = new RegExp((charType || "\\s") + "+$");
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length)
          return true;
        let chunk = this.lastChunk;
        do {
          const end = chunk.end;
          const aborted = chunk.trimEnd(rx);
          if (chunk.end !== end) {
            if (this.lastChunk === chunk) {
              this.lastChunk = chunk.next;
            }
            this.byEnd[chunk.end] = chunk;
            this.byStart[chunk.next.start] = chunk.next;
            this.byEnd[chunk.next.end] = chunk.next;
          }
          if (aborted)
            return true;
          chunk = chunk.previous;
        } while (chunk);
        return false;
      }
      trimEnd(charType) {
        this.trimEndAborted(charType);
        return this;
      }
      trimStartAborted(charType) {
        const rx = new RegExp("^" + (charType || "\\s") + "+");
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length)
          return true;
        let chunk = this.firstChunk;
        do {
          const end = chunk.end;
          const aborted = chunk.trimStart(rx);
          if (chunk.end !== end) {
            if (chunk === this.lastChunk)
              this.lastChunk = chunk.next;
            this.byEnd[chunk.end] = chunk;
            this.byStart[chunk.next.start] = chunk.next;
            this.byEnd[chunk.next.end] = chunk.next;
          }
          if (aborted)
            return true;
          chunk = chunk.next;
        } while (chunk);
        return false;
      }
      trimStart(charType) {
        this.trimStartAborted(charType);
        return this;
      }
      hasChanged() {
        return this.original !== this.toString();
      }
      _replaceRegexp(searchValue, replacement) {
        function getReplacement(match, str) {
          if (typeof replacement === "string") {
            return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
              if (i === "$")
                return "$";
              if (i === "&")
                return match[0];
              const num = +i;
              if (num < match.length)
                return match[+i];
              return `$${i}`;
            });
          } else {
            return replacement(...match, match.index, str, match.groups);
          }
        }
        function matchAll(re, str) {
          let match;
          const matches = [];
          while (match = re.exec(str)) {
            matches.push(match);
          }
          return matches;
        }
        if (searchValue.global) {
          const matches = matchAll(searchValue, this.original);
          matches.forEach((match) => {
            if (match.index != null)
              this.overwrite(
                match.index,
                match.index + match[0].length,
                getReplacement(match, this.original)
              );
          });
        } else {
          const match = this.original.match(searchValue);
          if (match && match.index != null)
            this.overwrite(
              match.index,
              match.index + match[0].length,
              getReplacement(match, this.original)
            );
        }
        return this;
      }
      _replaceString(string2, replacement) {
        const { original } = this;
        const index = original.indexOf(string2);
        if (index !== -1) {
          this.overwrite(index, index + string2.length, replacement);
        }
        return this;
      }
      replace(searchValue, replacement) {
        if (typeof searchValue === "string") {
          return this._replaceString(searchValue, replacement);
        }
        return this._replaceRegexp(searchValue, replacement);
      }
      _replaceAllString(string2, replacement) {
        const { original } = this;
        const stringLength = string2.length;
        for (let index = original.indexOf(string2); index !== -1; index = original.indexOf(string2, index + stringLength)) {
          this.overwrite(index, index + stringLength, replacement);
        }
        return this;
      }
      replaceAll(searchValue, replacement) {
        if (typeof searchValue === "string") {
          return this._replaceAllString(searchValue, replacement);
        }
        if (!searchValue.global) {
          throw new TypeError(
            "MagicString.prototype.replaceAll called with a non-global RegExp argument"
          );
        }
        return this._replaceRegexp(searchValue, replacement);
      }
    };
    GIT_LFS_PREFIX = import_node_buffer.Buffer.from("version https://git-lfs.github.com");
    A2 = 1 === new Uint8Array(new Uint16Array([1]).buffer)[0];
    init3 = WebAssembly.compile((E2 = "AGFzbQEAAAABKghgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gAn9/AAMvLgABAQICAgICAgICAgICAgICAgIAAwMDBAQAAAADAAAAAAMDAAUGAAAABwAGAgUEBQFwAQEBBQMBAAEGDwJ/AUGw8gALfwBBsPIACwdwEwZtZW1vcnkCAAJzYQAAAWUAAwJpcwAEAmllAAUCc3MABgJzZQAHAmFpAAgCaWQACQJpcAAKAmVzAAsCZWUADANlbHMADQNlbGUADgJyaQAPAnJlABABZgARBXBhcnNlABILX19oZWFwX2Jhc2UDAQrAOy5oAQF/QQAgADYC9AlBACgC0AkiASAAQQF0aiIAQQA7AQBBACAAQQJqIgA2AvgJQQAgADYC/AlBAEEANgLUCUEAQQA2AuQJQQBBADYC3AlBAEEANgLYCUEAQQA2AuwJQQBBADYC4AkgAQufAQEDf0EAKALkCSEEQQBBACgC/AkiBTYC5AlBACAENgLoCUEAIAVBIGo2AvwJIARBHGpB1AkgBBsgBTYCAEEAKALICSEEQQAoAsQJIQYgBSABNgIAIAUgADYCCCAFIAIgAkECakEAIAYgA0YbIAQgA0YbNgIMIAUgAzYCFCAFQQA2AhAgBSACNgIEIAVBADYCHCAFQQAoAsQJIANGOgAYC1YBAX9BACgC7AkiBEEQakHYCSAEG0EAKAL8CSIENgIAQQAgBDYC7AlBACAEQRRqNgL8CSAEQQA2AhAgBCADNgIMIAQgAjYCCCAEIAE2AgQgBCAANgIACwgAQQAoAoAKCxUAQQAoAtwJKAIAQQAoAtAJa0EBdQseAQF/QQAoAtwJKAIEIgBBACgC0AlrQQF1QX8gABsLFQBBACgC3AkoAghBACgC0AlrQQF1Cx4BAX9BACgC3AkoAgwiAEEAKALQCWtBAXVBfyAAGwseAQF/QQAoAtwJKAIQIgBBACgC0AlrQQF1QX8gABsLOwEBfwJAQQAoAtwJKAIUIgBBACgCxAlHDQBBfw8LAkAgAEEAKALICUcNAEF+DwsgAEEAKALQCWtBAXULCwBBACgC3AktABgLFQBBACgC4AkoAgBBACgC0AlrQQF1CxUAQQAoAuAJKAIEQQAoAtAJa0EBdQseAQF/QQAoAuAJKAIIIgBBACgC0AlrQQF1QX8gABsLHgEBf0EAKALgCSgCDCIAQQAoAtAJa0EBdUF/IAAbCyUBAX9BAEEAKALcCSIAQRxqQdQJIAAbKAIAIgA2AtwJIABBAEcLJQEBf0EAQQAoAuAJIgBBEGpB2AkgABsoAgAiADYC4AkgAEEARwsIAEEALQCECgvmDAEGfyMAQYDQAGsiACQAQQBBAToAhApBAEEAKALMCTYCjApBAEEAKALQCUF+aiIBNgKgCkEAIAFBACgC9AlBAXRqIgI2AqQKQQBBADsBhgpBAEEAOwGICkEAQQA6AJAKQQBBADYCgApBAEEAOgDwCUEAIABBgBBqNgKUCkEAIAA2ApgKQQBBADoAnAoCQAJAAkACQANAQQAgAUECaiIDNgKgCiABIAJPDQECQCADLwEAIgJBd2pBBUkNAAJAAkACQAJAAkAgAkGbf2oOBQEICAgCAAsgAkEgRg0EIAJBL0YNAyACQTtGDQIMBwtBAC8BiAoNASADEBNFDQEgAUEEakGCCEEKEC0NARAUQQAtAIQKDQFBAEEAKAKgCiIBNgKMCgwHCyADEBNFDQAgAUEEakGMCEEKEC0NABAVC0EAQQAoAqAKNgKMCgwBCwJAIAEvAQQiA0EqRg0AIANBL0cNBBAWDAELQQEQFwtBACgCpAohAkEAKAKgCiEBDAALC0EAIQIgAyEBQQAtAPAJDQIMAQtBACABNgKgCkEAQQA6AIQKCwNAQQAgAUECaiIDNgKgCgJAAkACQAJAAkACQAJAAkACQCABQQAoAqQKTw0AIAMvAQAiAkF3akEFSQ0IAkACQAJAAkACQAJAAkACQAJAAkAgAkFgag4KEhEGEREREQUBAgALAkACQAJAAkAgAkGgf2oOCgsUFAMUARQUFAIACyACQYV/ag4DBRMGCQtBAC8BiAoNEiADEBNFDRIgAUEEakGCCEEKEC0NEhAUDBILIAMQE0UNESABQQRqQYwIQQoQLQ0REBUMEQsgAxATRQ0QIAEpAARC7ICEg7COwDlSDRAgAS8BDCIDQXdqIgFBF0sNDkEBIAF0QZ+AgARxRQ0ODA8LQQBBAC8BiAoiAUEBajsBiApBACgClAogAUEDdGoiAUEBNgIAIAFBACgCjAo2AgQMDwtBAC8BiAoiAkUNC0EAIAJBf2oiBDsBiApBAC8BhgoiAkUNDiACQQJ0QQAoApgKakF8aigCACIFKAIUQQAoApQKIARB//8DcUEDdGooAgRHDQ4CQCAFKAIEDQAgBSADNgIEC0EAIAJBf2o7AYYKIAUgAUEEajYCDAwOCwJAQQAoAowKIgEvAQBBKUcNAEEAKALkCSIDRQ0AIAMoAgQgAUcNAEEAQQAoAugJIgM2AuQJAkAgA0UNACADQQA2AhwMAQtBAEEANgLUCQtBAEEALwGICiIDQQFqOwGICkEAKAKUCiADQQN0aiIDQQZBAkEALQCcChs2AgAgAyABNgIEQQBBADoAnAoMDQtBAC8BiAoiAUUNCUEAIAFBf2oiATsBiApBACgClAogAUH//wNxQQN0aigCAEEERg0EDAwLQScQGAwLC0EiEBgMCgsgAkEvRw0JAkACQCABLwEEIgFBKkYNACABQS9HDQEQFgwMC0EBEBcMCwsCQAJAQQAoAowKIgEvAQAiAxAZRQ0AAkACQCADQVVqDgQACAEDCAsgAUF+ai8BAEErRg0GDAcLIAFBfmovAQBBLUYNBQwGCwJAIANB/QBGDQAgA0EpRw0FQQAoApQKQQAvAYgKQQN0aigCBBAaRQ0FDAYLQQAoApQKQQAvAYgKQQN0aiICKAIEEBsNBSACKAIAQQZGDQUMBAsgAUF+ai8BAEFQakH//wNxQQpJDQMMBAtBACgClApBAC8BiAoiAUEDdCIDakEAKAKMCjYCBEEAIAFBAWo7AYgKQQAoApQKIANqQQM2AgALEBwMBwtBAC0A8AlBAC8BhgpBAC8BiApyckUhAgwJCyABEB0NACADRQ0AIANBL0ZBAC0AkApBAEdxDQAgAUF+aiEBQQAoAtAJIQICQANAIAFBAmoiBCACTQ0BQQAgATYCjAogAS8BACEDIAFBfmoiBCEBIAMQHkUNAAsgBEECaiEEC0EBIQUgA0H//wNxEB9FDQEgBEF+aiEBAkADQCABQQJqIgMgAk0NAUEAIAE2AowKIAEvAQAhAyABQX5qIgQhASADEB8NAAsgBEECaiEDCyADECBFDQEQIUEAQQA6AJAKDAULECFBACEFC0EAIAU6AJAKDAMLECJBACECDAULIANBoAFHDQELQQBBAToAnAoLQQBBACgCoAo2AowKC0EAKAKgCiEBDAALCyAAQYDQAGokACACCxoAAkBBACgC0AkgAEcNAEEBDwsgAEF+ahAjC80JAQV/QQBBACgCoAoiAEEMaiIBNgKgCkEAKALsCSECQQEQJyEDAkACQAJAAkACQAJAAkACQAJAAkBBACgCoAoiBCABRw0AIAMQJkUNAQsCQAJAAkACQCADQSpGDQAgA0H7AEcNAUEAIARBAmo2AqAKQQEQJyEEQQAoAqAKIQEDQAJAAkAgBEH//wNxIgNBIkYNACADQSdGDQAgAxAqGkEAKAKgCiEDDAELIAMQGEEAQQAoAqAKQQJqIgM2AqAKC0EBECcaAkAgASADECsiBEEsRw0AQQBBACgCoApBAmo2AqAKQQEQJyEEC0EAKAKgCiEDIARB/QBGDQMgAyABRg0NIAMhASADQQAoAqQKTQ0ADA0LC0EAIARBAmo2AqAKQQEQJxpBACgCoAoiAyADECsaDAILQQBBADoAhAoCQAJAAkACQAJAAkAgA0Gff2oODAIIBAEIAwgICAgIBQALIANB9gBGDQQMBwtBACAEQQ5qIgM2AqAKAkACQAJAQQEQJ0Gff2oOBgAQAhAQARALQQAoAqAKIgEpAAJC84Dkg+CNwDFSDQ8gAS8BChAfRQ0PQQAgAUEKajYCoApBABAnGgtBACgCoAoiAUECakGiCEEOEC0NDiABLwEQIgBBd2oiAkEXSw0LQQEgAnRBn4CABHFFDQsMDAtBACgCoAoiASkAAkLsgISDsI7AOVINDSABLwEKIgBBd2oiAkEXTQ0HDAgLQQAgBEEKajYCoApBABAnGkEAKAKgCiEEC0EAIARBEGo2AqAKAkBBARAnIgRBKkcNAEEAQQAoAqAKQQJqNgKgCkEBECchBAtBACgCoAohAyAEECoaIANBACgCoAoiBCADIAQQAkEAQQAoAqAKQX5qNgKgCg8LAkAgBCkAAkLsgISDsI7AOVINACAELwEKEB5FDQBBACAEQQpqNgKgCkEBECchBEEAKAKgCiEDIAQQKhogA0EAKAKgCiIEIAMgBBACQQBBACgCoApBfmo2AqAKDwtBACAEQQRqIgQ2AqAKC0EAIARBBGoiAzYCoApBAEEAOgCECgJAA0BBACADQQJqNgKgCkEBECchBEEAKAKgCiEDIAQQKkEgckH7AEYNAUEAKAKgCiIEIANGDQQgAyAEIAMgBBACQQEQJ0EsRw0BQQAoAqAKIQMMAAsLQQBBACgCoApBfmo2AqAKDwtBACADQQJqNgKgCgtBARAnIQRBACgCoAohAwJAIARB5gBHDQAgA0ECakGcCEEGEC0NAEEAIANBCGo2AqAKIABBARAnECkgAkEQakHYCSACGyEDA0AgAygCACIDRQ0CIANCADcCCCADQRBqIQMMAAsLQQAgA0F+ajYCoAoLDwtBASACdEGfgIAEcQ0BCyAAQaABRg0AIABB+wBHDQQLQQAgAUEKajYCoApBARAnIgFB+wBGDQMMAgsCQCAAQVhqDgMBAwEACyAAQaABRw0CC0EAIAFBEGo2AqAKAkBBARAnIgFBKkcNAEEAQQAoAqAKQQJqNgKgCkEBECchAQsgAUEoRg0BC0EAKAKgCiECIAEQKhpBACgCoAoiASACTQ0AIAQgAyACIAEQAkEAQQAoAqAKQX5qNgKgCg8LIAQgA0EAQQAQAkEAIARBDGo2AqAKDwsQIgvUBgEEf0EAQQAoAqAKIgBBDGoiATYCoAoCQAJAAkACQAJAAkACQAJAAkACQEEBECciAkFZag4IBAIBBAEBAQMACyACQSJGDQMgAkH7AEYNBAtBACgCoAogAUcNAkEAIABBCmo2AqAKDwtBACgClApBAC8BiAoiAkEDdGoiAUEAKAKgCjYCBEEAIAJBAWo7AYgKIAFBBTYCAEEAKAKMCi8BAEEuRg0DQQBBACgCoAoiAUECajYCoApBARAnIQIgAEEAKAKgCkEAIAEQAUEAQQAvAYYKIgFBAWo7AYYKQQAoApgKIAFBAnRqQQAoAuQJNgIAAkAgAkEiRg0AIAJBJ0YNAEEAQQAoAqAKQX5qNgKgCg8LIAIQGEEAQQAoAqAKQQJqIgI2AqAKAkACQAJAQQEQJ0FXag4EAQICAAILQQBBACgCoApBAmo2AqAKQQEQJxpBACgC5AkiASACNgIEIAFBAToAGCABQQAoAqAKIgI2AhBBACACQX5qNgKgCg8LQQAoAuQJIgEgAjYCBCABQQE6ABhBAEEALwGICkF/ajsBiAogAUEAKAKgCkECajYCDEEAQQAvAYYKQX9qOwGGCg8LQQBBACgCoApBfmo2AqAKDwtBAEEAKAKgCkECajYCoApBARAnQe0ARw0CQQAoAqAKIgJBAmpBlghBBhAtDQICQEEAKAKMCiIBECgNACABLwEAQS5GDQMLIAAgACACQQhqQQAoAsgJEAEPC0EALwGICg0CQQAoAqAKIQJBACgCpAohAwNAIAIgA08NBQJAAkAgAi8BACIBQSdGDQAgAUEiRw0BCyAAIAEQKQ8LQQAgAkECaiICNgKgCgwACwtBACgCoAohAkEALwGICg0CAkADQAJAAkACQCACQQAoAqQKTw0AQQEQJyICQSJGDQEgAkEnRg0BIAJB/QBHDQJBAEEAKAKgCkECajYCoAoLQQEQJyEBQQAoAqAKIQICQCABQeYARw0AIAJBAmpBnAhBBhAtDQgLQQAgAkEIajYCoApBARAnIgJBIkYNAyACQSdGDQMMBwsgAhAYC0EAQQAoAqAKQQJqIgI2AqAKDAALCyAAIAIQKQsPC0EAQQAoAqAKQX5qNgKgCg8LQQAgAkF+ajYCoAoPCxAiC0cBA39BACgCoApBAmohAEEAKAKkCiEBAkADQCAAIgJBfmogAU8NASACQQJqIQAgAi8BAEF2ag4EAQAAAQALC0EAIAI2AqAKC5gBAQN/QQBBACgCoAoiAUECajYCoAogAUEGaiEBQQAoAqQKIQIDQAJAAkACQCABQXxqIAJPDQAgAUF+ai8BACEDAkACQCAADQAgA0EqRg0BIANBdmoOBAIEBAIECyADQSpHDQMLIAEvAQBBL0cNAkEAIAFBfmo2AqAKDAELIAFBfmohAQtBACABNgKgCg8LIAFBAmohAQwACwuIAQEEf0EAKAKgCiEBQQAoAqQKIQICQAJAA0AgASIDQQJqIQEgAyACTw0BIAEvAQAiBCAARg0CAkAgBEHcAEYNACAEQXZqDgQCAQECAQsgA0EEaiEBIAMvAQRBDUcNACADQQZqIAEgAy8BBkEKRhshAQwACwtBACABNgKgChAiDwtBACABNgKgCgtsAQF/AkACQCAAQV9qIgFBBUsNAEEBIAF0QTFxDQELIABBRmpB//8DcUEGSQ0AIABBKUcgAEFYakH//wNxQQdJcQ0AAkAgAEGlf2oOBAEAAAEACyAAQf0ARyAAQYV/akH//wNxQQRJcQ8LQQELLgEBf0EBIQECQCAAQZYJQQUQJA0AIABBoAlBAxAkDQAgAEGmCUECECQhAQsgAQuDAQECf0EBIQECQAJAAkACQAJAAkAgAC8BACICQUVqDgQFBAQBAAsCQCACQZt/ag4EAwQEAgALIAJBKUYNBCACQfkARw0DIABBfmpBsglBBhAkDwsgAEF+ai8BAEE9Rg8LIABBfmpBqglBBBAkDwsgAEF+akG+CUEDECQPC0EAIQELIAEL3gEBBH9BACgCoAohAEEAKAKkCiEBAkACQAJAA0AgACICQQJqIQAgAiABTw0BAkACQAJAIAAvAQAiA0Gkf2oOBQIDAwMBAAsgA0EkRw0CIAIvAQRB+wBHDQJBACACQQRqIgA2AqAKQQBBAC8BiAoiAkEBajsBiApBACgClAogAkEDdGoiAkEENgIAIAIgADYCBA8LQQAgADYCoApBAEEALwGICkF/aiIAOwGICkEAKAKUCiAAQf//A3FBA3RqKAIAQQNHDQMMBAsgAkEEaiEADAALC0EAIAA2AqAKCxAiCwu0AwECf0EAIQECQAJAAkACQAJAAkACQAJAAkACQCAALwEAQZx/ag4UAAECCQkJCQMJCQQFCQkGCQcJCQgJCwJAAkAgAEF+ai8BAEGXf2oOBAAKCgEKCyAAQXxqQboIQQIQJA8LIABBfGpBvghBAxAkDwsCQAJAAkAgAEF+ai8BAEGNf2oOAwABAgoLAkAgAEF8ai8BACICQeEARg0AIAJB7ABHDQogAEF6akHlABAlDwsgAEF6akHjABAlDwsgAEF8akHECEEEECQPCyAAQXxqQcwIQQYQJA8LIABBfmovAQBB7wBHDQYgAEF8ai8BAEHlAEcNBgJAIABBemovAQAiAkHwAEYNACACQeMARw0HIABBeGpB2AhBBhAkDwsgAEF4akHkCEECECQPCyAAQX5qQegIQQQQJA8LQQEhASAAQX5qIgBB6QAQJQ0EIABB8AhBBRAkDwsgAEF+akHkABAlDwsgAEF+akH6CEEHECQPCyAAQX5qQYgJQQQQJA8LAkAgAEF+ai8BACICQe8ARg0AIAJB5QBHDQEgAEF8akHuABAlDwsgAEF8akGQCUEDECQhAQsgAQs0AQF/QQEhAQJAIABBd2pB//8DcUEFSQ0AIABBgAFyQaABRg0AIABBLkcgABAmcSEBCyABCzABAX8CQAJAIABBd2oiAUEXSw0AQQEgAXRBjYCABHENAQsgAEGgAUYNAEEADwtBAQtOAQJ/QQAhAQJAAkAgAC8BACICQeUARg0AIAJB6wBHDQEgAEF+akHoCEEEECQPCyAAQX5qLwEAQfUARw0AIABBfGpBzAhBBhAkIQELIAELcAECfwJAAkADQEEAQQAoAqAKIgBBAmoiATYCoAogAEEAKAKkCk8NAQJAAkACQCABLwEAIgFBpX9qDgIBAgALAkAgAUF2ag4EBAMDBAALIAFBL0cNAgwECxAsGgwBC0EAIABBBGo2AqAKDAALCxAiCws1AQF/QQBBAToA8AlBACgCoAohAEEAQQAoAqQKQQJqNgKgCkEAIABBACgC0AlrQQF1NgKACgtDAQJ/QQEhAQJAIAAvAQAiAkF3akH//wNxQQVJDQAgAkGAAXJBoAFGDQBBACEBIAIQJkUNACACQS5HIAAQKHIPCyABC0YBA39BACEDAkAgACACQQF0IgJrIgRBAmoiAEEAKALQCSIFSQ0AIAAgASACEC0NAAJAIAAgBUcNAEEBDwsgBBAjIQMLIAMLPQECf0EAIQICQEEAKALQCSIDIABLDQAgAC8BACABRw0AAkAgAyAARw0AQQEPCyAAQX5qLwEAEB4hAgsgAgtoAQJ/QQEhAQJAAkAgAEFfaiICQQVLDQBBASACdEExcQ0BCyAAQfj/A3FBKEYNACAAQUZqQf//A3FBBkkNAAJAIABBpX9qIgJBA0sNACACQQFHDQELIABBhX9qQf//A3FBBEkhAQsgAQucAQEDf0EAKAKgCiEBAkADQAJAAkAgAS8BACICQS9HDQACQCABLwECIgFBKkYNACABQS9HDQQQFgwCCyAAEBcMAQsCQAJAIABFDQAgAkF3aiIBQRdLDQFBASABdEGfgIAEcUUNAQwCCyACEB9FDQMMAQsgAkGgAUcNAgtBAEEAKAKgCiIDQQJqIgE2AqAKIANBACgCpApJDQALCyACCzEBAX9BACEBAkAgAC8BAEEuRw0AIABBfmovAQBBLkcNACAAQXxqLwEAQS5GIQELIAELwgMBAX8CQCABQSJGDQAgAUEnRg0AECIPC0EAKAKgCiECIAEQGCAAIAJBAmpBACgCoApBACgCxAkQAUEAQQAoAqAKQQJqNgKgCkEAECchAEEAKAKgCiEBAkACQCAAQeEARw0AIAFBAmpBsAhBChAtRQ0BC0EAIAFBfmo2AqAKDwtBACABQQxqNgKgCgJAQQEQJ0H7AEYNAEEAIAE2AqAKDwtBACgCoAoiAiEAA0BBACAAQQJqNgKgCgJAAkACQEEBECciAEEiRg0AIABBJ0cNAUEnEBhBAEEAKAKgCkECajYCoApBARAnIQAMAgtBIhAYQQBBACgCoApBAmo2AqAKQQEQJyEADAELIAAQKiEACwJAIABBOkYNAEEAIAE2AqAKDwtBAEEAKAKgCkECajYCoAoCQEEBECciAEEiRg0AIABBJ0YNAEEAIAE2AqAKDwsgABAYQQBBACgCoApBAmo2AqAKAkACQEEBECciAEEsRg0AIABB/QBGDQFBACABNgKgCg8LQQBBACgCoApBAmo2AqAKQQEQJ0H9AEYNAEEAKAKgCiEADAELC0EAKALkCSIBIAI2AhAgAUEAKAKgCkECajYCDAttAQJ/AkACQANAAkAgAEH//wNxIgFBd2oiAkEXSw0AQQEgAnRBn4CABHENAgsgAUGgAUYNASAAIQIgARAmDQJBACECQQBBACgCoAoiAEECajYCoAogAC8BAiIADQAMAgsLIAAhAgsgAkH//wNxC6sBAQR/AkACQEEAKAKgCiICLwEAIgNB4QBGDQAgASEEIAAhBQwBC0EAIAJBBGo2AqAKQQEQJyECQQAoAqAKIQUCQAJAIAJBIkYNACACQSdGDQAgAhAqGkEAKAKgCiEEDAELIAIQGEEAQQAoAqAKQQJqIgQ2AqAKC0EBECchA0EAKAKgCiECCwJAIAIgBUYNACAFIARBACAAIAAgAUYiAhtBACABIAIbEAILIAMLcgEEf0EAKAKgCiEAQQAoAqQKIQECQAJAA0AgAEECaiECIAAgAU8NAQJAAkAgAi8BACIDQaR/ag4CAQQACyACIQAgA0F2ag4EAgEBAgELIABBBGohAAwACwtBACACNgKgChAiQQAPC0EAIAI2AqAKQd0AC0kBA39BACEDAkAgAkUNAAJAA0AgAC0AACIEIAEtAAAiBUcNASABQQFqIQEgAEEBaiEAIAJBf2oiAg0ADAILCyAEIAVrIQMLIAMLC+IBAgBBgAgLxAEAAHgAcABvAHIAdABtAHAAbwByAHQAZQB0AGEAcgBvAG0AdQBuAGMAdABpAG8AbgBzAHMAZQByAHQAdgBvAHkAaQBlAGQAZQBsAGUAYwBvAG4AdABpAG4AaQBuAHMAdABhAG4AdAB5AGIAcgBlAGEAcgBlAHQAdQByAGQAZQBiAHUAZwBnAGUAYQB3AGEAaQB0AGgAcgB3AGgAaQBsAGUAZgBvAHIAaQBmAGMAYQB0AGMAZgBpAG4AYQBsAGwAZQBsAHMAAEHECQsQAQAAAAIAAAAABAAAMDkAAA==", "undefined" != typeof Buffer ? Buffer.from(E2, "base64") : Uint8Array.from(atob(E2), (A3) => A3.charCodeAt(0)))).then(WebAssembly.instantiate).then(({ exports: A3 }) => {
      C3 = A3;
    });
    isDebug$6 = !!process.env.DEBUG;
    debug$e = createDebugger("vite:sourcemap", {
      onlyWhenFocused: true
    });
    astralIdentifierCodes2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    astralIdentifierStartCodes2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
    nonASCIIidentifierChars2 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    nonASCIIidentifierStartChars2 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    reservedWords2 = {
      3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
      5: "class enum extends super const export import",
      6: "enum",
      strict: "implements interface let package private protected public static yield",
      strictBind: "eval arguments"
    };
    ecma5AndLessKeywords2 = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    keywords$12 = {
      5: ecma5AndLessKeywords2,
      "5module": ecma5AndLessKeywords2 + " export import",
      6: ecma5AndLessKeywords2 + " const class extends export import super"
    };
    keywordRelationalOperator2 = /^in(stanceof)?$/;
    nonASCIIidentifierStart2 = new RegExp("[" + nonASCIIidentifierStartChars2 + "]");
    nonASCIIidentifier2 = new RegExp("[" + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + "]");
    TokenType3 = function TokenType4(label, conf) {
      if (conf === void 0)
        conf = {};
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    };
    beforeExpr2 = { beforeExpr: true };
    startsExpr2 = { startsExpr: true };
    keywords$2 = {};
    types$12 = {
      num: new TokenType3("num", startsExpr2),
      regexp: new TokenType3("regexp", startsExpr2),
      string: new TokenType3("string", startsExpr2),
      name: new TokenType3("name", startsExpr2),
      privateId: new TokenType3("privateId", startsExpr2),
      eof: new TokenType3("eof"),
      // Punctuation token types.
      bracketL: new TokenType3("[", { beforeExpr: true, startsExpr: true }),
      bracketR: new TokenType3("]"),
      braceL: new TokenType3("{", { beforeExpr: true, startsExpr: true }),
      braceR: new TokenType3("}"),
      parenL: new TokenType3("(", { beforeExpr: true, startsExpr: true }),
      parenR: new TokenType3(")"),
      comma: new TokenType3(",", beforeExpr2),
      semi: new TokenType3(";", beforeExpr2),
      colon: new TokenType3(":", beforeExpr2),
      dot: new TokenType3("."),
      question: new TokenType3("?", beforeExpr2),
      questionDot: new TokenType3("?."),
      arrow: new TokenType3("=>", beforeExpr2),
      template: new TokenType3("template"),
      invalidTemplate: new TokenType3("invalidTemplate"),
      ellipsis: new TokenType3("...", beforeExpr2),
      backQuote: new TokenType3("`", startsExpr2),
      dollarBraceL: new TokenType3("${", { beforeExpr: true, startsExpr: true }),
      // Operators. These carry several kinds of properties to help the
      // parser use them properly (the presence of these properties is
      // what categorizes them as operators).
      //
      // `binop`, when present, specifies that this operator is a binary
      // operator, and will refer to its precedence.
      //
      // `prefix` and `postfix` mark the operator as a prefix or postfix
      // unary operator.
      //
      // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
      // binary operators with a very low precedence, that should result
      // in AssignmentExpression nodes.
      eq: new TokenType3("=", { beforeExpr: true, isAssign: true }),
      assign: new TokenType3("_=", { beforeExpr: true, isAssign: true }),
      incDec: new TokenType3("++/--", { prefix: true, postfix: true, startsExpr: true }),
      prefix: new TokenType3("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
      logicalOR: binop2("||", 1),
      logicalAND: binop2("&&", 2),
      bitwiseOR: binop2("|", 3),
      bitwiseXOR: binop2("^", 4),
      bitwiseAND: binop2("&", 5),
      equality: binop2("==/!=/===/!==", 6),
      relational: binop2("</>/<=/>=", 7),
      bitShift: binop2("<</>>/>>>", 8),
      plusMin: new TokenType3("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
      modulo: binop2("%", 10),
      star: binop2("*", 10),
      slash: binop2("/", 10),
      starstar: new TokenType3("**", { beforeExpr: true }),
      coalesce: binop2("??", 1),
      // Keyword token types.
      _break: kw2("break"),
      _case: kw2("case", beforeExpr2),
      _catch: kw2("catch"),
      _continue: kw2("continue"),
      _debugger: kw2("debugger"),
      _default: kw2("default", beforeExpr2),
      _do: kw2("do", { isLoop: true, beforeExpr: true }),
      _else: kw2("else", beforeExpr2),
      _finally: kw2("finally"),
      _for: kw2("for", { isLoop: true }),
      _function: kw2("function", startsExpr2),
      _if: kw2("if"),
      _return: kw2("return", beforeExpr2),
      _switch: kw2("switch"),
      _throw: kw2("throw", beforeExpr2),
      _try: kw2("try"),
      _var: kw2("var"),
      _const: kw2("const"),
      _while: kw2("while", { isLoop: true }),
      _with: kw2("with"),
      _new: kw2("new", { beforeExpr: true, startsExpr: true }),
      _this: kw2("this", startsExpr2),
      _super: kw2("super", startsExpr2),
      _class: kw2("class", startsExpr2),
      _extends: kw2("extends", beforeExpr2),
      _export: kw2("export"),
      _import: kw2("import", startsExpr2),
      _null: kw2("null", startsExpr2),
      _true: kw2("true", startsExpr2),
      _false: kw2("false", startsExpr2),
      _in: kw2("in", { beforeExpr: true, binop: 7 }),
      _instanceof: kw2("instanceof", { beforeExpr: true, binop: 7 }),
      _typeof: kw2("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
      _void: kw2("void", { beforeExpr: true, prefix: true, startsExpr: true }),
      _delete: kw2("delete", { beforeExpr: true, prefix: true, startsExpr: true })
    };
    lineBreak2 = /\r\n?|\n|\u2028|\u2029/;
    lineBreakG2 = new RegExp(lineBreak2.source, "g");
    nonASCIIwhitespace2 = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    ref2 = Object.prototype;
    hasOwnProperty$1 = ref2.hasOwnProperty;
    toString$1 = ref2.toString;
    hasOwn2 = Object.hasOwn || function(obj, propName) {
      return hasOwnProperty$1.call(obj, propName);
    };
    isArray2 = Array.isArray || function(obj) {
      return toString$1.call(obj) === "[object Array]";
    };
    loneSurrogate2 = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
    Position3 = function Position4(line, col) {
      this.line = line;
      this.column = col;
    };
    Position3.prototype.offset = function offset2(n2) {
      return new Position3(this.line, this.column + n2);
    };
    SourceLocation3 = function SourceLocation4(p, start, end) {
      this.start = start;
      this.end = end;
      if (p.sourceFile !== null) {
        this.source = p.sourceFile;
      }
    };
    defaultOptions2 = {
      // `ecmaVersion` indicates the ECMAScript version to parse. Must be
      // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
      // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
      // (the latest version the library supports). This influences
      // support for strict mode, the set of reserved words, and support
      // for new syntax features.
      ecmaVersion: null,
      // `sourceType` indicates the mode the code should be parsed in.
      // Can be either `"script"` or `"module"`. This influences global
      // strict mode and parsing of `import` and `export` declarations.
      sourceType: "script",
      // `onInsertedSemicolon` can be a callback that will be called
      // when a semicolon is automatically inserted. It will be passed
      // the position of the comma as an offset, and if `locations` is
      // enabled, it is given the location as a `{line, column}` object
      // as second argument.
      onInsertedSemicolon: null,
      // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
      // trailing commas.
      onTrailingComma: null,
      // By default, reserved words are only enforced if ecmaVersion >= 5.
      // Set `allowReserved` to a boolean value to explicitly turn this on
      // an off. When this option has the value "never", reserved words
      // and keywords can also not be used as property names.
      allowReserved: null,
      // When enabled, a return at the top level is not considered an
      // error.
      allowReturnOutsideFunction: false,
      // When enabled, import/export statements are not constrained to
      // appearing at the top of the program, and an import.meta expression
      // in a script isn't considered an error.
      allowImportExportEverywhere: false,
      // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
      // When enabled, await identifiers are allowed to appear at the top-level scope,
      // but they are still not allowed in non-async functions.
      allowAwaitOutsideFunction: null,
      // When enabled, super identifiers are not constrained to
      // appearing in methods and do not raise an error when they appear elsewhere.
      allowSuperOutsideMethod: null,
      // When enabled, hashbang directive in the beginning of file is
      // allowed and treated as a line comment. Enabled by default when
      // `ecmaVersion` >= 2023.
      allowHashBang: false,
      // When `locations` is on, `loc` properties holding objects with
      // `start` and `end` properties in `{line, column}` form (with
      // line being 1-based and column 0-based) will be attached to the
      // nodes.
      locations: false,
      // A function can be passed as `onToken` option, which will
      // cause Acorn to call that function with object in the same
      // format as tokens returned from `tokenizer().getToken()`. Note
      // that you are not allowed to call the parser from the
      // callbackthat will corrupt its internal state.
      onToken: null,
      // A function can be passed as `onComment` option, which will
      // cause Acorn to call that function with `(block, text, start,
      // end)` parameters whenever a comment is skipped. `block` is a
      // boolean indicating whether this is a block (`/* */`) comment,
      // `text` is the content of the comment, and `start` and `end` are
      // character offsets that denote the start and end of the comment.
      // When the `locations` option is on, two more parameters are
      // passed, the full `{line, column}` locations of the start and
      // end of the comments. Note that you are not allowed to call the
      // parser from the callbackthat will corrupt its internal state.
      onComment: null,
      // Nodes have their start and end characters offsets recorded in
      // `start` and `end` properties (directly on the node, rather than
      // the `loc` object, which holds line/column data. To also add a
      // [semi-standardized][range] `range` property holding a `[start,
      // end]` array with the same numbers, set the `ranges` option to
      // `true`.
      //
      // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
      ranges: false,
      // It is possible to parse multiple files into a single AST by
      // passing the tree produced by parsing the first file as
      // `program` option in subsequent parses. This will add the
      // toplevel forms of the parsed file to the `Program` (top) node
      // of an existing parse tree.
      program: null,
      // When `locations` is on, you can pass this to record the source
      // file in every node's `loc` object.
      sourceFile: null,
      // This value, if given, is stored in every node, whether
      // `locations` is on or off.
      directSourceFile: null,
      // When enabled, parenthesized expressions are represented by
      // (non-standard) ParenthesizedExpression nodes
      preserveParens: false
    };
    warnedAboutEcmaVersion2 = false;
    SCOPE_TOP2 = 1;
    SCOPE_FUNCTION2 = 2;
    SCOPE_ASYNC2 = 4;
    SCOPE_GENERATOR2 = 8;
    SCOPE_ARROW2 = 16;
    SCOPE_SIMPLE_CATCH2 = 32;
    SCOPE_SUPER2 = 64;
    SCOPE_DIRECT_SUPER2 = 128;
    SCOPE_CLASS_STATIC_BLOCK2 = 256;
    SCOPE_VAR2 = SCOPE_TOP2 | SCOPE_FUNCTION2 | SCOPE_CLASS_STATIC_BLOCK2;
    BIND_NONE2 = 0;
    BIND_VAR2 = 1;
    BIND_LEXICAL2 = 2;
    BIND_FUNCTION2 = 3;
    BIND_SIMPLE_CATCH2 = 4;
    BIND_OUTSIDE2 = 5;
    Parser$1 = function Parser3(options2, input, startPos) {
      this.options = options2 = getOptions2(options2);
      this.sourceFile = options2.sourceFile;
      this.keywords = wordsRegexp2(keywords$12[options2.ecmaVersion >= 6 ? 6 : options2.sourceType === "module" ? "5module" : 5]);
      var reserved = "";
      if (options2.allowReserved !== true) {
        reserved = reservedWords2[options2.ecmaVersion >= 6 ? 6 : options2.ecmaVersion === 5 ? 5 : 3];
        if (options2.sourceType === "module") {
          reserved += " await";
        }
      }
      this.reservedWords = wordsRegexp2(reserved);
      var reservedStrict = (reserved ? reserved + " " : "") + reservedWords2.strict;
      this.reservedWordsStrict = wordsRegexp2(reservedStrict);
      this.reservedWordsStrictBind = wordsRegexp2(reservedStrict + " " + reservedWords2.strictBind);
      this.input = String(input);
      this.containsEsc = false;
      if (startPos) {
        this.pos = startPos;
        this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak2).length;
      } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
      }
      this.type = types$12.eof;
      this.value = null;
      this.start = this.end = this.pos;
      this.startLoc = this.endLoc = this.curPosition();
      this.lastTokEndLoc = this.lastTokStartLoc = null;
      this.lastTokStart = this.lastTokEnd = this.pos;
      this.context = this.initialContext();
      this.exprAllowed = true;
      this.inModule = options2.sourceType === "module";
      this.strict = this.inModule || this.strictDirective(this.pos);
      this.potentialArrowAt = -1;
      this.potentialArrowInForAwait = false;
      this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
      this.labels = [];
      this.undefinedExports = /* @__PURE__ */ Object.create(null);
      if (this.pos === 0 && options2.allowHashBang && this.input.slice(0, 2) === "#!") {
        this.skipLineComment(2);
      }
      this.scopeStack = [];
      this.enterScope(SCOPE_TOP2);
      this.regexpState = null;
      this.privateNameStack = [];
    };
    prototypeAccessors2 = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
    Parser$1.prototype.parse = function parse4() {
      var node2 = this.options.program || this.startNode();
      this.nextToken();
      return this.parseTopLevel(node2);
    };
    prototypeAccessors2.inFunction.get = function() {
      return (this.currentVarScope().flags & SCOPE_FUNCTION2) > 0;
    };
    prototypeAccessors2.inGenerator.get = function() {
      return (this.currentVarScope().flags & SCOPE_GENERATOR2) > 0 && !this.currentVarScope().inClassFieldInit;
    };
    prototypeAccessors2.inAsync.get = function() {
      return (this.currentVarScope().flags & SCOPE_ASYNC2) > 0 && !this.currentVarScope().inClassFieldInit;
    };
    prototypeAccessors2.canAwait.get = function() {
      for (var i = this.scopeStack.length - 1; i >= 0; i--) {
        var scope = this.scopeStack[i];
        if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK2) {
          return false;
        }
        if (scope.flags & SCOPE_FUNCTION2) {
          return (scope.flags & SCOPE_ASYNC2) > 0;
        }
      }
      return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
    };
    prototypeAccessors2.allowSuper.get = function() {
      var ref3 = this.currentThisScope();
      var flags = ref3.flags;
      var inClassFieldInit = ref3.inClassFieldInit;
      return (flags & SCOPE_SUPER2) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
    };
    prototypeAccessors2.allowDirectSuper.get = function() {
      return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER2) > 0;
    };
    prototypeAccessors2.treatFunctionsAsVar.get = function() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    };
    prototypeAccessors2.allowNewDotTarget.get = function() {
      var ref3 = this.currentThisScope();
      var flags = ref3.flags;
      var inClassFieldInit = ref3.inClassFieldInit;
      return (flags & (SCOPE_FUNCTION2 | SCOPE_CLASS_STATIC_BLOCK2)) > 0 || inClassFieldInit;
    };
    prototypeAccessors2.inClassStaticBlock.get = function() {
      return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK2) > 0;
    };
    Parser$1.extend = function extend2() {
      var plugins2 = [], len = arguments.length;
      while (len--)
        plugins2[len] = arguments[len];
      var cls = this;
      for (var i = 0; i < plugins2.length; i++) {
        cls = plugins2[i](cls);
      }
      return cls;
    };
    Parser$1.parse = function parse5(input, options2) {
      return new this(options2, input).parse();
    };
    Parser$1.parseExpressionAt = function parseExpressionAt2(input, pos, options2) {
      var parser = new this(options2, input, pos);
      parser.nextToken();
      return parser.parseExpression();
    };
    Parser$1.tokenizer = function tokenizer2(input, options2) {
      return new this(options2, input);
    };
    Object.defineProperties(Parser$1.prototype, prototypeAccessors2);
    pp$92 = Parser$1.prototype;
    literal2 = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
    pp$92.strictDirective = function(start) {
      if (this.options.ecmaVersion < 5) {
        return false;
      }
      for (; ; ) {
        skipWhiteSpace2.lastIndex = start;
        start += skipWhiteSpace2.exec(this.input)[0].length;
        var match = literal2.exec(this.input.slice(start));
        if (!match) {
          return false;
        }
        if ((match[1] || match[2]) === "use strict") {
          skipWhiteSpace2.lastIndex = start + match[0].length;
          var spaceAfter = skipWhiteSpace2.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
          var next = this.input.charAt(end);
          return next === ";" || next === "}" || lineBreak2.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
        }
        start += match[0].length;
        skipWhiteSpace2.lastIndex = start;
        start += skipWhiteSpace2.exec(this.input)[0].length;
        if (this.input[start] === ";") {
          start++;
        }
      }
    };
    pp$92.eat = function(type) {
      if (this.type === type) {
        this.next();
        return true;
      } else {
        return false;
      }
    };
    pp$92.isContextual = function(name2) {
      return this.type === types$12.name && this.value === name2 && !this.containsEsc;
    };
    pp$92.eatContextual = function(name2) {
      if (!this.isContextual(name2)) {
        return false;
      }
      this.next();
      return true;
    };
    pp$92.expectContextual = function(name2) {
      if (!this.eatContextual(name2)) {
        this.unexpected();
      }
    };
    pp$92.canInsertSemicolon = function() {
      return this.type === types$12.eof || this.type === types$12.braceR || lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$92.insertSemicolon = function() {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon) {
          this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
        }
        return true;
      }
    };
    pp$92.semicolon = function() {
      if (!this.eat(types$12.semi) && !this.insertSemicolon()) {
        this.unexpected();
      }
    };
    pp$92.afterTrailingComma = function(tokType, notNext) {
      if (this.type === tokType) {
        if (this.options.onTrailingComma) {
          this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
        }
        if (!notNext) {
          this.next();
        }
        return true;
      }
    };
    pp$92.expect = function(type) {
      this.eat(type) || this.unexpected();
    };
    pp$92.unexpected = function(pos) {
      this.raise(pos != null ? pos : this.start, "Unexpected token");
    };
    DestructuringErrors3 = function DestructuringErrors4() {
      this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
    };
    pp$92.checkPatternErrors = function(refDestructuringErrors, isAssign) {
      if (!refDestructuringErrors) {
        return;
      }
      if (refDestructuringErrors.trailingComma > -1) {
        this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
      }
      var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
      if (parens > -1) {
        this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
      }
    };
    pp$92.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
      if (!refDestructuringErrors) {
        return false;
      }
      var shorthandAssign = refDestructuringErrors.shorthandAssign;
      var doubleProto = refDestructuringErrors.doubleProto;
      if (!andThrow) {
        return shorthandAssign >= 0 || doubleProto >= 0;
      }
      if (shorthandAssign >= 0) {
        this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
      }
      if (doubleProto >= 0) {
        this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
      }
    };
    pp$92.checkYieldAwaitInDefaultParams = function() {
      if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
        this.raise(this.yieldPos, "Yield expression cannot be a default value");
      }
      if (this.awaitPos) {
        this.raise(this.awaitPos, "Await expression cannot be a default value");
      }
    };
    pp$92.isSimpleAssignTarget = function(expr) {
      if (expr.type === "ParenthesizedExpression") {
        return this.isSimpleAssignTarget(expr.expression);
      }
      return expr.type === "Identifier" || expr.type === "MemberExpression";
    };
    pp$82 = Parser$1.prototype;
    pp$82.parseTopLevel = function(node2) {
      var exports2 = /* @__PURE__ */ Object.create(null);
      if (!node2.body) {
        node2.body = [];
      }
      while (this.type !== types$12.eof) {
        var stmt = this.parseStatement(null, true, exports2);
        node2.body.push(stmt);
      }
      if (this.inModule) {
        for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
          var name2 = list[i];
          this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
        }
      }
      this.adaptDirectivePrologue(node2.body);
      this.next();
      node2.sourceType = this.options.sourceType;
      return this.finishNode(node2, "Program");
    };
    loopLabel2 = { kind: "loop" };
    switchLabel2 = { kind: "switch" };
    pp$82.isLet = function(context) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
        return false;
      }
      skipWhiteSpace2.lastIndex = this.pos;
      var skip = skipWhiteSpace2.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 91 || nextCh === 92) {
        return true;
      }
      if (context) {
        return false;
      }
      if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
        return true;
      }
      if (isIdentifierStart2(nextCh, true)) {
        var pos = next + 1;
        while (isIdentifierChar2(nextCh = this.input.charCodeAt(pos), true)) {
          ++pos;
        }
        if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator2.test(ident)) {
          return true;
        }
      }
      return false;
    };
    pp$82.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
        return false;
      }
      skipWhiteSpace2.lastIndex = this.pos;
      var skip = skipWhiteSpace2.exec(this.input);
      var next = this.pos + skip[0].length, after;
      return !lineBreak2.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar2(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
    };
    pp$82.parseStatement = function(context, topLevel, exports2) {
      var starttype = this.type, node2 = this.startNode(), kind;
      if (this.isLet(context)) {
        starttype = types$12._var;
        kind = "let";
      }
      switch (starttype) {
        case types$12._break:
        case types$12._continue:
          return this.parseBreakContinueStatement(node2, starttype.keyword);
        case types$12._debugger:
          return this.parseDebuggerStatement(node2);
        case types$12._do:
          return this.parseDoStatement(node2);
        case types$12._for:
          return this.parseForStatement(node2);
        case types$12._function:
          if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
            this.unexpected();
          }
          return this.parseFunctionStatement(node2, false, !context);
        case types$12._class:
          if (context) {
            this.unexpected();
          }
          return this.parseClass(node2, true);
        case types$12._if:
          return this.parseIfStatement(node2);
        case types$12._return:
          return this.parseReturnStatement(node2);
        case types$12._switch:
          return this.parseSwitchStatement(node2);
        case types$12._throw:
          return this.parseThrowStatement(node2);
        case types$12._try:
          return this.parseTryStatement(node2);
        case types$12._const:
        case types$12._var:
          kind = kind || this.value;
          if (context && kind !== "var") {
            this.unexpected();
          }
          return this.parseVarStatement(node2, kind);
        case types$12._while:
          return this.parseWhileStatement(node2);
        case types$12._with:
          return this.parseWithStatement(node2);
        case types$12.braceL:
          return this.parseBlock(true, node2);
        case types$12.semi:
          return this.parseEmptyStatement(node2);
        case types$12._export:
        case types$12._import:
          if (this.options.ecmaVersion > 10 && starttype === types$12._import) {
            skipWhiteSpace2.lastIndex = this.pos;
            var skip = skipWhiteSpace2.exec(this.input);
            var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
            if (nextCh === 40 || nextCh === 46) {
              return this.parseExpressionStatement(node2, this.parseExpression());
            }
          }
          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel) {
              this.raise(this.start, "'import' and 'export' may only appear at the top level");
            }
            if (!this.inModule) {
              this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
          }
          return starttype === types$12._import ? this.parseImport(node2) : this.parseExport(node2, exports2);
        default:
          if (this.isAsyncFunction()) {
            if (context) {
              this.unexpected();
            }
            this.next();
            return this.parseFunctionStatement(node2, true, !context);
          }
          var maybeName = this.value, expr = this.parseExpression();
          if (starttype === types$12.name && expr.type === "Identifier" && this.eat(types$12.colon)) {
            return this.parseLabeledStatement(node2, maybeName, expr, context);
          } else {
            return this.parseExpressionStatement(node2, expr);
          }
      }
    };
    pp$82.parseBreakContinueStatement = function(node2, keyword) {
      var isBreak = keyword === "break";
      this.next();
      if (this.eat(types$12.semi) || this.insertSemicolon()) {
        node2.label = null;
      } else if (this.type !== types$12.name) {
        this.unexpected();
      } else {
        node2.label = this.parseIdent();
        this.semicolon();
      }
      var i = 0;
      for (; i < this.labels.length; ++i) {
        var lab = this.labels[i];
        if (node2.label == null || lab.name === node2.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) {
            break;
          }
          if (node2.label && isBreak) {
            break;
          }
        }
      }
      if (i === this.labels.length) {
        this.raise(node2.start, "Unsyntactic " + keyword);
      }
      return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
    };
    pp$82.parseDebuggerStatement = function(node2) {
      this.next();
      this.semicolon();
      return this.finishNode(node2, "DebuggerStatement");
    };
    pp$82.parseDoStatement = function(node2) {
      this.next();
      this.labels.push(loopLabel2);
      node2.body = this.parseStatement("do");
      this.labels.pop();
      this.expect(types$12._while);
      node2.test = this.parseParenExpression();
      if (this.options.ecmaVersion >= 6) {
        this.eat(types$12.semi);
      } else {
        this.semicolon();
      }
      return this.finishNode(node2, "DoWhileStatement");
    };
    pp$82.parseForStatement = function(node2) {
      this.next();
      var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
      this.labels.push(loopLabel2);
      this.enterScope(0);
      this.expect(types$12.parenL);
      if (this.type === types$12.semi) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, null);
      }
      var isLet = this.isLet();
      if (this.type === types$12._var || this.type === types$12._const || isLet) {
        var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
        this.next();
        this.parseVar(init$1, true, kind);
        this.finishNode(init$1, "VariableDeclaration");
        if ((this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$12._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node2.await = awaitAt > -1;
            }
          }
          return this.parseForIn(node2, init$1);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, init$1);
      }
      var startsWithLet = this.isContextual("let"), isForOf = false;
      var refDestructuringErrors = new DestructuringErrors3();
      var init4 = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
      if (this.type === types$12._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types$12._in) {
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
          } else {
            node2.await = awaitAt > -1;
          }
        }
        if (startsWithLet && isForOf) {
          this.raise(init4.start, "The left-hand side of a for-of loop may not start with 'let'.");
        }
        this.toAssignable(init4, false, refDestructuringErrors);
        this.checkLValPattern(init4);
        return this.parseForIn(node2, init4);
      } else {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node2, init4);
    };
    pp$82.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT2), false, isAsync);
    };
    pp$82.parseIfStatement = function(node2) {
      this.next();
      node2.test = this.parseParenExpression();
      node2.consequent = this.parseStatement("if");
      node2.alternate = this.eat(types$12._else) ? this.parseStatement("if") : null;
      return this.finishNode(node2, "IfStatement");
    };
    pp$82.parseReturnStatement = function(node2) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
        this.raise(this.start, "'return' outside of function");
      }
      this.next();
      if (this.eat(types$12.semi) || this.insertSemicolon()) {
        node2.argument = null;
      } else {
        node2.argument = this.parseExpression();
        this.semicolon();
      }
      return this.finishNode(node2, "ReturnStatement");
    };
    pp$82.parseSwitchStatement = function(node2) {
      this.next();
      node2.discriminant = this.parseParenExpression();
      node2.cases = [];
      this.expect(types$12.braceL);
      this.labels.push(switchLabel2);
      this.enterScope(0);
      var cur;
      for (var sawDefault = false; this.type !== types$12.braceR; ) {
        if (this.type === types$12._case || this.type === types$12._default) {
          var isCase = this.type === types$12._case;
          if (cur) {
            this.finishNode(cur, "SwitchCase");
          }
          node2.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
            }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(types$12.colon);
        } else {
          if (!cur) {
            this.unexpected();
          }
          cur.consequent.push(this.parseStatement(null));
        }
      }
      this.exitScope();
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      this.next();
      this.labels.pop();
      return this.finishNode(node2, "SwitchStatement");
    };
    pp$82.parseThrowStatement = function(node2) {
      this.next();
      if (lineBreak2.test(this.input.slice(this.lastTokEnd, this.start))) {
        this.raise(this.lastTokEnd, "Illegal newline after throw");
      }
      node2.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node2, "ThrowStatement");
    };
    empty$12 = [];
    pp$82.parseTryStatement = function(node2) {
      this.next();
      node2.block = this.parseBlock();
      node2.handler = null;
      if (this.type === types$12._catch) {
        var clause = this.startNode();
        this.next();
        if (this.eat(types$12.parenL)) {
          clause.param = this.parseBindingAtom();
          var simple = clause.param.type === "Identifier";
          this.enterScope(simple ? SCOPE_SIMPLE_CATCH2 : 0);
          this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH2 : BIND_LEXICAL2);
          this.expect(types$12.parenR);
        } else {
          if (this.options.ecmaVersion < 10) {
            this.unexpected();
          }
          clause.param = null;
          this.enterScope(0);
        }
        clause.body = this.parseBlock(false);
        this.exitScope();
        node2.handler = this.finishNode(clause, "CatchClause");
      }
      node2.finalizer = this.eat(types$12._finally) ? this.parseBlock() : null;
      if (!node2.handler && !node2.finalizer) {
        this.raise(node2.start, "Missing catch or finally clause");
      }
      return this.finishNode(node2, "TryStatement");
    };
    pp$82.parseVarStatement = function(node2, kind) {
      this.next();
      this.parseVar(node2, false, kind);
      this.semicolon();
      return this.finishNode(node2, "VariableDeclaration");
    };
    pp$82.parseWhileStatement = function(node2) {
      this.next();
      node2.test = this.parseParenExpression();
      this.labels.push(loopLabel2);
      node2.body = this.parseStatement("while");
      this.labels.pop();
      return this.finishNode(node2, "WhileStatement");
    };
    pp$82.parseWithStatement = function(node2) {
      if (this.strict) {
        this.raise(this.start, "'with' in strict mode");
      }
      this.next();
      node2.object = this.parseParenExpression();
      node2.body = this.parseStatement("with");
      return this.finishNode(node2, "WithStatement");
    };
    pp$82.parseEmptyStatement = function(node2) {
      this.next();
      return this.finishNode(node2, "EmptyStatement");
    };
    pp$82.parseLabeledStatement = function(node2, maybeName, expr, context) {
      for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
        var label = list[i$1];
        if (label.name === maybeName) {
          this.raise(expr.start, "Label '" + maybeName + "' is already declared");
        }
      }
      var kind = this.type.isLoop ? "loop" : this.type === types$12._switch ? "switch" : null;
      for (var i = this.labels.length - 1; i >= 0; i--) {
        var label$1 = this.labels[i];
        if (label$1.statementStart === node2.start) {
          label$1.statementStart = this.start;
          label$1.kind = kind;
        } else {
          break;
        }
      }
      this.labels.push({ name: maybeName, kind, statementStart: this.start });
      node2.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.labels.pop();
      node2.label = expr;
      return this.finishNode(node2, "LabeledStatement");
    };
    pp$82.parseExpressionStatement = function(node2, expr) {
      node2.expression = expr;
      this.semicolon();
      return this.finishNode(node2, "ExpressionStatement");
    };
    pp$82.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
      if (createNewLexicalScope === void 0)
        createNewLexicalScope = true;
      if (node2 === void 0)
        node2 = this.startNode();
      node2.body = [];
      this.expect(types$12.braceL);
      if (createNewLexicalScope) {
        this.enterScope(0);
      }
      while (this.type !== types$12.braceR) {
        var stmt = this.parseStatement(null);
        node2.body.push(stmt);
      }
      if (exitStrict) {
        this.strict = false;
      }
      this.next();
      if (createNewLexicalScope) {
        this.exitScope();
      }
      return this.finishNode(node2, "BlockStatement");
    };
    pp$82.parseFor = function(node2, init4) {
      node2.init = init4;
      this.expect(types$12.semi);
      node2.test = this.type === types$12.semi ? null : this.parseExpression();
      this.expect(types$12.semi);
      node2.update = this.type === types$12.parenR ? null : this.parseExpression();
      this.expect(types$12.parenR);
      node2.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node2, "ForStatement");
    };
    pp$82.parseForIn = function(node2, init4) {
      var isForIn = this.type === types$12._in;
      this.next();
      if (init4.type === "VariableDeclaration" && init4.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init4.kind !== "var" || init4.declarations[0].id.type !== "Identifier")) {
        this.raise(
          init4.start,
          (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
        );
      }
      node2.left = init4;
      node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
      this.expect(types$12.parenR);
      node2.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
    };
    pp$82.parseVar = function(node2, isFor, kind) {
      node2.declarations = [];
      node2.kind = kind;
      for (; ; ) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        if (this.eat(types$12.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else if (kind === "const" && !(this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          this.unexpected();
        } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$12._in || this.isContextual("of")))) {
          this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types$12.comma)) {
          break;
        }
      }
      return node2;
    };
    pp$82.parseVarId = function(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR2 : BIND_LEXICAL2, false);
    };
    FUNC_STATEMENT = 1;
    FUNC_HANGING_STATEMENT2 = 2;
    FUNC_NULLABLE_ID = 4;
    pp$82.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
      this.initFunction(node2);
      if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
        if (this.type === types$12.star && statement & FUNC_HANGING_STATEMENT2) {
          this.unexpected();
        }
        node2.generator = this.eat(types$12.star);
      }
      if (this.options.ecmaVersion >= 8) {
        node2.async = !!isAsync;
      }
      if (statement & FUNC_STATEMENT) {
        node2.id = statement & FUNC_NULLABLE_ID && this.type !== types$12.name ? null : this.parseIdent();
        if (node2.id && !(statement & FUNC_HANGING_STATEMENT2)) {
          this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR2 : BIND_LEXICAL2 : BIND_FUNCTION2);
        }
      }
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags2(node2.async, node2.generator));
      if (!(statement & FUNC_STATEMENT)) {
        node2.id = this.type === types$12.name ? this.parseIdent() : null;
      }
      this.parseFunctionParams(node2);
      this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node2, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
    };
    pp$82.parseFunctionParams = function(node2) {
      this.expect(types$12.parenL);
      node2.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
    };
    pp$82.parseClass = function(node2, isStatement) {
      this.next();
      var oldStrict = this.strict;
      this.strict = true;
      this.parseClassId(node2, isStatement);
      this.parseClassSuper(node2);
      var privateNameMap = this.enterClassBody();
      var classBody = this.startNode();
      var hadConstructor = false;
      classBody.body = [];
      this.expect(types$12.braceL);
      while (this.type !== types$12.braceR) {
        var element = this.parseClassElement(node2.superClass !== null);
        if (element) {
          classBody.body.push(element);
          if (element.type === "MethodDefinition" && element.kind === "constructor") {
            if (hadConstructor) {
              this.raise(element.start, "Duplicate constructor in the same class");
            }
            hadConstructor = true;
          } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted2(privateNameMap, element)) {
            this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
          }
        }
      }
      this.strict = oldStrict;
      this.next();
      node2.body = this.finishNode(classBody, "ClassBody");
      this.exitClassBody();
      return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    pp$82.parseClassElement = function(constructorAllowsSuper) {
      if (this.eat(types$12.semi)) {
        return null;
      }
      var ecmaVersion = this.options.ecmaVersion;
      var node2 = this.startNode();
      var keyName = "";
      var isGenerator = false;
      var isAsync = false;
      var kind = "method";
      var isStatic = false;
      if (this.eatContextual("static")) {
        if (ecmaVersion >= 13 && this.eat(types$12.braceL)) {
          this.parseClassStaticBlock(node2);
          return node2;
        }
        if (this.isClassElementNameStart() || this.type === types$12.star) {
          isStatic = true;
        } else {
          keyName = "static";
        }
      }
      node2.static = isStatic;
      if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
        if ((this.isClassElementNameStart() || this.type === types$12.star) && !this.canInsertSemicolon()) {
          isAsync = true;
        } else {
          keyName = "async";
        }
      }
      if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$12.star)) {
        isGenerator = true;
      }
      if (!keyName && !isAsync && !isGenerator) {
        var lastValue = this.value;
        if (this.eatContextual("get") || this.eatContextual("set")) {
          if (this.isClassElementNameStart()) {
            kind = lastValue;
          } else {
            keyName = lastValue;
          }
        }
      }
      if (keyName) {
        node2.computed = false;
        node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
        node2.key.name = keyName;
        this.finishNode(node2.key, "Identifier");
      } else {
        this.parseClassElementName(node2);
      }
      if (ecmaVersion < 13 || this.type === types$12.parenL || kind !== "method" || isGenerator || isAsync) {
        var isConstructor = !node2.static && checkKeyName2(node2, "constructor");
        var allowsDirectSuper = isConstructor && constructorAllowsSuper;
        if (isConstructor && kind !== "method") {
          this.raise(node2.key.start, "Constructor can't have get/set modifier");
        }
        node2.kind = isConstructor ? "constructor" : kind;
        this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
      } else {
        this.parseClassField(node2);
      }
      return node2;
    };
    pp$82.isClassElementNameStart = function() {
      return this.type === types$12.name || this.type === types$12.privateId || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword;
    };
    pp$82.parseClassElementName = function(element) {
      if (this.type === types$12.privateId) {
        if (this.value === "constructor") {
          this.raise(this.start, "Classes can't have an element named '#constructor'");
        }
        element.computed = false;
        element.key = this.parsePrivateIdent();
      } else {
        this.parsePropertyName(element);
      }
    };
    pp$82.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
      var key = method.key;
      if (method.kind === "constructor") {
        if (isGenerator) {
          this.raise(key.start, "Constructor can't be a generator");
        }
        if (isAsync) {
          this.raise(key.start, "Constructor can't be an async method");
        }
      } else if (method.static && checkKeyName2(method, "prototype")) {
        this.raise(key.start, "Classes may not have a static property named prototype");
      }
      var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
      if (method.kind === "get" && value2.params.length !== 0) {
        this.raiseRecoverable(value2.start, "getter should have no params");
      }
      if (method.kind === "set" && value2.params.length !== 1) {
        this.raiseRecoverable(value2.start, "setter should have exactly one param");
      }
      if (method.kind === "set" && value2.params[0].type === "RestElement") {
        this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
      }
      return this.finishNode(method, "MethodDefinition");
    };
    pp$82.parseClassField = function(field) {
      if (checkKeyName2(field, "constructor")) {
        this.raise(field.key.start, "Classes can't have a field named 'constructor'");
      } else if (field.static && checkKeyName2(field, "prototype")) {
        this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
      }
      if (this.eat(types$12.eq)) {
        var scope = this.currentThisScope();
        var inClassFieldInit = scope.inClassFieldInit;
        scope.inClassFieldInit = true;
        field.value = this.parseMaybeAssign();
        scope.inClassFieldInit = inClassFieldInit;
      } else {
        field.value = null;
      }
      this.semicolon();
      return this.finishNode(field, "PropertyDefinition");
    };
    pp$82.parseClassStaticBlock = function(node2) {
      node2.body = [];
      var oldLabels = this.labels;
      this.labels = [];
      this.enterScope(SCOPE_CLASS_STATIC_BLOCK2 | SCOPE_SUPER2);
      while (this.type !== types$12.braceR) {
        var stmt = this.parseStatement(null);
        node2.body.push(stmt);
      }
      this.next();
      this.exitScope();
      this.labels = oldLabels;
      return this.finishNode(node2, "StaticBlock");
    };
    pp$82.parseClassId = function(node2, isStatement) {
      if (this.type === types$12.name) {
        node2.id = this.parseIdent();
        if (isStatement) {
          this.checkLValSimple(node2.id, BIND_LEXICAL2, false);
        }
      } else {
        if (isStatement === true) {
          this.unexpected();
        }
        node2.id = null;
      }
    };
    pp$82.parseClassSuper = function(node2) {
      node2.superClass = this.eat(types$12._extends) ? this.parseExprSubscripts(null, false) : null;
    };
    pp$82.enterClassBody = function() {
      var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
      this.privateNameStack.push(element);
      return element.declared;
    };
    pp$82.exitClassBody = function() {
      var ref3 = this.privateNameStack.pop();
      var declared = ref3.declared;
      var used = ref3.used;
      var len = this.privateNameStack.length;
      var parent = len === 0 ? null : this.privateNameStack[len - 1];
      for (var i = 0; i < used.length; ++i) {
        var id = used[i];
        if (!hasOwn2(declared, id.name)) {
          if (parent) {
            parent.used.push(id);
          } else {
            this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
          }
        }
      }
    };
    pp$82.parseExport = function(node2, exports2) {
      this.next();
      if (this.eat(types$12.star)) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node2.exported = this.parseModuleExportName();
            this.checkExport(exports2, node2.exported, this.lastTokStart);
          } else {
            node2.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$12.string) {
          this.unexpected();
        }
        node2.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node2, "ExportAllDeclaration");
      }
      if (this.eat(types$12._default)) {
        this.checkExport(exports2, "default", this.lastTokStart);
        var isAsync;
        if (this.type === types$12._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          node2.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types$12._class) {
          var cNode = this.startNode();
          node2.declaration = this.parseClass(cNode, "nullableID");
        } else {
          node2.declaration = this.parseMaybeAssign();
          this.semicolon();
        }
        return this.finishNode(node2, "ExportDefaultDeclaration");
      }
      if (this.shouldParseExportStatement()) {
        node2.declaration = this.parseStatement(null);
        if (node2.declaration.type === "VariableDeclaration") {
          this.checkVariableExport(exports2, node2.declaration.declarations);
        } else {
          this.checkExport(exports2, node2.declaration.id, node2.declaration.id.start);
        }
        node2.specifiers = [];
        node2.source = null;
      } else {
        node2.declaration = null;
        node2.specifiers = this.parseExportSpecifiers(exports2);
        if (this.eatContextual("from")) {
          if (this.type !== types$12.string) {
            this.unexpected();
          }
          node2.source = this.parseExprAtom();
        } else {
          for (var i = 0, list = node2.specifiers; i < list.length; i += 1) {
            var spec = list[i];
            this.checkUnreserved(spec.local);
            this.checkLocalExport(spec.local);
            if (spec.local.type === "Literal") {
              this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
            }
          }
          node2.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(node2, "ExportNamedDeclaration");
    };
    pp$82.checkExport = function(exports2, name2, pos) {
      if (!exports2) {
        return;
      }
      if (typeof name2 !== "string") {
        name2 = name2.type === "Identifier" ? name2.name : name2.value;
      }
      if (hasOwn2(exports2, name2)) {
        this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
      }
      exports2[name2] = true;
    };
    pp$82.checkPatternExport = function(exports2, pat) {
      var type = pat.type;
      if (type === "Identifier") {
        this.checkExport(exports2, pat, pat.start);
      } else if (type === "ObjectPattern") {
        for (var i = 0, list = pat.properties; i < list.length; i += 1) {
          var prop = list[i];
          this.checkPatternExport(exports2, prop);
        }
      } else if (type === "ArrayPattern") {
        for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
          var elt = list$1[i$1];
          if (elt) {
            this.checkPatternExport(exports2, elt);
          }
        }
      } else if (type === "Property") {
        this.checkPatternExport(exports2, pat.value);
      } else if (type === "AssignmentPattern") {
        this.checkPatternExport(exports2, pat.left);
      } else if (type === "RestElement") {
        this.checkPatternExport(exports2, pat.argument);
      } else if (type === "ParenthesizedExpression") {
        this.checkPatternExport(exports2, pat.expression);
      }
    };
    pp$82.checkVariableExport = function(exports2, decls) {
      if (!exports2) {
        return;
      }
      for (var i = 0, list = decls; i < list.length; i += 1) {
        var decl = list[i];
        this.checkPatternExport(exports2, decl.id);
      }
    };
    pp$82.shouldParseExportStatement = function() {
      return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
    };
    pp$82.parseExportSpecifiers = function(exports2) {
      var nodes = [], first2 = true;
      this.expect(types$12.braceL);
      while (!this.eat(types$12.braceR)) {
        if (!first2) {
          this.expect(types$12.comma);
          if (this.afterTrailingComma(types$12.braceR)) {
            break;
          }
        } else {
          first2 = false;
        }
        var node2 = this.startNode();
        node2.local = this.parseModuleExportName();
        node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
        this.checkExport(
          exports2,
          node2.exported,
          node2.exported.start
        );
        nodes.push(this.finishNode(node2, "ExportSpecifier"));
      }
      return nodes;
    };
    pp$82.parseImport = function(node2) {
      this.next();
      if (this.type === types$12.string) {
        node2.specifiers = empty$12;
        node2.source = this.parseExprAtom();
      } else {
        node2.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node2.source = this.type === types$12.string ? this.parseExprAtom() : this.unexpected();
      }
      this.semicolon();
      return this.finishNode(node2, "ImportDeclaration");
    };
    pp$82.parseImportSpecifiers = function() {
      var nodes = [], first2 = true;
      if (this.type === types$12.name) {
        var node2 = this.startNode();
        node2.local = this.parseIdent();
        this.checkLValSimple(node2.local, BIND_LEXICAL2);
        nodes.push(this.finishNode(node2, "ImportDefaultSpecifier"));
        if (!this.eat(types$12.comma)) {
          return nodes;
        }
      }
      if (this.type === types$12.star) {
        var node$12 = this.startNode();
        this.next();
        this.expectContextual("as");
        node$12.local = this.parseIdent();
        this.checkLValSimple(node$12.local, BIND_LEXICAL2);
        nodes.push(this.finishNode(node$12, "ImportNamespaceSpecifier"));
        return nodes;
      }
      this.expect(types$12.braceL);
      while (!this.eat(types$12.braceR)) {
        if (!first2) {
          this.expect(types$12.comma);
          if (this.afterTrailingComma(types$12.braceR)) {
            break;
          }
        } else {
          first2 = false;
        }
        var node$2 = this.startNode();
        node$2.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node$2.local = this.parseIdent();
        } else {
          this.checkUnreserved(node$2.imported);
          node$2.local = node$2.imported;
        }
        this.checkLValSimple(node$2.local, BIND_LEXICAL2);
        nodes.push(this.finishNode(node$2, "ImportSpecifier"));
      }
      return nodes;
    };
    pp$82.parseModuleExportName = function() {
      if (this.options.ecmaVersion >= 13 && this.type === types$12.string) {
        var stringLiteral = this.parseLiteral(this.value);
        if (loneSurrogate2.test(stringLiteral.value)) {
          this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
        }
        return stringLiteral;
      }
      return this.parseIdent(true);
    };
    pp$82.adaptDirectivePrologue = function(statements) {
      for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
        statements[i].directive = statements[i].expression.raw.slice(1, -1);
      }
    };
    pp$82.isDirectiveCandidate = function(statement) {
      return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
      (this.input[statement.start] === '"' || this.input[statement.start] === "'");
    };
    pp$72 = Parser$1.prototype;
    pp$72.toAssignable = function(node2, isBinding, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 6 && node2) {
        switch (node2.type) {
          case "Identifier":
            if (this.inAsync && node2.name === "await") {
              this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
            }
            break;
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node2.type = "ObjectPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            for (var i = 0, list = node2.properties; i < list.length; i += 1) {
              var prop = list[i];
              this.toAssignable(prop, isBinding);
              if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                this.raise(prop.argument.start, "Unexpected token");
              }
            }
            break;
          case "Property":
            if (node2.kind !== "init") {
              this.raise(node2.key.start, "Object pattern can't contain getter or setter");
            }
            this.toAssignable(node2.value, isBinding);
            break;
          case "ArrayExpression":
            node2.type = "ArrayPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            this.toAssignableList(node2.elements, isBinding);
            break;
          case "SpreadElement":
            node2.type = "RestElement";
            this.toAssignable(node2.argument, isBinding);
            if (node2.argument.type === "AssignmentPattern") {
              this.raise(node2.argument.start, "Rest elements cannot have a default value");
            }
            break;
          case "AssignmentExpression":
            if (node2.operator !== "=") {
              this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
            }
            node2.type = "AssignmentPattern";
            delete node2.operator;
            this.toAssignable(node2.left, isBinding);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
            break;
          case "ChainExpression":
            this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (!isBinding) {
              break;
            }
          default:
            this.raise(node2.start, "Assigning to rvalue");
        }
      } else if (refDestructuringErrors) {
        this.checkPatternErrors(refDestructuringErrors, true);
      }
      return node2;
    };
    pp$72.toAssignableList = function(exprList, isBinding) {
      var end = exprList.length;
      for (var i = 0; i < end; i++) {
        var elt = exprList[i];
        if (elt) {
          this.toAssignable(elt, isBinding);
        }
      }
      if (end) {
        var last = exprList[end - 1];
        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
          this.unexpected(last.argument.start);
        }
      }
      return exprList;
    };
    pp$72.parseSpread = function(refDestructuringErrors) {
      var node2 = this.startNode();
      this.next();
      node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      return this.finishNode(node2, "SpreadElement");
    };
    pp$72.parseRestBinding = function() {
      var node2 = this.startNode();
      this.next();
      if (this.options.ecmaVersion === 6 && this.type !== types$12.name) {
        this.unexpected();
      }
      node2.argument = this.parseBindingAtom();
      return this.finishNode(node2, "RestElement");
    };
    pp$72.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6) {
        switch (this.type) {
          case types$12.bracketL:
            var node2 = this.startNode();
            this.next();
            node2.elements = this.parseBindingList(types$12.bracketR, true, true);
            return this.finishNode(node2, "ArrayPattern");
          case types$12.braceL:
            return this.parseObj(true);
        }
      }
      return this.parseIdent();
    };
    pp$72.parseBindingList = function(close2, allowEmpty, allowTrailingComma) {
      var elts = [], first2 = true;
      while (!this.eat(close2)) {
        if (first2) {
          first2 = false;
        } else {
          this.expect(types$12.comma);
        }
        if (allowEmpty && this.type === types$12.comma) {
          elts.push(null);
        } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
          break;
        } else if (this.type === types$12.ellipsis) {
          var rest = this.parseRestBinding();
          this.parseBindingListItem(rest);
          elts.push(rest);
          if (this.type === types$12.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          this.expect(close2);
          break;
        } else {
          var elem = this.parseMaybeDefault(this.start, this.startLoc);
          this.parseBindingListItem(elem);
          elts.push(elem);
        }
      }
      return elts;
    };
    pp$72.parseBindingListItem = function(param) {
      return param;
    };
    pp$72.parseMaybeDefault = function(startPos, startLoc, left) {
      left = left || this.parseBindingAtom();
      if (this.options.ecmaVersion < 6 || !this.eat(types$12.eq)) {
        return left;
      }
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.left = left;
      node2.right = this.parseMaybeAssign();
      return this.finishNode(node2, "AssignmentPattern");
    };
    pp$72.checkLValSimple = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE2;
      var isBind = bindingType !== BIND_NONE2;
      switch (expr.type) {
        case "Identifier":
          if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
            this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
          }
          if (isBind) {
            if (bindingType === BIND_LEXICAL2 && expr.name === "let") {
              this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
            }
            if (checkClashes) {
              if (hasOwn2(checkClashes, expr.name)) {
                this.raiseRecoverable(expr.start, "Argument name clash");
              }
              checkClashes[expr.name] = true;
            }
            if (bindingType !== BIND_OUTSIDE2) {
              this.declareName(expr.name, bindingType, expr.start);
            }
          }
          break;
        case "ChainExpression":
          this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding member expression");
          }
          break;
        case "ParenthesizedExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding parenthesized expression");
          }
          return this.checkLValSimple(expr.expression, bindingType, checkClashes);
        default:
          this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
      }
    };
    pp$72.checkLValPattern = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE2;
      switch (expr.type) {
        case "ObjectPattern":
          for (var i = 0, list = expr.properties; i < list.length; i += 1) {
            var prop = list[i];
            this.checkLValInnerPattern(prop, bindingType, checkClashes);
          }
          break;
        case "ArrayPattern":
          for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
            var elem = list$1[i$1];
            if (elem) {
              this.checkLValInnerPattern(elem, bindingType, checkClashes);
            }
          }
          break;
        default:
          this.checkLValSimple(expr, bindingType, checkClashes);
      }
    };
    pp$72.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE2;
      switch (expr.type) {
        case "Property":
          this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
          break;
        case "AssignmentPattern":
          this.checkLValPattern(expr.left, bindingType, checkClashes);
          break;
        case "RestElement":
          this.checkLValPattern(expr.argument, bindingType, checkClashes);
          break;
        default:
          this.checkLValPattern(expr, bindingType, checkClashes);
      }
    };
    TokContext3 = function TokContext4(token, isExpr, preserveSpace, override, generator) {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
      this.generator = !!generator;
    };
    types$2 = {
      b_stat: new TokContext3("{", false),
      b_expr: new TokContext3("{", true),
      b_tmpl: new TokContext3("${", false),
      p_stat: new TokContext3("(", false),
      p_expr: new TokContext3("(", true),
      q_tmpl: new TokContext3("`", true, true, function(p) {
        return p.tryReadTemplateToken();
      }),
      f_stat: new TokContext3("function", false),
      f_expr: new TokContext3("function", true),
      f_expr_gen: new TokContext3("function", true, false, null, true),
      f_gen: new TokContext3("function", false, false, null, true)
    };
    pp$62 = Parser$1.prototype;
    pp$62.initialContext = function() {
      return [types$2.b_stat];
    };
    pp$62.curContext = function() {
      return this.context[this.context.length - 1];
    };
    pp$62.braceIsBlock = function(prevType) {
      var parent = this.curContext();
      if (parent === types$2.f_expr || parent === types$2.f_stat) {
        return true;
      }
      if (prevType === types$12.colon && (parent === types$2.b_stat || parent === types$2.b_expr)) {
        return !parent.isExpr;
      }
      if (prevType === types$12._return || prevType === types$12.name && this.exprAllowed) {
        return lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
      }
      if (prevType === types$12._else || prevType === types$12.semi || prevType === types$12.eof || prevType === types$12.parenR || prevType === types$12.arrow) {
        return true;
      }
      if (prevType === types$12.braceL) {
        return parent === types$2.b_stat;
      }
      if (prevType === types$12._var || prevType === types$12._const || prevType === types$12.name) {
        return false;
      }
      return !this.exprAllowed;
    };
    pp$62.inGeneratorContext = function() {
      for (var i = this.context.length - 1; i >= 1; i--) {
        var context = this.context[i];
        if (context.token === "function") {
          return context.generator;
        }
      }
      return false;
    };
    pp$62.updateContext = function(prevType) {
      var update, type = this.type;
      if (type.keyword && prevType === types$12.dot) {
        this.exprAllowed = false;
      } else if (update = type.updateContext) {
        update.call(this, prevType);
      } else {
        this.exprAllowed = type.beforeExpr;
      }
    };
    pp$62.overrideContext = function(tokenCtx) {
      if (this.curContext() !== tokenCtx) {
        this.context[this.context.length - 1] = tokenCtx;
      }
    };
    types$12.parenR.updateContext = types$12.braceR.updateContext = function() {
      if (this.context.length === 1) {
        this.exprAllowed = true;
        return;
      }
      var out = this.context.pop();
      if (out === types$2.b_stat && this.curContext().token === "function") {
        out = this.context.pop();
      }
      this.exprAllowed = !out.isExpr;
    };
    types$12.braceL.updateContext = function(prevType) {
      this.context.push(this.braceIsBlock(prevType) ? types$2.b_stat : types$2.b_expr);
      this.exprAllowed = true;
    };
    types$12.dollarBraceL.updateContext = function() {
      this.context.push(types$2.b_tmpl);
      this.exprAllowed = true;
    };
    types$12.parenL.updateContext = function(prevType) {
      var statementParens = prevType === types$12._if || prevType === types$12._for || prevType === types$12._with || prevType === types$12._while;
      this.context.push(statementParens ? types$2.p_stat : types$2.p_expr);
      this.exprAllowed = true;
    };
    types$12.incDec.updateContext = function() {
    };
    types$12._function.updateContext = types$12._class.updateContext = function(prevType) {
      if (prevType.beforeExpr && prevType !== types$12._else && !(prevType === types$12.semi && this.curContext() !== types$2.p_stat) && !(prevType === types$12._return && lineBreak2.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$12.colon || prevType === types$12.braceL) && this.curContext() === types$2.b_stat)) {
        this.context.push(types$2.f_expr);
      } else {
        this.context.push(types$2.f_stat);
      }
      this.exprAllowed = false;
    };
    types$12.backQuote.updateContext = function() {
      if (this.curContext() === types$2.q_tmpl) {
        this.context.pop();
      } else {
        this.context.push(types$2.q_tmpl);
      }
      this.exprAllowed = false;
    };
    types$12.star.updateContext = function(prevType) {
      if (prevType === types$12._function) {
        var index = this.context.length - 1;
        if (this.context[index] === types$2.f_expr) {
          this.context[index] = types$2.f_expr_gen;
        } else {
          this.context[index] = types$2.f_gen;
        }
      }
      this.exprAllowed = true;
    };
    types$12.name.updateContext = function(prevType) {
      var allowed = false;
      if (this.options.ecmaVersion >= 6 && prevType !== types$12.dot) {
        if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
          allowed = true;
        }
      }
      this.exprAllowed = allowed;
    };
    pp$52 = Parser$1.prototype;
    pp$52.checkPropClash = function(prop, propHash, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
        return;
      }
      if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
        return;
      }
      var key = prop.key;
      var name2;
      switch (key.type) {
        case "Identifier":
          name2 = key.name;
          break;
        case "Literal":
          name2 = String(key.value);
          break;
        default:
          return;
      }
      var kind = prop.kind;
      if (this.options.ecmaVersion >= 6) {
        if (name2 === "__proto__" && kind === "init") {
          if (propHash.proto) {
            if (refDestructuringErrors) {
              if (refDestructuringErrors.doubleProto < 0) {
                refDestructuringErrors.doubleProto = key.start;
              }
            } else {
              this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
            }
          }
          propHash.proto = true;
        }
        return;
      }
      name2 = "$" + name2;
      var other = propHash[name2];
      if (other) {
        var redefinition;
        if (kind === "init") {
          redefinition = this.strict && other.init || other.get || other.set;
        } else {
          redefinition = other.init || other[kind];
        }
        if (redefinition) {
          this.raiseRecoverable(key.start, "Redefinition of property");
        }
      } else {
        other = propHash[name2] = {
          init: false,
          get: false,
          set: false
        };
      }
      other[kind] = true;
    };
    pp$52.parseExpression = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
      if (this.type === types$12.comma) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.expressions = [expr];
        while (this.eat(types$12.comma)) {
          node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
        }
        return this.finishNode(node2, "SequenceExpression");
      }
      return expr;
    };
    pp$52.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
      if (this.isContextual("yield")) {
        if (this.inGenerator) {
          return this.parseYield(forInit);
        } else {
          this.exprAllowed = false;
        }
      }
      var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
      if (refDestructuringErrors) {
        oldParenAssign = refDestructuringErrors.parenthesizedAssign;
        oldTrailingComma = refDestructuringErrors.trailingComma;
        oldDoubleProto = refDestructuringErrors.doubleProto;
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
      } else {
        refDestructuringErrors = new DestructuringErrors3();
        ownDestructuringErrors = true;
      }
      var startPos = this.start, startLoc = this.startLoc;
      if (this.type === types$12.parenL || this.type === types$12.name) {
        this.potentialArrowAt = this.start;
        this.potentialArrowInForAwait = forInit === "await";
      }
      var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }
      if (this.type.isAssign) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.operator = this.value;
        if (this.type === types$12.eq) {
          left = this.toAssignable(left, false, refDestructuringErrors);
        }
        if (!ownDestructuringErrors) {
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
        }
        if (refDestructuringErrors.shorthandAssign >= left.start) {
          refDestructuringErrors.shorthandAssign = -1;
        }
        if (this.type === types$12.eq) {
          this.checkLValPattern(left);
        } else {
          this.checkLValSimple(left);
        }
        node2.left = left;
        this.next();
        node2.right = this.parseMaybeAssign(forInit);
        if (oldDoubleProto > -1) {
          refDestructuringErrors.doubleProto = oldDoubleProto;
        }
        return this.finishNode(node2, "AssignmentExpression");
      } else {
        if (ownDestructuringErrors) {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
      }
      if (oldParenAssign > -1) {
        refDestructuringErrors.parenthesizedAssign = oldParenAssign;
      }
      if (oldTrailingComma > -1) {
        refDestructuringErrors.trailingComma = oldTrailingComma;
      }
      return left;
    };
    pp$52.parseMaybeConditional = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprOps(forInit, refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      if (this.eat(types$12.question)) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.test = expr;
        node2.consequent = this.parseMaybeAssign();
        this.expect(types$12.colon);
        node2.alternate = this.parseMaybeAssign(forInit);
        return this.finishNode(node2, "ConditionalExpression");
      }
      return expr;
    };
    pp$52.parseExprOps = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
    };
    pp$52.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
      var prec = this.type.binop;
      if (prec != null && (!forInit || this.type !== types$12._in)) {
        if (prec > minPrec) {
          var logical = this.type === types$12.logicalOR || this.type === types$12.logicalAND;
          var coalesce = this.type === types$12.coalesce;
          if (coalesce) {
            prec = types$12.logicalAND.binop;
          }
          var op = this.value;
          this.next();
          var startPos = this.start, startLoc = this.startLoc;
          var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
          var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
          if (logical && this.type === types$12.coalesce || coalesce && (this.type === types$12.logicalOR || this.type === types$12.logicalAND)) {
            this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
          }
          return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
        }
      }
      return left;
    };
    pp$52.buildBinary = function(startPos, startLoc, left, right, op, logical) {
      if (right.type === "PrivateIdentifier") {
        this.raise(right.start, "Private identifier can only be left side of binary expression");
      }
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.left = left;
      node2.operator = op;
      node2.right = right;
      return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
    };
    pp$52.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
      var startPos = this.start, startLoc = this.startLoc, expr;
      if (this.isContextual("await") && this.canAwait) {
        expr = this.parseAwait(forInit);
        sawUnary = true;
      } else if (this.type.prefix) {
        var node2 = this.startNode(), update = this.type === types$12.incDec;
        node2.operator = this.value;
        node2.prefix = true;
        this.next();
        node2.argument = this.parseMaybeUnary(null, true, update, forInit);
        this.checkExpressionErrors(refDestructuringErrors, true);
        if (update) {
          this.checkLValSimple(node2.argument);
        } else if (this.strict && node2.operator === "delete" && node2.argument.type === "Identifier") {
          this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
        } else if (node2.operator === "delete" && isPrivateFieldAccess2(node2.argument)) {
          this.raiseRecoverable(node2.start, "Private fields can not be deleted");
        } else {
          sawUnary = true;
        }
        expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
      } else if (!sawUnary && this.type === types$12.privateId) {
        if (forInit || this.privateNameStack.length === 0) {
          this.unexpected();
        }
        expr = this.parsePrivateIdent();
        if (this.type !== types$12._in) {
          this.unexpected();
        }
      } else {
        expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        while (this.type.postfix && !this.canInsertSemicolon()) {
          var node$12 = this.startNodeAt(startPos, startLoc);
          node$12.operator = this.value;
          node$12.prefix = false;
          node$12.argument = expr;
          this.checkLValSimple(expr);
          this.next();
          expr = this.finishNode(node$12, "UpdateExpression");
        }
      }
      if (!incDec && this.eat(types$12.starstar)) {
        if (sawUnary) {
          this.unexpected(this.lastTokStart);
        } else {
          return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
        }
      } else {
        return expr;
      }
    };
    pp$52.parseExprSubscripts = function(refDestructuringErrors, forInit) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprAtom(refDestructuringErrors, forInit);
      if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
        return expr;
      }
      var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
      if (refDestructuringErrors && result.type === "MemberExpression") {
        if (refDestructuringErrors.parenthesizedAssign >= result.start) {
          refDestructuringErrors.parenthesizedAssign = -1;
        }
        if (refDestructuringErrors.parenthesizedBind >= result.start) {
          refDestructuringErrors.parenthesizedBind = -1;
        }
        if (refDestructuringErrors.trailingComma >= result.start) {
          refDestructuringErrors.trailingComma = -1;
        }
      }
      return result;
    };
    pp$52.parseSubscripts = function(base3, startPos, startLoc, noCalls, forInit) {
      var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base3.type === "Identifier" && base3.name === "async" && this.lastTokEnd === base3.end && !this.canInsertSemicolon() && base3.end - base3.start === 5 && this.potentialArrowAt === base3.start;
      var optionalChained = false;
      while (true) {
        var element = this.parseSubscript(base3, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
        if (element.optional) {
          optionalChained = true;
        }
        if (element === base3 || element.type === "ArrowFunctionExpression") {
          if (optionalChained) {
            var chainNode = this.startNodeAt(startPos, startLoc);
            chainNode.expression = element;
            element = this.finishNode(chainNode, "ChainExpression");
          }
          return element;
        }
        base3 = element;
      }
    };
    pp$52.parseSubscript = function(base3, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
      var optionalSupported = this.options.ecmaVersion >= 11;
      var optional = optionalSupported && this.eat(types$12.questionDot);
      if (noCalls && optional) {
        this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
      }
      var computed = this.eat(types$12.bracketL);
      if (computed || optional && this.type !== types$12.parenL && this.type !== types$12.backQuote || this.eat(types$12.dot)) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.object = base3;
        if (computed) {
          node2.property = this.parseExpression();
          this.expect(types$12.bracketR);
        } else if (this.type === types$12.privateId && base3.type !== "Super") {
          node2.property = this.parsePrivateIdent();
        } else {
          node2.property = this.parseIdent(this.options.allowReserved !== "never");
        }
        node2.computed = !!computed;
        if (optionalSupported) {
          node2.optional = optional;
        }
        base3 = this.finishNode(node2, "MemberExpression");
      } else if (!noCalls && this.eat(types$12.parenL)) {
        var refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        var exprList = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
        if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$12.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          if (this.awaitIdentPos > 0) {
            this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
          }
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
        var node$12 = this.startNodeAt(startPos, startLoc);
        node$12.callee = base3;
        node$12.arguments = exprList;
        if (optionalSupported) {
          node$12.optional = optional;
        }
        base3 = this.finishNode(node$12, "CallExpression");
      } else if (this.type === types$12.backQuote) {
        if (optional || optionalChained) {
          this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        }
        var node$2 = this.startNodeAt(startPos, startLoc);
        node$2.tag = base3;
        node$2.quasi = this.parseTemplate({ isTagged: true });
        base3 = this.finishNode(node$2, "TaggedTemplateExpression");
      }
      return base3;
    };
    pp$52.parseExprAtom = function(refDestructuringErrors, forInit) {
      if (this.type === types$12.slash) {
        this.readRegexp();
      }
      var node2, canBeArrow = this.potentialArrowAt === this.start;
      switch (this.type) {
        case types$12._super:
          if (!this.allowSuper) {
            this.raise(this.start, "'super' keyword outside a method");
          }
          node2 = this.startNode();
          this.next();
          if (this.type === types$12.parenL && !this.allowDirectSuper) {
            this.raise(node2.start, "super() call outside constructor of a subclass");
          }
          if (this.type !== types$12.dot && this.type !== types$12.bracketL && this.type !== types$12.parenL) {
            this.unexpected();
          }
          return this.finishNode(node2, "Super");
        case types$12._this:
          node2 = this.startNode();
          this.next();
          return this.finishNode(node2, "ThisExpression");
        case types$12.name:
          var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          var id = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$12._function)) {
            this.overrideContext(types$2.f_expr);
            return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(types$12.arrow)) {
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
            }
            if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$12.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
              id = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(types$12.arrow)) {
                this.unexpected();
              }
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
            }
          }
          return id;
        case types$12.regexp:
          var value2 = this.value;
          node2 = this.parseLiteral(value2.value);
          node2.regex = { pattern: value2.pattern, flags: value2.flags };
          return node2;
        case types$12.num:
        case types$12.string:
          return this.parseLiteral(this.value);
        case types$12._null:
        case types$12._true:
        case types$12._false:
          node2 = this.startNode();
          node2.value = this.type === types$12._null ? null : this.type === types$12._true;
          node2.raw = this.type.keyword;
          this.next();
          return this.finishNode(node2, "Literal");
        case types$12.parenL:
          var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
          if (refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
              refDestructuringErrors.parenthesizedAssign = start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = start;
            }
          }
          return expr;
        case types$12.bracketL:
          node2 = this.startNode();
          this.next();
          node2.elements = this.parseExprList(types$12.bracketR, true, true, refDestructuringErrors);
          return this.finishNode(node2, "ArrayExpression");
        case types$12.braceL:
          this.overrideContext(types$2.b_expr);
          return this.parseObj(false, refDestructuringErrors);
        case types$12._function:
          node2 = this.startNode();
          this.next();
          return this.parseFunction(node2, 0);
        case types$12._class:
          return this.parseClass(this.startNode(), false);
        case types$12._new:
          return this.parseNew();
        case types$12.backQuote:
          return this.parseTemplate();
        case types$12._import:
          if (this.options.ecmaVersion >= 11) {
            return this.parseExprImport();
          } else {
            return this.unexpected();
          }
        default:
          this.unexpected();
      }
    };
    pp$52.parseExprImport = function() {
      var node2 = this.startNode();
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword import");
      }
      var meta = this.parseIdent(true);
      switch (this.type) {
        case types$12.parenL:
          return this.parseDynamicImport(node2);
        case types$12.dot:
          node2.meta = meta;
          return this.parseImportMeta(node2);
        default:
          this.unexpected();
      }
    };
    pp$52.parseDynamicImport = function(node2) {
      this.next();
      node2.source = this.parseMaybeAssign();
      if (!this.eat(types$12.parenR)) {
        var errorPos = this.start;
        if (this.eat(types$12.comma) && this.eat(types$12.parenR)) {
          this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
        } else {
          this.unexpected(errorPos);
        }
      }
      return this.finishNode(node2, "ImportExpression");
    };
    pp$52.parseImportMeta = function(node2) {
      this.next();
      var containsEsc = this.containsEsc;
      node2.property = this.parseIdent(true);
      if (node2.property.name !== "meta") {
        this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
      }
      if (containsEsc) {
        this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
      }
      if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
        this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
      }
      return this.finishNode(node2, "MetaProperty");
    };
    pp$52.parseLiteral = function(value2) {
      var node2 = this.startNode();
      node2.value = value2;
      node2.raw = this.input.slice(this.start, this.end);
      if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
        node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
      }
      this.next();
      return this.finishNode(node2, "Literal");
    };
    pp$52.parseParenExpression = function() {
      this.expect(types$12.parenL);
      var val = this.parseExpression();
      this.expect(types$12.parenR);
      return val;
    };
    pp$52.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
      var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();
        var innerStartPos = this.start, innerStartLoc = this.startLoc;
        var exprList = [], first2 = true, lastIsComma = false;
        var refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
        this.yieldPos = 0;
        this.awaitPos = 0;
        while (this.type !== types$12.parenR) {
          first2 ? first2 = false : this.expect(types$12.comma);
          if (allowTrailingComma && this.afterTrailingComma(types$12.parenR, true)) {
            lastIsComma = true;
            break;
          } else if (this.type === types$12.ellipsis) {
            spreadStart = this.start;
            exprList.push(this.parseParenItem(this.parseRestBinding()));
            if (this.type === types$12.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            break;
          } else {
            exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
          }
        }
        var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
        this.expect(types$12.parenR);
        if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$12.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
        }
        if (!exprList.length || lastIsComma) {
          this.unexpected(this.lastTokStart);
        }
        if (spreadStart) {
          this.unexpected(spreadStart);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }
      } else {
        val = this.parseParenExpression();
      }
      if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression");
      } else {
        return val;
      }
    };
    pp$52.parseParenItem = function(item) {
      return item;
    };
    pp$52.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
    };
    empty2 = [];
    pp$52.parseNew = function() {
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword new");
      }
      var node2 = this.startNode();
      var meta = this.parseIdent(true);
      if (this.options.ecmaVersion >= 6 && this.eat(types$12.dot)) {
        node2.meta = meta;
        var containsEsc = this.containsEsc;
        node2.property = this.parseIdent(true);
        if (node2.property.name !== "target") {
          this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
        }
        if (!this.allowNewDotTarget) {
          this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
        }
        return this.finishNode(node2, "MetaProperty");
      }
      var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$12._import;
      node2.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
      if (isImport && node2.callee.type === "ImportExpression") {
        this.raise(startPos, "Cannot use new with import()");
      }
      if (this.eat(types$12.parenL)) {
        node2.arguments = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false);
      } else {
        node2.arguments = empty2;
      }
      return this.finishNode(node2, "NewExpression");
    };
    pp$52.parseTemplateElement = function(ref3) {
      var isTagged = ref3.isTagged;
      var elem = this.startNode();
      if (this.type === types$12.invalidTemplate) {
        if (!isTagged) {
          this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        }
        elem.value = {
          raw: this.value,
          cooked: null
        };
      } else {
        elem.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
          cooked: this.value
        };
      }
      this.next();
      elem.tail = this.type === types$12.backQuote;
      return this.finishNode(elem, "TemplateElement");
    };
    pp$52.parseTemplate = function(ref3) {
      if (ref3 === void 0)
        ref3 = {};
      var isTagged = ref3.isTagged;
      if (isTagged === void 0)
        isTagged = false;
      var node2 = this.startNode();
      this.next();
      node2.expressions = [];
      var curElt = this.parseTemplateElement({ isTagged });
      node2.quasis = [curElt];
      while (!curElt.tail) {
        if (this.type === types$12.eof) {
          this.raise(this.pos, "Unterminated template literal");
        }
        this.expect(types$12.dollarBraceL);
        node2.expressions.push(this.parseExpression());
        this.expect(types$12.braceR);
        node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
      }
      this.next();
      return this.finishNode(node2, "TemplateLiteral");
    };
    pp$52.isAsyncProp = function(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$12.name || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$12.star) && !lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$52.parseObj = function(isPattern, refDestructuringErrors) {
      var node2 = this.startNode(), first2 = true, propHash = {};
      node2.properties = [];
      this.next();
      while (!this.eat(types$12.braceR)) {
        if (!first2) {
          this.expect(types$12.comma);
          if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$12.braceR)) {
            break;
          }
        } else {
          first2 = false;
        }
        var prop = this.parseProperty(isPattern, refDestructuringErrors);
        if (!isPattern) {
          this.checkPropClash(prop, propHash, refDestructuringErrors);
        }
        node2.properties.push(prop);
      }
      return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
    };
    pp$52.parseProperty = function(isPattern, refDestructuringErrors) {
      var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
      if (this.options.ecmaVersion >= 9 && this.eat(types$12.ellipsis)) {
        if (isPattern) {
          prop.argument = this.parseIdent(false);
          if (this.type === types$12.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          return this.finishNode(prop, "RestElement");
        }
        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        if (this.type === types$12.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
        return this.finishNode(prop, "SpreadElement");
      }
      if (this.options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refDestructuringErrors) {
          startPos = this.start;
          startLoc = this.startLoc;
        }
        if (!isPattern) {
          isGenerator = this.eat(types$12.star);
        }
      }
      var containsEsc = this.containsEsc;
      this.parsePropertyName(prop);
      if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$12.star);
        this.parsePropertyName(prop);
      } else {
        isAsync = false;
      }
      this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
      return this.finishNode(prop, "Property");
    };
    pp$52.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
      if ((isGenerator || isAsync) && this.type === types$12.colon) {
        this.unexpected();
      }
      if (this.eat(types$12.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
        prop.kind = "init";
      } else if (this.options.ecmaVersion >= 6 && this.type === types$12.parenL) {
        if (isPattern) {
          this.unexpected();
        }
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator, isAsync);
      } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$12.comma && this.type !== types$12.braceR && this.type !== types$12.eq)) {
        if (isGenerator || isAsync) {
          this.unexpected();
        }
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        if (isGenerator || isAsync) {
          this.unexpected();
        }
        this.checkUnreserved(prop.key);
        if (prop.key.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = startPos;
        }
        prop.kind = "init";
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else if (this.type === types$12.eq && refDestructuringErrors) {
          if (refDestructuringErrors.shorthandAssign < 0) {
            refDestructuringErrors.shorthandAssign = this.start;
          }
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else {
          prop.value = this.copyNode(prop.key);
        }
        prop.shorthand = true;
      } else {
        this.unexpected();
      }
    };
    pp$52.parsePropertyName = function(prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(types$12.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(types$12.bracketR);
          return prop.key;
        } else {
          prop.computed = false;
        }
      }
      return prop.key = this.type === types$12.num || this.type === types$12.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    };
    pp$52.initFunction = function(node2) {
      node2.id = null;
      if (this.options.ecmaVersion >= 6) {
        node2.generator = node2.expression = false;
      }
      if (this.options.ecmaVersion >= 8) {
        node2.async = false;
      }
    };
    pp$52.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
      var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.initFunction(node2);
      if (this.options.ecmaVersion >= 6) {
        node2.generator = isGenerator;
      }
      if (this.options.ecmaVersion >= 8) {
        node2.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags2(isAsync, node2.generator) | SCOPE_SUPER2 | (allowDirectSuper ? SCOPE_DIRECT_SUPER2 : 0));
      this.expect(types$12.parenL);
      node2.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
      this.parseFunctionBody(node2, false, true, false);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node2, "FunctionExpression");
    };
    pp$52.parseArrowExpression = function(node2, params, isAsync, forInit) {
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.enterScope(functionFlags2(isAsync, false) | SCOPE_ARROW2);
      this.initFunction(node2);
      if (this.options.ecmaVersion >= 8) {
        node2.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      node2.params = this.toAssignableList(params, true);
      this.parseFunctionBody(node2, true, false, forInit);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node2, "ArrowFunctionExpression");
    };
    pp$52.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
      var isExpression = isArrowFunction && this.type !== types$12.braceL;
      var oldStrict = this.strict, useStrict = false;
      if (isExpression) {
        node2.body = this.parseMaybeAssign(forInit);
        node2.expression = true;
        this.checkParams(node2, false);
      } else {
        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
        if (!oldStrict || nonSimple) {
          useStrict = this.strictDirective(this.end);
          if (useStrict && nonSimple) {
            this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
          }
        }
        var oldLabels = this.labels;
        this.labels = [];
        if (useStrict) {
          this.strict = true;
        }
        this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
        if (this.strict && node2.id) {
          this.checkLValSimple(node2.id, BIND_OUTSIDE2);
        }
        node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
        node2.expression = false;
        this.adaptDirectivePrologue(node2.body.body);
        this.labels = oldLabels;
      }
      this.exitScope();
    };
    pp$52.isSimpleParamList = function(params) {
      for (var i = 0, list = params; i < list.length; i += 1) {
        var param = list[i];
        if (param.type !== "Identifier") {
          return false;
        }
      }
      return true;
    };
    pp$52.checkParams = function(node2, allowDuplicates) {
      var nameHash = /* @__PURE__ */ Object.create(null);
      for (var i = 0, list = node2.params; i < list.length; i += 1) {
        var param = list[i];
        this.checkLValInnerPattern(param, BIND_VAR2, allowDuplicates ? null : nameHash);
      }
    };
    pp$52.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
      var elts = [], first2 = true;
      while (!this.eat(close2)) {
        if (!first2) {
          this.expect(types$12.comma);
          if (allowTrailingComma && this.afterTrailingComma(close2)) {
            break;
          }
        } else {
          first2 = false;
        }
        var elt = void 0;
        if (allowEmpty && this.type === types$12.comma) {
          elt = null;
        } else if (this.type === types$12.ellipsis) {
          elt = this.parseSpread(refDestructuringErrors);
          if (refDestructuringErrors && this.type === types$12.comma && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
        } else {
          elt = this.parseMaybeAssign(false, refDestructuringErrors);
        }
        elts.push(elt);
      }
      return elts;
    };
    pp$52.checkUnreserved = function(ref3) {
      var start = ref3.start;
      var end = ref3.end;
      var name2 = ref3.name;
      if (this.inGenerator && name2 === "yield") {
        this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
      }
      if (this.inAsync && name2 === "await") {
        this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
      }
      if (this.currentThisScope().inClassFieldInit && name2 === "arguments") {
        this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
      }
      if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
        this.raise(start, "Cannot use " + name2 + " in class static initialization block");
      }
      if (this.keywords.test(name2)) {
        this.raise(start, "Unexpected keyword '" + name2 + "'");
      }
      if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
        return;
      }
      var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
      if (re.test(name2)) {
        if (!this.inAsync && name2 === "await") {
          this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
        }
        this.raiseRecoverable(start, "The keyword '" + name2 + "' is reserved");
      }
    };
    pp$52.parseIdent = function(liberal) {
      var node2 = this.startNode();
      if (this.type === types$12.name) {
        node2.name = this.value;
      } else if (this.type.keyword) {
        node2.name = this.type.keyword;
        if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
          this.context.pop();
        }
      } else {
        this.unexpected();
      }
      this.next(!!liberal);
      this.finishNode(node2, "Identifier");
      if (!liberal) {
        this.checkUnreserved(node2);
        if (node2.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = node2.start;
        }
      }
      return node2;
    };
    pp$52.parsePrivateIdent = function() {
      var node2 = this.startNode();
      if (this.type === types$12.privateId) {
        node2.name = this.value;
      } else {
        this.unexpected();
      }
      this.next();
      this.finishNode(node2, "PrivateIdentifier");
      if (this.privateNameStack.length === 0) {
        this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
      } else {
        this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
      }
      return node2;
    };
    pp$52.parseYield = function(forInit) {
      if (!this.yieldPos) {
        this.yieldPos = this.start;
      }
      var node2 = this.startNode();
      this.next();
      if (this.type === types$12.semi || this.canInsertSemicolon() || this.type !== types$12.star && !this.type.startsExpr) {
        node2.delegate = false;
        node2.argument = null;
      } else {
        node2.delegate = this.eat(types$12.star);
        node2.argument = this.parseMaybeAssign(forInit);
      }
      return this.finishNode(node2, "YieldExpression");
    };
    pp$52.parseAwait = function(forInit) {
      if (!this.awaitPos) {
        this.awaitPos = this.start;
      }
      var node2 = this.startNode();
      this.next();
      node2.argument = this.parseMaybeUnary(null, true, false, forInit);
      return this.finishNode(node2, "AwaitExpression");
    };
    pp$42 = Parser$1.prototype;
    pp$42.raise = function(pos, message) {
      var loc = getLineInfo2(this.input, pos);
      message += " (" + loc.line + ":" + loc.column + ")";
      var err = new SyntaxError(message);
      err.pos = pos;
      err.loc = loc;
      err.raisedAt = this.pos;
      throw err;
    };
    pp$42.raiseRecoverable = pp$42.raise;
    pp$42.curPosition = function() {
      if (this.options.locations) {
        return new Position3(this.curLine, this.pos - this.lineStart);
      }
    };
    pp$32 = Parser$1.prototype;
    Scope4 = function Scope5(flags) {
      this.flags = flags;
      this.var = [];
      this.lexical = [];
      this.functions = [];
      this.inClassFieldInit = false;
    };
    pp$32.enterScope = function(flags) {
      this.scopeStack.push(new Scope4(flags));
    };
    pp$32.exitScope = function() {
      this.scopeStack.pop();
    };
    pp$32.treatFunctionsAsVarInScope = function(scope) {
      return scope.flags & SCOPE_FUNCTION2 || !this.inModule && scope.flags & SCOPE_TOP2;
    };
    pp$32.declareName = function(name2, bindingType, pos) {
      var redeclared = false;
      if (bindingType === BIND_LEXICAL2) {
        var scope = this.currentScope();
        redeclared = scope.lexical.indexOf(name2) > -1 || scope.functions.indexOf(name2) > -1 || scope.var.indexOf(name2) > -1;
        scope.lexical.push(name2);
        if (this.inModule && scope.flags & SCOPE_TOP2) {
          delete this.undefinedExports[name2];
        }
      } else if (bindingType === BIND_SIMPLE_CATCH2) {
        var scope$1 = this.currentScope();
        scope$1.lexical.push(name2);
      } else if (bindingType === BIND_FUNCTION2) {
        var scope$2 = this.currentScope();
        if (this.treatFunctionsAsVar) {
          redeclared = scope$2.lexical.indexOf(name2) > -1;
        } else {
          redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
        }
        scope$2.functions.push(name2);
      } else {
        for (var i = this.scopeStack.length - 1; i >= 0; --i) {
          var scope$3 = this.scopeStack[i];
          if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH2 && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
            redeclared = true;
            break;
          }
          scope$3.var.push(name2);
          if (this.inModule && scope$3.flags & SCOPE_TOP2) {
            delete this.undefinedExports[name2];
          }
          if (scope$3.flags & SCOPE_VAR2) {
            break;
          }
        }
      }
      if (redeclared) {
        this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
      }
    };
    pp$32.checkLocalExport = function(id) {
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
        this.undefinedExports[id.name] = id;
      }
    };
    pp$32.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1];
    };
    pp$32.currentVarScope = function() {
      for (var i = this.scopeStack.length - 1; ; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR2) {
          return scope;
        }
      }
    };
    pp$32.currentThisScope = function() {
      for (var i = this.scopeStack.length - 1; ; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR2 && !(scope.flags & SCOPE_ARROW2)) {
          return scope;
        }
      }
    };
    Node3 = function Node4(parser, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      if (parser.options.locations) {
        this.loc = new SourceLocation3(parser, loc);
      }
      if (parser.options.directSourceFile) {
        this.sourceFile = parser.options.directSourceFile;
      }
      if (parser.options.ranges) {
        this.range = [pos, 0];
      }
    };
    pp$22 = Parser$1.prototype;
    pp$22.startNode = function() {
      return new Node3(this, this.start, this.startLoc);
    };
    pp$22.startNodeAt = function(pos, loc) {
      return new Node3(this, pos, loc);
    };
    pp$22.finishNode = function(node2, type) {
      return finishNodeAt2.call(this, node2, type, this.lastTokEnd, this.lastTokEndLoc);
    };
    pp$22.finishNodeAt = function(node2, type, pos, loc) {
      return finishNodeAt2.call(this, node2, type, pos, loc);
    };
    pp$22.copyNode = function(node2) {
      var newNode = new Node3(this, node2.start, this.startLoc);
      for (var prop in node2) {
        newNode[prop] = node2[prop];
      }
      return newNode;
    };
    ecma9BinaryProperties2 = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    ecma10BinaryProperties2 = ecma9BinaryProperties2 + " Extended_Pictographic";
    ecma11BinaryProperties2 = ecma10BinaryProperties2;
    ecma12BinaryProperties2 = ecma11BinaryProperties2 + " EBase EComp EMod EPres ExtPict";
    ecma13BinaryProperties2 = ecma12BinaryProperties2;
    ecma14BinaryProperties2 = ecma13BinaryProperties2;
    unicodeBinaryProperties2 = {
      9: ecma9BinaryProperties2,
      10: ecma10BinaryProperties2,
      11: ecma11BinaryProperties2,
      12: ecma12BinaryProperties2,
      13: ecma13BinaryProperties2,
      14: ecma14BinaryProperties2
    };
    unicodeGeneralCategoryValues2 = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
    ecma9ScriptValues2 = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    ecma10ScriptValues2 = ecma9ScriptValues2 + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    ecma11ScriptValues2 = ecma10ScriptValues2 + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    ecma12ScriptValues2 = ecma11ScriptValues2 + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
    ecma13ScriptValues2 = ecma12ScriptValues2 + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
    ecma14ScriptValues2 = ecma13ScriptValues2 + " Kawi Nag_Mundari Nagm";
    unicodeScriptValues2 = {
      9: ecma9ScriptValues2,
      10: ecma10ScriptValues2,
      11: ecma11ScriptValues2,
      12: ecma12ScriptValues2,
      13: ecma13ScriptValues2,
      14: ecma14ScriptValues2
    };
    data2 = {};
    for (i$1 = 0, list = [9, 10, 11, 12, 13, 14]; i$1 < list.length; i$1 += 1) {
      ecmaVersion = list[i$1];
      buildUnicodeData2(ecmaVersion);
    }
    pp$12 = Parser$1.prototype;
    RegExpValidationState3 = function RegExpValidationState4(parser) {
      this.parser = parser;
      this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "");
      this.unicodeProperties = data2[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
      this.source = "";
      this.flags = "";
      this.start = 0;
      this.switchU = false;
      this.switchN = false;
      this.pos = 0;
      this.lastIntValue = 0;
      this.lastStringValue = "";
      this.lastAssertionIsQuantifiable = false;
      this.numCapturingParens = 0;
      this.maxBackReference = 0;
      this.groupNames = [];
      this.backReferenceNames = [];
    };
    RegExpValidationState3.prototype.reset = function reset2(start, pattern2, flags) {
      var unicode = flags.indexOf("u") !== -1;
      this.start = start | 0;
      this.source = pattern2 + "";
      this.flags = flags;
      this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
      this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
    };
    RegExpValidationState3.prototype.raise = function raise2(message) {
      this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
    };
    RegExpValidationState3.prototype.at = function at2(i, forceU) {
      if (forceU === void 0)
        forceU = false;
      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return -1;
      }
      var c = s.charCodeAt(i);
      if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
        return c;
      }
      var next = s.charCodeAt(i + 1);
      return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
    };
    RegExpValidationState3.prototype.nextIndex = function nextIndex2(i, forceU) {
      if (forceU === void 0)
        forceU = false;
      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return l;
      }
      var c = s.charCodeAt(i), next;
      if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
        return i + 1;
      }
      return i + 2;
    };
    RegExpValidationState3.prototype.current = function current2(forceU) {
      if (forceU === void 0)
        forceU = false;
      return this.at(this.pos, forceU);
    };
    RegExpValidationState3.prototype.lookahead = function lookahead2(forceU) {
      if (forceU === void 0)
        forceU = false;
      return this.at(this.nextIndex(this.pos, forceU), forceU);
    };
    RegExpValidationState3.prototype.advance = function advance2(forceU) {
      if (forceU === void 0)
        forceU = false;
      this.pos = this.nextIndex(this.pos, forceU);
    };
    RegExpValidationState3.prototype.eat = function eat2(ch, forceU) {
      if (forceU === void 0)
        forceU = false;
      if (this.current(forceU) === ch) {
        this.advance(forceU);
        return true;
      }
      return false;
    };
    pp$12.validateRegExpFlags = function(state) {
      var validFlags = state.validFlags;
      var flags = state.flags;
      for (var i = 0; i < flags.length; i++) {
        var flag = flags.charAt(i);
        if (validFlags.indexOf(flag) === -1) {
          this.raise(state.start, "Invalid regular expression flag");
        }
        if (flags.indexOf(flag, i + 1) > -1) {
          this.raise(state.start, "Duplicate regular expression flag");
        }
      }
    };
    pp$12.validateRegExpPattern = function(state) {
      this.regexp_pattern(state);
      if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
        state.switchN = true;
        this.regexp_pattern(state);
      }
    };
    pp$12.regexp_pattern = function(state) {
      state.pos = 0;
      state.lastIntValue = 0;
      state.lastStringValue = "";
      state.lastAssertionIsQuantifiable = false;
      state.numCapturingParens = 0;
      state.maxBackReference = 0;
      state.groupNames.length = 0;
      state.backReferenceNames.length = 0;
      this.regexp_disjunction(state);
      if (state.pos !== state.source.length) {
        if (state.eat(
          41
          /* ) */
        )) {
          state.raise("Unmatched ')'");
        }
        if (state.eat(
          93
          /* ] */
        ) || state.eat(
          125
          /* } */
        )) {
          state.raise("Lone quantifier brackets");
        }
      }
      if (state.maxBackReference > state.numCapturingParens) {
        state.raise("Invalid escape");
      }
      for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
        var name2 = list[i];
        if (state.groupNames.indexOf(name2) === -1) {
          state.raise("Invalid named capture referenced");
        }
      }
    };
    pp$12.regexp_disjunction = function(state) {
      this.regexp_alternative(state);
      while (state.eat(
        124
        /* | */
      )) {
        this.regexp_alternative(state);
      }
      if (this.regexp_eatQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      if (state.eat(
        123
        /* { */
      )) {
        state.raise("Lone quantifier brackets");
      }
    };
    pp$12.regexp_alternative = function(state) {
      while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
      }
    };
    pp$12.regexp_eatTerm = function(state) {
      if (this.regexp_eatAssertion(state)) {
        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
          if (state.switchU) {
            state.raise("Invalid quantifier");
          }
        }
        return true;
      }
      if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
        this.regexp_eatQuantifier(state);
        return true;
      }
      return false;
    };
    pp$12.regexp_eatAssertion = function(state) {
      var start = state.pos;
      state.lastAssertionIsQuantifiable = false;
      if (state.eat(
        94
        /* ^ */
      ) || state.eat(
        36
        /* $ */
      )) {
        return true;
      }
      if (state.eat(
        92
        /* \ */
      )) {
        if (state.eat(
          66
          /* B */
        ) || state.eat(
          98
          /* b */
        )) {
          return true;
        }
        state.pos = start;
      }
      if (state.eat(
        40
        /* ( */
      ) && state.eat(
        63
        /* ? */
      )) {
        var lookbehind = false;
        if (this.options.ecmaVersion >= 9) {
          lookbehind = state.eat(
            60
            /* < */
          );
        }
        if (state.eat(
          61
          /* = */
        ) || state.eat(
          33
          /* ! */
        )) {
          this.regexp_disjunction(state);
          if (!state.eat(
            41
            /* ) */
          )) {
            state.raise("Unterminated group");
          }
          state.lastAssertionIsQuantifiable = !lookbehind;
          return true;
        }
      }
      state.pos = start;
      return false;
    };
    pp$12.regexp_eatQuantifier = function(state, noError) {
      if (noError === void 0)
        noError = false;
      if (this.regexp_eatQuantifierPrefix(state, noError)) {
        state.eat(
          63
          /* ? */
        );
        return true;
      }
      return false;
    };
    pp$12.regexp_eatQuantifierPrefix = function(state, noError) {
      return state.eat(
        42
        /* * */
      ) || state.eat(
        43
        /* + */
      ) || state.eat(
        63
        /* ? */
      ) || this.regexp_eatBracedQuantifier(state, noError);
    };
    pp$12.regexp_eatBracedQuantifier = function(state, noError) {
      var start = state.pos;
      if (state.eat(
        123
        /* { */
      )) {
        var min2 = 0, max = -1;
        if (this.regexp_eatDecimalDigits(state)) {
          min2 = state.lastIntValue;
          if (state.eat(
            44
            /* , */
          ) && this.regexp_eatDecimalDigits(state)) {
            max = state.lastIntValue;
          }
          if (state.eat(
            125
            /* } */
          )) {
            if (max !== -1 && max < min2 && !noError) {
              state.raise("numbers out of order in {} quantifier");
            }
            return true;
          }
        }
        if (state.switchU && !noError) {
          state.raise("Incomplete quantifier");
        }
        state.pos = start;
      }
      return false;
    };
    pp$12.regexp_eatAtom = function(state) {
      return this.regexp_eatPatternCharacters(state) || state.eat(
        46
        /* . */
      ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
    };
    pp$12.regexp_eatReverseSolidusAtomEscape = function(state) {
      var start = state.pos;
      if (state.eat(
        92
        /* \ */
      )) {
        if (this.regexp_eatAtomEscape(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$12.regexp_eatUncapturingGroup = function(state) {
      var start = state.pos;
      if (state.eat(
        40
        /* ( */
      )) {
        if (state.eat(
          63
          /* ? */
        ) && state.eat(
          58
          /* : */
        )) {
          this.regexp_disjunction(state);
          if (state.eat(
            41
            /* ) */
          )) {
            return true;
          }
          state.raise("Unterminated group");
        }
        state.pos = start;
      }
      return false;
    };
    pp$12.regexp_eatCapturingGroup = function(state) {
      if (state.eat(
        40
        /* ( */
      )) {
        if (this.options.ecmaVersion >= 9) {
          this.regexp_groupSpecifier(state);
        } else if (state.current() === 63) {
          state.raise("Invalid group");
        }
        this.regexp_disjunction(state);
        if (state.eat(
          41
          /* ) */
        )) {
          state.numCapturingParens += 1;
          return true;
        }
        state.raise("Unterminated group");
      }
      return false;
    };
    pp$12.regexp_eatExtendedAtom = function(state) {
      return state.eat(
        46
        /* . */
      ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
    };
    pp$12.regexp_eatInvalidBracedQuantifier = function(state) {
      if (this.regexp_eatBracedQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      return false;
    };
    pp$12.regexp_eatSyntaxCharacter = function(state) {
      var ch = state.current();
      if (isSyntaxCharacter2(ch)) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$12.regexp_eatPatternCharacters = function(state) {
      var start = state.pos;
      var ch = 0;
      while ((ch = state.current()) !== -1 && !isSyntaxCharacter2(ch)) {
        state.advance();
      }
      return state.pos !== start;
    };
    pp$12.regexp_eatExtendedPatternCharacter = function(state) {
      var ch = state.current();
      if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
        state.advance();
        return true;
      }
      return false;
    };
    pp$12.regexp_groupSpecifier = function(state) {
      if (state.eat(
        63
        /* ? */
      )) {
        if (this.regexp_eatGroupName(state)) {
          if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
            state.raise("Duplicate capture group name");
          }
          state.groupNames.push(state.lastStringValue);
          return;
        }
        state.raise("Invalid group");
      }
    };
    pp$12.regexp_eatGroupName = function(state) {
      state.lastStringValue = "";
      if (state.eat(
        60
        /* < */
      )) {
        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
          62
          /* > */
        )) {
          return true;
        }
        state.raise("Invalid capture group name");
      }
      return false;
    };
    pp$12.regexp_eatRegExpIdentifierName = function(state) {
      state.lastStringValue = "";
      if (this.regexp_eatRegExpIdentifierStart(state)) {
        state.lastStringValue += codePointToString2(state.lastIntValue);
        while (this.regexp_eatRegExpIdentifierPart(state)) {
          state.lastStringValue += codePointToString2(state.lastIntValue);
        }
        return true;
      }
      return false;
    };
    pp$12.regexp_eatRegExpIdentifierStart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch = state.current(forceU);
      state.advance(forceU);
      if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierStart2(ch)) {
        state.lastIntValue = ch;
        return true;
      }
      state.pos = start;
      return false;
    };
    pp$12.regexp_eatRegExpIdentifierPart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch = state.current(forceU);
      state.advance(forceU);
      if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierPart2(ch)) {
        state.lastIntValue = ch;
        return true;
      }
      state.pos = start;
      return false;
    };
    pp$12.regexp_eatAtomEscape = function(state) {
      if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
        return true;
      }
      if (state.switchU) {
        if (state.current() === 99) {
          state.raise("Invalid unicode escape");
        }
        state.raise("Invalid escape");
      }
      return false;
    };
    pp$12.regexp_eatBackReference = function(state) {
      var start = state.pos;
      if (this.regexp_eatDecimalEscape(state)) {
        var n2 = state.lastIntValue;
        if (state.switchU) {
          if (n2 > state.maxBackReference) {
            state.maxBackReference = n2;
          }
          return true;
        }
        if (n2 <= state.numCapturingParens) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$12.regexp_eatKGroupName = function(state) {
      if (state.eat(
        107
        /* k */
      )) {
        if (this.regexp_eatGroupName(state)) {
          state.backReferenceNames.push(state.lastStringValue);
          return true;
        }
        state.raise("Invalid named reference");
      }
      return false;
    };
    pp$12.regexp_eatCharacterEscape = function(state) {
      return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
    };
    pp$12.regexp_eatCControlLetter = function(state) {
      var start = state.pos;
      if (state.eat(
        99
        /* c */
      )) {
        if (this.regexp_eatControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$12.regexp_eatZero = function(state) {
      if (state.current() === 48 && !isDecimalDigit2(state.lookahead())) {
        state.lastIntValue = 0;
        state.advance();
        return true;
      }
      return false;
    };
    pp$12.regexp_eatControlEscape = function(state) {
      var ch = state.current();
      if (ch === 116) {
        state.lastIntValue = 9;
        state.advance();
        return true;
      }
      if (ch === 110) {
        state.lastIntValue = 10;
        state.advance();
        return true;
      }
      if (ch === 118) {
        state.lastIntValue = 11;
        state.advance();
        return true;
      }
      if (ch === 102) {
        state.lastIntValue = 12;
        state.advance();
        return true;
      }
      if (ch === 114) {
        state.lastIntValue = 13;
        state.advance();
        return true;
      }
      return false;
    };
    pp$12.regexp_eatControlLetter = function(state) {
      var ch = state.current();
      if (isControlLetter2(ch)) {
        state.lastIntValue = ch % 32;
        state.advance();
        return true;
      }
      return false;
    };
    pp$12.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
      if (forceU === void 0)
        forceU = false;
      var start = state.pos;
      var switchU = forceU || state.switchU;
      if (state.eat(
        117
        /* u */
      )) {
        if (this.regexp_eatFixedHexDigits(state, 4)) {
          var lead = state.lastIntValue;
          if (switchU && lead >= 55296 && lead <= 56319) {
            var leadSurrogateEnd = state.pos;
            if (state.eat(
              92
              /* \ */
            ) && state.eat(
              117
              /* u */
            ) && this.regexp_eatFixedHexDigits(state, 4)) {
              var trail = state.lastIntValue;
              if (trail >= 56320 && trail <= 57343) {
                state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                return true;
              }
            }
            state.pos = leadSurrogateEnd;
            state.lastIntValue = lead;
          }
          return true;
        }
        if (switchU && state.eat(
          123
          /* { */
        ) && this.regexp_eatHexDigits(state) && state.eat(
          125
          /* } */
        ) && isValidUnicode2(state.lastIntValue)) {
          return true;
        }
        if (switchU) {
          state.raise("Invalid unicode escape");
        }
        state.pos = start;
      }
      return false;
    };
    pp$12.regexp_eatIdentityEscape = function(state) {
      if (state.switchU) {
        if (this.regexp_eatSyntaxCharacter(state)) {
          return true;
        }
        if (state.eat(
          47
          /* / */
        )) {
          state.lastIntValue = 47;
          return true;
        }
        return false;
      }
      var ch = state.current();
      if (ch !== 99 && (!state.switchN || ch !== 107)) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$12.regexp_eatDecimalEscape = function(state) {
      state.lastIntValue = 0;
      var ch = state.current();
      if (ch >= 49 && ch <= 57) {
        do {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        } while ((ch = state.current()) >= 48 && ch <= 57);
        return true;
      }
      return false;
    };
    pp$12.regexp_eatCharacterClassEscape = function(state) {
      var ch = state.current();
      if (isCharacterClassEscape2(ch)) {
        state.lastIntValue = -1;
        state.advance();
        return true;
      }
      if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
        state.lastIntValue = -1;
        state.advance();
        if (state.eat(
          123
          /* { */
        ) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(
          125
          /* } */
        )) {
          return true;
        }
        state.raise("Invalid property name");
      }
      return false;
    };
    pp$12.regexp_eatUnicodePropertyValueExpression = function(state) {
      var start = state.pos;
      if (this.regexp_eatUnicodePropertyName(state) && state.eat(
        61
        /* = */
      )) {
        var name2 = state.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(state)) {
          var value2 = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameAndValue(state, name2, value2);
          return true;
        }
      }
      state.pos = start;
      if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
        var nameOrValue = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        return true;
      }
      return false;
    };
    pp$12.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value2) {
      if (!hasOwn2(state.unicodeProperties.nonBinary, name2)) {
        state.raise("Invalid property name");
      }
      if (!state.unicodeProperties.nonBinary[name2].test(value2)) {
        state.raise("Invalid property value");
      }
    };
    pp$12.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
      if (!state.unicodeProperties.binary.test(nameOrValue)) {
        state.raise("Invalid property name");
      }
    };
    pp$12.regexp_eatUnicodePropertyName = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyNameCharacter2(ch = state.current())) {
        state.lastStringValue += codePointToString2(ch);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    pp$12.regexp_eatUnicodePropertyValue = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyValueCharacter2(ch = state.current())) {
        state.lastStringValue += codePointToString2(ch);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    pp$12.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
      return this.regexp_eatUnicodePropertyValue(state);
    };
    pp$12.regexp_eatCharacterClass = function(state) {
      if (state.eat(
        91
        /* [ */
      )) {
        state.eat(
          94
          /* ^ */
        );
        this.regexp_classRanges(state);
        if (state.eat(
          93
          /* ] */
        )) {
          return true;
        }
        state.raise("Unterminated character class");
      }
      return false;
    };
    pp$12.regexp_classRanges = function(state) {
      while (this.regexp_eatClassAtom(state)) {
        var left = state.lastIntValue;
        if (state.eat(
          45
          /* - */
        ) && this.regexp_eatClassAtom(state)) {
          var right = state.lastIntValue;
          if (state.switchU && (left === -1 || right === -1)) {
            state.raise("Invalid character class");
          }
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
        }
      }
    };
    pp$12.regexp_eatClassAtom = function(state) {
      var start = state.pos;
      if (state.eat(
        92
        /* \ */
      )) {
        if (this.regexp_eatClassEscape(state)) {
          return true;
        }
        if (state.switchU) {
          var ch$1 = state.current();
          if (ch$1 === 99 || isOctalDigit2(ch$1)) {
            state.raise("Invalid class escape");
          }
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      var ch = state.current();
      if (ch !== 93) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$12.regexp_eatClassEscape = function(state) {
      var start = state.pos;
      if (state.eat(
        98
        /* b */
      )) {
        state.lastIntValue = 8;
        return true;
      }
      if (state.switchU && state.eat(
        45
        /* - */
      )) {
        state.lastIntValue = 45;
        return true;
      }
      if (!state.switchU && state.eat(
        99
        /* c */
      )) {
        if (this.regexp_eatClassControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
    };
    pp$12.regexp_eatClassControlLetter = function(state) {
      var ch = state.current();
      if (isDecimalDigit2(ch) || ch === 95) {
        state.lastIntValue = ch % 32;
        state.advance();
        return true;
      }
      return false;
    };
    pp$12.regexp_eatHexEscapeSequence = function(state) {
      var start = state.pos;
      if (state.eat(
        120
        /* x */
      )) {
        if (this.regexp_eatFixedHexDigits(state, 2)) {
          return true;
        }
        if (state.switchU) {
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return false;
    };
    pp$12.regexp_eatDecimalDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isDecimalDigit2(ch = state.current())) {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
        state.advance();
      }
      return state.pos !== start;
    };
    pp$12.regexp_eatHexDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isHexDigit2(ch = state.current())) {
        state.lastIntValue = 16 * state.lastIntValue + hexToInt2(ch);
        state.advance();
      }
      return state.pos !== start;
    };
    pp$12.regexp_eatLegacyOctalEscapeSequence = function(state) {
      if (this.regexp_eatOctalDigit(state)) {
        var n1 = state.lastIntValue;
        if (this.regexp_eatOctalDigit(state)) {
          var n2 = state.lastIntValue;
          if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
            state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
          } else {
            state.lastIntValue = n1 * 8 + n2;
          }
        } else {
          state.lastIntValue = n1;
        }
        return true;
      }
      return false;
    };
    pp$12.regexp_eatOctalDigit = function(state) {
      var ch = state.current();
      if (isOctalDigit2(ch)) {
        state.lastIntValue = ch - 48;
        state.advance();
        return true;
      }
      state.lastIntValue = 0;
      return false;
    };
    pp$12.regexp_eatFixedHexDigits = function(state, length) {
      var start = state.pos;
      state.lastIntValue = 0;
      for (var i = 0; i < length; ++i) {
        var ch = state.current();
        if (!isHexDigit2(ch)) {
          state.pos = start;
          return false;
        }
        state.lastIntValue = 16 * state.lastIntValue + hexToInt2(ch);
        state.advance();
      }
      return true;
    };
    Token3 = function Token4(p) {
      this.type = p.type;
      this.value = p.value;
      this.start = p.start;
      this.end = p.end;
      if (p.options.locations) {
        this.loc = new SourceLocation3(p, p.startLoc, p.endLoc);
      }
      if (p.options.ranges) {
        this.range = [p.start, p.end];
      }
    };
    pp2 = Parser$1.prototype;
    pp2.next = function(ignoreEscapeSequenceInKeyword) {
      if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
      }
      if (this.options.onToken) {
        this.options.onToken(new Token3(this));
      }
      this.lastTokEnd = this.end;
      this.lastTokStart = this.start;
      this.lastTokEndLoc = this.endLoc;
      this.lastTokStartLoc = this.startLoc;
      this.nextToken();
    };
    pp2.getToken = function() {
      this.next();
      return new Token3(this);
    };
    if (typeof Symbol !== "undefined") {
      pp2[Symbol.iterator] = function() {
        var this$1$1 = this;
        return {
          next: function() {
            var token = this$1$1.getToken();
            return {
              done: token.type === types$12.eof,
              value: token
            };
          }
        };
      };
    }
    pp2.nextToken = function() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) {
        this.skipSpace();
      }
      this.start = this.pos;
      if (this.options.locations) {
        this.startLoc = this.curPosition();
      }
      if (this.pos >= this.input.length) {
        return this.finishToken(types$12.eof);
      }
      if (curContext.override) {
        return curContext.override(this);
      } else {
        this.readToken(this.fullCharCodeAtPos());
      }
    };
    pp2.readToken = function(code) {
      if (isIdentifierStart2(code, this.options.ecmaVersion >= 6) || code === 92) {
        return this.readWord();
      }
      return this.getTokenFromCode(code);
    };
    pp2.fullCharCodeAtPos = function() {
      var code = this.input.charCodeAt(this.pos);
      if (code <= 55295 || code >= 56320) {
        return code;
      }
      var next = this.input.charCodeAt(this.pos + 1);
      return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
    };
    pp2.skipBlockComment = function() {
      var startLoc = this.options.onComment && this.curPosition();
      var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
      if (end === -1) {
        this.raise(this.pos - 2, "Unterminated comment");
      }
      this.pos = end + 2;
      if (this.options.locations) {
        for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak2(this.input, pos, this.pos)) > -1; ) {
          ++this.curLine;
          pos = this.lineStart = nextBreak;
        }
      }
      if (this.options.onComment) {
        this.options.onComment(
          true,
          this.input.slice(start + 2, end),
          start,
          this.pos,
          startLoc,
          this.curPosition()
        );
      }
    };
    pp2.skipLineComment = function(startSkip) {
      var start = this.pos;
      var startLoc = this.options.onComment && this.curPosition();
      var ch = this.input.charCodeAt(this.pos += startSkip);
      while (this.pos < this.input.length && !isNewLine2(ch)) {
        ch = this.input.charCodeAt(++this.pos);
      }
      if (this.options.onComment) {
        this.options.onComment(
          false,
          this.input.slice(start + startSkip, this.pos),
          start,
          this.pos,
          startLoc,
          this.curPosition()
        );
      }
    };
    pp2.skipSpace = function() {
      loop:
        while (this.pos < this.input.length) {
          var ch = this.input.charCodeAt(this.pos);
          switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace2.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
          }
        }
    };
    pp2.finishToken = function(type, val) {
      this.end = this.pos;
      if (this.options.locations) {
        this.endLoc = this.curPosition();
      }
      var prevType = this.type;
      this.type = type;
      this.value = val;
      this.updateContext(prevType);
    };
    pp2.readToken_dot = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next >= 48 && next <= 57) {
        return this.readNumber(true);
      }
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
        this.pos += 3;
        return this.finishToken(types$12.ellipsis);
      } else {
        ++this.pos;
        return this.finishToken(types$12.dot);
      }
    };
    pp2.readToken_slash = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed) {
        ++this.pos;
        return this.readRegexp();
      }
      if (next === 61) {
        return this.finishOp(types$12.assign, 2);
      }
      return this.finishOp(types$12.slash, 1);
    };
    pp2.readToken_mult_modulo_exp = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      var tokentype = code === 42 ? types$12.star : types$12.modulo;
      if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
        ++size;
        tokentype = types$12.starstar;
        next = this.input.charCodeAt(this.pos + 2);
      }
      if (next === 61) {
        return this.finishOp(types$12.assign, size + 1);
      }
      return this.finishOp(tokentype, size);
    };
    pp2.readToken_pipe_amp = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (this.options.ecmaVersion >= 12) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 === 61) {
            return this.finishOp(types$12.assign, 3);
          }
        }
        return this.finishOp(code === 124 ? types$12.logicalOR : types$12.logicalAND, 2);
      }
      if (next === 61) {
        return this.finishOp(types$12.assign, 2);
      }
      return this.finishOp(code === 124 ? types$12.bitwiseOR : types$12.bitwiseAND, 1);
    };
    pp2.readToken_caret = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) {
        return this.finishOp(types$12.assign, 2);
      }
      return this.finishOp(types$12.bitwiseXOR, 1);
    };
    pp2.readToken_plus_min = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak2.test(this.input.slice(this.lastTokEnd, this.pos)))) {
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken();
        }
        return this.finishOp(types$12.incDec, 2);
      }
      if (next === 61) {
        return this.finishOp(types$12.assign, 2);
      }
      return this.finishOp(types$12.plusMin, 1);
    };
    pp2.readToken_lt_gt = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) {
          return this.finishOp(types$12.assign, size + 1);
        }
        return this.finishOp(types$12.bitShift, size);
      }
      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken();
      }
      if (next === 61) {
        size = 2;
      }
      return this.finishOp(types$12.relational, size);
    };
    pp2.readToken_eq_excl = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) {
        return this.finishOp(types$12.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
      }
      if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
        this.pos += 2;
        return this.finishToken(types$12.arrow);
      }
      return this.finishOp(code === 61 ? types$12.eq : types$12.prefix, 1);
    };
    pp2.readToken_question = function() {
      var ecmaVersion = this.options.ecmaVersion;
      if (ecmaVersion >= 11) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 46) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 < 48 || next2 > 57) {
            return this.finishOp(types$12.questionDot, 2);
          }
        }
        if (next === 63) {
          if (ecmaVersion >= 12) {
            var next2$1 = this.input.charCodeAt(this.pos + 2);
            if (next2$1 === 61) {
              return this.finishOp(types$12.assign, 3);
            }
          }
          return this.finishOp(types$12.coalesce, 2);
        }
      }
      return this.finishOp(types$12.question, 1);
    };
    pp2.readToken_numberSign = function() {
      var ecmaVersion = this.options.ecmaVersion;
      var code = 35;
      if (ecmaVersion >= 13) {
        ++this.pos;
        code = this.fullCharCodeAtPos();
        if (isIdentifierStart2(code, true) || code === 92) {
          return this.finishToken(types$12.privateId, this.readWord1());
        }
      }
      this.raise(this.pos, "Unexpected character '" + codePointToString2(code) + "'");
    };
    pp2.getTokenFromCode = function(code) {
      switch (code) {
        case 46:
          return this.readToken_dot();
        case 40:
          ++this.pos;
          return this.finishToken(types$12.parenL);
        case 41:
          ++this.pos;
          return this.finishToken(types$12.parenR);
        case 59:
          ++this.pos;
          return this.finishToken(types$12.semi);
        case 44:
          ++this.pos;
          return this.finishToken(types$12.comma);
        case 91:
          ++this.pos;
          return this.finishToken(types$12.bracketL);
        case 93:
          ++this.pos;
          return this.finishToken(types$12.bracketR);
        case 123:
          ++this.pos;
          return this.finishToken(types$12.braceL);
        case 125:
          ++this.pos;
          return this.finishToken(types$12.braceR);
        case 58:
          ++this.pos;
          return this.finishToken(types$12.colon);
        case 96:
          if (this.options.ecmaVersion < 6) {
            break;
          }
          ++this.pos;
          return this.finishToken(types$12.backQuote);
        case 48:
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 120 || next === 88) {
            return this.readRadixNumber(16);
          }
          if (this.options.ecmaVersion >= 6) {
            if (next === 111 || next === 79) {
              return this.readRadixNumber(8);
            }
            if (next === 98 || next === 66) {
              return this.readRadixNumber(2);
            }
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(false);
        case 34:
        case 39:
          return this.readString(code);
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(code);
        case 124:
        case 38:
          return this.readToken_pipe_amp(code);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(code);
        case 60:
        case 62:
          return this.readToken_lt_gt(code);
        case 61:
        case 33:
          return this.readToken_eq_excl(code);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(types$12.prefix, 1);
        case 35:
          return this.readToken_numberSign();
      }
      this.raise(this.pos, "Unexpected character '" + codePointToString2(code) + "'");
    };
    pp2.finishOp = function(type, size) {
      var str = this.input.slice(this.pos, this.pos + size);
      this.pos += size;
      return this.finishToken(type, str);
    };
    pp2.readRegexp = function() {
      var escaped2, inClass, start = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(start, "Unterminated regular expression");
        }
        var ch = this.input.charAt(this.pos);
        if (lineBreak2.test(ch)) {
          this.raise(start, "Unterminated regular expression");
        }
        if (!escaped2) {
          if (ch === "[") {
            inClass = true;
          } else if (ch === "]" && inClass) {
            inClass = false;
          } else if (ch === "/" && !inClass) {
            break;
          }
          escaped2 = ch === "\\";
        } else {
          escaped2 = false;
        }
        ++this.pos;
      }
      var pattern2 = this.input.slice(start, this.pos);
      ++this.pos;
      var flagsStart = this.pos;
      var flags = this.readWord1();
      if (this.containsEsc) {
        this.unexpected(flagsStart);
      }
      var state = this.regexpState || (this.regexpState = new RegExpValidationState3(this));
      state.reset(start, pattern2, flags);
      this.validateRegExpFlags(state);
      this.validateRegExpPattern(state);
      var value2 = null;
      try {
        value2 = new RegExp(pattern2, flags);
      } catch (e) {
      }
      return this.finishToken(types$12.regexp, { pattern: pattern2, flags, value: value2 });
    };
    pp2.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
      var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
      var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
      var start = this.pos, total = 0, lastCode = 0;
      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
        var code = this.input.charCodeAt(this.pos), val = void 0;
        if (allowSeparators && code === 95) {
          if (isLegacyOctalNumericLiteral) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
          }
          if (lastCode === 95) {
            this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
          }
          if (i === 0) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
          }
          lastCode = code;
          continue;
        }
        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (code >= 48 && code <= 57) {
          val = code - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          break;
        }
        lastCode = code;
        total = total * radix + val;
      }
      if (allowSeparators && lastCode === 95) {
        this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
      }
      if (this.pos === start || len != null && this.pos - start !== len) {
        return null;
      }
      return total;
    };
    pp2.readRadixNumber = function(radix) {
      var start = this.pos;
      this.pos += 2;
      var val = this.readInt(radix);
      if (val == null) {
        this.raise(this.start + 2, "Expected number in radix " + radix);
      }
      if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
        val = stringToBigInt2(this.input.slice(start, this.pos));
        ++this.pos;
      } else if (isIdentifierStart2(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      return this.finishToken(types$12.num, val);
    };
    pp2.readNumber = function(startsWithDot) {
      var start = this.pos;
      if (!startsWithDot && this.readInt(10, void 0, true) === null) {
        this.raise(start, "Invalid number");
      }
      var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (octal && this.strict) {
        this.raise(start, "Invalid number");
      }
      var next = this.input.charCodeAt(this.pos);
      if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
        var val$1 = stringToBigInt2(this.input.slice(start, this.pos));
        ++this.pos;
        if (isIdentifierStart2(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$12.num, val$1);
      }
      if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
        octal = false;
      }
      if (next === 46 && !octal) {
        ++this.pos;
        this.readInt(10);
        next = this.input.charCodeAt(this.pos);
      }
      if ((next === 69 || next === 101) && !octal) {
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) {
          ++this.pos;
        }
        if (this.readInt(10) === null) {
          this.raise(start, "Invalid number");
        }
      }
      if (isIdentifierStart2(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      var val = stringToNumber2(this.input.slice(start, this.pos), octal);
      return this.finishToken(types$12.num, val);
    };
    pp2.readCodePoint = function() {
      var ch = this.input.charCodeAt(this.pos), code;
      if (ch === 123) {
        if (this.options.ecmaVersion < 6) {
          this.unexpected();
        }
        var codePos = ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 1114111) {
          this.invalidStringToken(codePos, "Code point out of bounds");
        }
      } else {
        code = this.readHexChar(4);
      }
      return code;
    };
    pp2.readString = function(quote) {
      var out = "", chunkStart = ++this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated string constant");
        }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === quote) {
          break;
        }
        if (ch === 92) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.pos;
        } else if (ch === 8232 || ch === 8233) {
          if (this.options.ecmaVersion < 10) {
            this.raise(this.start, "Unterminated string constant");
          }
          ++this.pos;
          if (this.options.locations) {
            this.curLine++;
            this.lineStart = this.pos;
          }
        } else {
          if (isNewLine2(ch)) {
            this.raise(this.start, "Unterminated string constant");
          }
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(types$12.string, out);
    };
    INVALID_TEMPLATE_ESCAPE_ERROR2 = {};
    pp2.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (err) {
        if (err === INVALID_TEMPLATE_ESCAPE_ERROR2) {
          this.readInvalidTemplateToken();
        } else {
          throw err;
        }
      }
      this.inTemplateElement = false;
    };
    pp2.invalidStringToken = function(position, message) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
        throw INVALID_TEMPLATE_ESCAPE_ERROR2;
      } else {
        this.raise(position, message);
      }
    };
    pp2.readTmplToken = function() {
      var out = "", chunkStart = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated template");
        }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
          if (this.pos === this.start && (this.type === types$12.template || this.type === types$12.invalidTemplate)) {
            if (ch === 36) {
              this.pos += 2;
              return this.finishToken(types$12.dollarBraceL);
            } else {
              ++this.pos;
              return this.finishToken(types$12.backQuote);
            }
          }
          out += this.input.slice(chunkStart, this.pos);
          return this.finishToken(types$12.template, out);
        }
        if (ch === 92) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(true);
          chunkStart = this.pos;
        } else if (isNewLine2(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          ++this.pos;
          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) {
                ++this.pos;
              }
            case 10:
              out += "\n";
              break;
            default:
              out += String.fromCharCode(ch);
              break;
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    };
    pp2.readInvalidTemplateToken = function() {
      for (; this.pos < this.input.length; this.pos++) {
        switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break;
          case "$":
            if (this.input[this.pos + 1] !== "{") {
              break;
            }
          case "`":
            return this.finishToken(types$12.invalidTemplate, this.input.slice(this.start, this.pos));
        }
      }
      this.raise(this.start, "Unterminated template");
    };
    pp2.readEscapedChar = function(inTemplate) {
      var ch = this.input.charCodeAt(++this.pos);
      ++this.pos;
      switch (ch) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        case 117:
          return codePointToString2(this.readCodePoint());
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          if (this.options.locations) {
            this.lineStart = this.pos;
            ++this.curLine;
          }
          return "";
        case 56:
        case 57:
          if (this.strict) {
            this.invalidStringToken(
              this.pos - 1,
              "Invalid escape sequence"
            );
          }
          if (inTemplate) {
            var codePos = this.pos - 1;
            this.invalidStringToken(
              codePos,
              "Invalid escape sequence in template string"
            );
          }
        default:
          if (ch >= 48 && ch <= 55) {
            var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            this.pos += octalStr.length - 1;
            ch = this.input.charCodeAt(this.pos);
            if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
              this.invalidStringToken(
                this.pos - 1 - octalStr.length,
                inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
              );
            }
            return String.fromCharCode(octal);
          }
          if (isNewLine2(ch)) {
            return "";
          }
          return String.fromCharCode(ch);
      }
    };
    pp2.readHexChar = function(len) {
      var codePos = this.pos;
      var n2 = this.readInt(16, len);
      if (n2 === null) {
        this.invalidStringToken(codePos, "Bad character escape sequence");
      }
      return n2;
    };
    pp2.readWord1 = function() {
      this.containsEsc = false;
      var word = "", first2 = true, chunkStart = this.pos;
      var astral = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var ch = this.fullCharCodeAtPos();
        if (isIdentifierChar2(ch, astral)) {
          this.pos += ch <= 65535 ? 1 : 2;
        } else if (ch === 92) {
          this.containsEsc = true;
          word += this.input.slice(chunkStart, this.pos);
          var escStart = this.pos;
          if (this.input.charCodeAt(++this.pos) !== 117) {
            this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
          }
          ++this.pos;
          var esc = this.readCodePoint();
          if (!(first2 ? isIdentifierStart2 : isIdentifierChar2)(esc, astral)) {
            this.invalidStringToken(escStart, "Invalid Unicode escape");
          }
          word += codePointToString2(esc);
          chunkStart = this.pos;
        } else {
          break;
        }
        first2 = false;
      }
      return word + this.input.slice(chunkStart, this.pos);
    };
    pp2.readWord = function() {
      var word = this.readWord1();
      var type = types$12.name;
      if (this.keywords.test(word)) {
        type = keywords$2[word];
      }
      return this.finishToken(type, word);
    };
    version$2 = "8.8.2";
    Parser$1.acorn = {
      Parser: Parser$1,
      version: version$2,
      defaultOptions: defaultOptions2,
      Position: Position3,
      SourceLocation: SourceLocation3,
      getLineInfo: getLineInfo2,
      Node: Node3,
      TokenType: TokenType3,
      tokTypes: types$12,
      keywordTypes: keywords$2,
      TokContext: TokContext3,
      tokContexts: types$2,
      isIdentifierChar: isIdentifierChar2,
      isIdentifierStart: isIdentifierStart2,
      Token: Token3,
      isNewLine: isNewLine2,
      lineBreak: lineBreak2,
      lineBreakG: lineBreakG2,
      nonASCIIwhitespace: nonASCIIwhitespace2
    };
    isWindows$3 = import_node_process3.default.platform === "win32";
    own$1 = {}.hasOwnProperty;
    messages = /* @__PURE__ */ new Map();
    nodeInternalPrefix = "__node_internal_";
    createError(
      "ERR_INVALID_MODULE_SPECIFIER",
      /**
       * @param {string} request
       * @param {string} reason
       * @param {string} [base]
       */
      (request, reason, base3 = void 0) => {
        return `Invalid module "${request}" ${reason}${base3 ? ` imported from ${base3}` : ""}`;
      },
      TypeError
    );
    createError(
      "ERR_INVALID_PACKAGE_CONFIG",
      /**
       * @param {string} path
       * @param {string} [base]
       * @param {string} [message]
       */
      (path4, base3, message) => {
        return `Invalid package config ${path4}${base3 ? ` while importing ${base3}` : ""}${message ? `. ${message}` : ""}`;
      },
      Error
    );
    createError(
      "ERR_INVALID_PACKAGE_TARGET",
      /**
       * @param {string} pkgPath
       * @param {string} key
       * @param {unknown} target
       * @param {boolean} [isImport=false]
       * @param {string} [base]
       */
      (pkgPath, key, target, isImport = false, base3 = void 0) => {
        const relError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
        if (key === ".") {
          (0, import_node_assert.default)(isImport === false);
          return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${base3 ? ` imported from ${base3}` : ""}${relError ? '; targets must start with "./"' : ""}`;
        }
        return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
          target
        )} defined for '${key}' in the package config ${pkgPath}package.json${base3 ? ` imported from ${base3}` : ""}${relError ? '; targets must start with "./"' : ""}`;
      },
      Error
    );
    createError(
      "ERR_MODULE_NOT_FOUND",
      /**
       * @param {string} path
       * @param {string} base
       * @param {string} [type]
       */
      (path4, base3, type = "package") => {
        return `Cannot find ${type} '${path4}' imported from ${base3}`;
      },
      Error
    );
    createError(
      "ERR_NETWORK_IMPORT_DISALLOWED",
      "import of '%s' by %s is not supported: %s",
      Error
    );
    createError(
      "ERR_PACKAGE_IMPORT_NOT_DEFINED",
      /**
       * @param {string} specifier
       * @param {string} packagePath
       * @param {string} base
       */
      (specifier, packagePath, base3) => {
        return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base3}`;
      },
      TypeError
    );
    createError(
      "ERR_PACKAGE_PATH_NOT_EXPORTED",
      /**
       * @param {string} pkgPath
       * @param {string} subpath
       * @param {string} [base]
       */
      (pkgPath, subpath, base3 = void 0) => {
        if (subpath === ".")
          return `No "exports" main defined in ${pkgPath}package.json${base3 ? ` imported from ${base3}` : ""}`;
        return `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base3 ? ` imported from ${base3}` : ""}`;
      },
      Error
    );
    createError(
      "ERR_UNSUPPORTED_DIR_IMPORT",
      "Directory import '%s' is not supported resolving ES modules imported from %s",
      Error
    );
    createError(
      "ERR_UNKNOWN_FILE_EXTENSION",
      /**
       * @param {string} ext
       * @param {string} path
       */
      (ext2, path4) => {
        return `Unknown file extension "${ext2}" for ${path4}`;
      },
      TypeError
    );
    createError(
      "ERR_INVALID_ARG_VALUE",
      /**
       * @param {string} name
       * @param {unknown} value
       * @param {string} [reason='is invalid']
       */
      (name2, value2, reason = "is invalid") => {
        let inspected = (0, import_node_util.inspect)(value2);
        if (inspected.length > 128) {
          inspected = `${inspected.slice(0, 128)}...`;
        }
        const type = name2.includes(".") ? "property" : "argument";
        return `The ${type} '${name2}' ${reason}. Received ${inspected}`;
      },
      TypeError
      // Note: extra classes have been shaken out.
      // , RangeError
    );
    createError(
      "ERR_UNSUPPORTED_ESM_URL_SCHEME",
      /**
       * @param {URL} url
       * @param {Array<string>} supported
       */
      (url2, supported) => {
        let message = `Only URLs with a scheme in: ${formatList(
          supported
        )} are supported by the default ESM loader`;
        if (isWindows$3 && url2.protocol.length === 2) {
          message += ". On Windows, absolute paths must be valid file:// URLs";
        }
        message += `. Received protocol '${url2.protocol}'`;
        return message;
      },
      Error
    );
    captureLargerStackTrace = hideStackFrames(
      /**
       * @param {Error} error
       * @returns {Error}
       */
      // @ts-expect-error: fine
      function(error2) {
        const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
        if (stackTraceLimitIsWritable) {
          userStackTraceLimit = Error.stackTraceLimit;
          Error.stackTraceLimit = Number.POSITIVE_INFINITY;
        }
        Error.captureStackTrace(error2);
        if (stackTraceLimitIsWritable)
          Error.stackTraceLimit = userStackTraceLimit;
        return error2;
      }
    );
    (0, import_node_url2.pathToFileURL)(process.cwd());
    isDebug$5 = process.env.DEBUG;
    debug$d = createDebugger("vite:resolve-details", {
      onlyWhenFocused: true
    });
    normalizedClientEntry$1 = normalizePath$3(CLIENT_ENTRY);
    normalizedEnvEntry$1 = normalizePath$3(ENV_ENTRY);
    isDebug$4 = process.env.DEBUG;
    debug$c = createDebugger("vite:resolve-details", {
      onlyWhenFocused: true
    });
    externalTypes = [
      "css",
      // supported pre-processor types
      "less",
      "sass",
      "scss",
      "styl",
      "stylus",
      "pcss",
      "postcss",
      // wasm
      "wasm",
      // known SFC types
      "vue",
      "svelte",
      "marko",
      "astro",
      "imba",
      // JSX/TSX may be configured to be compiled differently from how esbuild
      // handles it by default, so exclude them as well
      "jsx",
      "tsx",
      ...KNOWN_ASSET_TYPES
    ];
    tasks = {};
    utils$g = {};
    array$1 = {};
    Object.defineProperty(array$1, "__esModule", { value: true });
    array$1.splitWhen = array$1.flatten = void 0;
    array$1.flatten = flatten$1;
    array$1.splitWhen = splitWhen;
    errno$1 = {};
    Object.defineProperty(errno$1, "__esModule", { value: true });
    errno$1.isEnoentCodeError = void 0;
    errno$1.isEnoentCodeError = isEnoentCodeError;
    fs$h = {};
    Object.defineProperty(fs$h, "__esModule", { value: true });
    fs$h.createDirentFromStats = void 0;
    DirentFromStats$1 = class DirentFromStats {
      constructor(name2, stats) {
        this.name = name2;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    fs$h.createDirentFromStats = createDirentFromStats$1;
    path$h = {};
    Object.defineProperty(path$h, "__esModule", { value: true });
    path$h.removeLeadingDotSegment = path$h.escape = path$h.makeAbsolute = path$h.unixify = void 0;
    path$g = import_path2.default;
    LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
    path$h.unixify = unixify;
    path$h.makeAbsolute = makeAbsolute;
    path$h.escape = escape$2;
    path$h.removeLeadingDotSegment = removeLeadingDotSegment;
    pattern$1 = {};
    isExtglob$1 = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
    isExtglob2 = isExtglob$1;
    chars3 = { "{": "}", "(": ")", "[": "]" };
    strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open2 = str[index + 1];
          index += 2;
          var close2 = chars3[open2];
          if (close2) {
            var n2 = str.indexOf(close2, index);
            if (n2 !== -1) {
              index = n2 + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open2 = str[index + 1];
          index += 2;
          var close2 = chars3[open2];
          if (close2) {
            var n2 = str.indexOf(close2, index);
            if (n2 !== -1) {
              index = n2 + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    isGlob$2 = function isGlob(str, options2) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob2(str)) {
        return true;
      }
      var check = strictCheck;
      if (options2 && options2.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
    isGlob$1 = isGlob$2;
    pathPosixDirname = import_path2.default.posix.dirname;
    isWin32 = import_os.default.platform() === "win32";
    slash = "/";
    backslash = /\\/g;
    enclosure = /[\{\[].*[\}\]]$/;
    globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    globParent$2 = function globParent(str, opts) {
      var options2 = Object.assign({ flipBackslashes: true }, opts);
      if (options2.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob$1(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
    utils$f = {};
    (function(exports2) {
      exports2.isInteger = (num) => {
        if (typeof num === "number") {
          return Number.isInteger(num);
        }
        if (typeof num === "string" && num.trim() !== "") {
          return Number.isInteger(Number(num));
        }
        return false;
      };
      exports2.find = (node2, type) => node2.nodes.find((node3) => node3.type === type);
      exports2.exceedsLimit = (min2, max, step = 1, limit) => {
        if (limit === false)
          return false;
        if (!exports2.isInteger(min2) || !exports2.isInteger(max))
          return false;
        return (Number(max) - Number(min2)) / Number(step) >= limit;
      };
      exports2.escapeNode = (block, n2 = 0, type) => {
        let node2 = block.nodes[n2];
        if (!node2)
          return;
        if (type && node2.type === type || node2.type === "open" || node2.type === "close") {
          if (node2.escaped !== true) {
            node2.value = "\\" + node2.value;
            node2.escaped = true;
          }
        }
      };
      exports2.encloseBrace = (node2) => {
        if (node2.type !== "brace")
          return false;
        if (node2.commas >> 0 + node2.ranges >> 0 === 0) {
          node2.invalid = true;
          return true;
        }
        return false;
      };
      exports2.isInvalidBrace = (block) => {
        if (block.type !== "brace")
          return false;
        if (block.invalid === true || block.dollar)
          return true;
        if (block.commas >> 0 + block.ranges >> 0 === 0) {
          block.invalid = true;
          return true;
        }
        if (block.open !== true || block.close !== true) {
          block.invalid = true;
          return true;
        }
        return false;
      };
      exports2.isOpenOrClose = (node2) => {
        if (node2.type === "open" || node2.type === "close") {
          return true;
        }
        return node2.open === true || node2.close === true;
      };
      exports2.reduce = (nodes) => nodes.reduce((acc, node2) => {
        if (node2.type === "text")
          acc.push(node2.value);
        if (node2.type === "range")
          node2.type = "text";
        return acc;
      }, []);
      exports2.flatten = (...args) => {
        const result = [];
        const flat = (arr) => {
          for (let i = 0; i < arr.length; i++) {
            let ele = arr[i];
            Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);
          }
          return result;
        };
        flat(args);
        return result;
      };
    })(utils$f);
    utils$e = utils$f;
    stringify$7 = (ast, options2 = {}) => {
      let stringify2 = (node2, parent = {}) => {
        let invalidBlock = options2.escapeInvalid && utils$e.isInvalidBrace(parent);
        let invalidNode = node2.invalid === true && options2.escapeInvalid === true;
        let output = "";
        if (node2.value) {
          if ((invalidBlock || invalidNode) && utils$e.isOpenOrClose(node2)) {
            return "\\" + node2.value;
          }
          return node2.value;
        }
        if (node2.value) {
          return node2.value;
        }
        if (node2.nodes) {
          for (let child of node2.nodes) {
            output += stringify2(child);
          }
        }
        return output;
      };
      return stringify2(ast);
    };
    isNumber$2 = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
    isNumber$1 = isNumber$2;
    toRegexRange$1 = (min2, max, options2) => {
      if (isNumber$1(min2) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min2 === max) {
        return String(min2);
      }
      if (isNumber$1(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options2 };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap2 = String(opts.wrap);
      let cacheKey = min2 + ":" + max + "=" + relax + shorthand + capture + wrap2;
      if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange$1.cache[cacheKey].result;
      }
      let a = Math.min(min2, max);
      let b = Math.max(min2, max);
      if (Math.abs(a - b) === 1) {
        let result = min2 + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded2 = hasPadding(min2) || hasPadding(max);
      let state = { min: min2, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded2) {
        state.isPadded = isPadded2;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange$1.cache[cacheKey] = state;
      return state.result;
    };
    toRegexRange$1.cache = {};
    toRegexRange$1.clearCache = () => toRegexRange$1.cache = {};
    toRegexRange_1 = toRegexRange$1;
    util$1 = import_util.default;
    toRegexRange = toRegexRange_1;
    isObject3 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    transform$1 = (toNumber) => {
      return (value2) => toNumber === true ? Number(value2) : String(value2);
    };
    isValidValue = (value2) => {
      return typeof value2 === "number" || typeof value2 === "string" && value2 !== "";
    };
    isNumber = (num) => Number.isInteger(+num);
    zeros = (input) => {
      let value2 = `${input}`;
      let index = -1;
      if (value2[0] === "-")
        value2 = value2.slice(1);
      if (value2 === "0")
        return false;
      while (value2[++index] === "0")
        ;
      return index > 0;
    };
    stringify$6 = (start, end, options2) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options2.stringify === true;
    };
    pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    toSequence = (parts, options2) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options2.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options2.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    toRange = (a, b, isNumbers, options2) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options2 });
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    toRegex = (start, end, options2) => {
      if (Array.isArray(start)) {
        let wrap2 = options2.wrap === true;
        let prefix = options2.capture ? "" : "?:";
        return wrap2 ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options2);
    };
    rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util$1.inspect(...args));
    };
    invalidRange = (start, end, options2) => {
      if (options2.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    invalidStep = (step, options2) => {
      if (options2.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    fillNumbers = (start, end, step = 1, options2 = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options2.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify$6(start, end, options2) === false;
      let format2 = options2.transform || transform$1(toNumber);
      if (options2.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options2);
      }
      let parts = { negatives: [], positives: [] };
      let push2 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options2.toRegex === true && step > 1) {
          push2(a);
        } else {
          range.push(pad(format2(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options2.toRegex === true) {
        return step > 1 ? toSequence(parts, options2) : toRegex(range, null, { wrap: false, ...options2 });
      }
      return range;
    };
    fillLetters = (start, end, step = 1, options2 = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options2);
      }
      let format2 = options2.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min2 = Math.min(a, b);
      let max = Math.max(a, b);
      if (options2.toRegex && step === 1) {
        return toRange(min2, max, false, options2);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format2(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options2.toRegex === true) {
        return toRegex(range, null, { wrap: false, options: options2 });
      }
      return range;
    };
    fill$2 = (start, end, step, options2 = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options2);
      }
      if (typeof step === "function") {
        return fill$2(start, end, 1, { transform: step });
      }
      if (isObject3(step)) {
        return fill$2(start, end, 0, step);
      }
      let opts = { ...options2 };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject3(step))
          return invalidStep(step, opts);
        return fill$2(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    fillRange = fill$2;
    fill$1 = fillRange;
    utils$d = utils$f;
    compile$1 = (ast, options2 = {}) => {
      let walk = (node2, parent = {}) => {
        let invalidBlock = utils$d.isInvalidBrace(parent);
        let invalidNode = node2.invalid === true && options2.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options2.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node2.isOpen === true) {
          return prefix + node2.value;
        }
        if (node2.isClose === true) {
          return prefix + node2.value;
        }
        if (node2.type === "open") {
          return invalid ? prefix + node2.value : "(";
        }
        if (node2.type === "close") {
          return invalid ? prefix + node2.value : ")";
        }
        if (node2.type === "comma") {
          return node2.prev.type === "comma" ? "" : invalid ? node2.value : "|";
        }
        if (node2.value) {
          return node2.value;
        }
        if (node2.nodes && node2.ranges > 0) {
          let args = utils$d.reduce(node2.nodes);
          let range = fill$1(...args, { ...options2, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node2.nodes) {
          for (let child of node2.nodes) {
            output += walk(child, node2);
          }
        }
        return output;
      };
      return walk(ast);
    };
    compile_1 = compile$1;
    fill = fillRange;
    stringify$5 = stringify$7;
    utils$c = utils$f;
    append$1 = (queue2 = "", stash = "", enclose = false) => {
      let result = [];
      queue2 = [].concat(queue2);
      stash = [].concat(stash);
      if (!stash.length)
        return queue2;
      if (!queue2.length) {
        return enclose ? utils$c.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue2) {
        if (Array.isArray(item)) {
          for (let value2 of item) {
            result.push(append$1(value2, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append$1(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils$c.flatten(result);
    };
    expand$2 = (ast, options2 = {}) => {
      let rangeLimit = options2.rangeLimit === void 0 ? 1e3 : options2.rangeLimit;
      let walk = (node2, parent = {}) => {
        node2.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node2.invalid || node2.dollar) {
          q.push(append$1(q.pop(), stringify$5(node2, options2)));
          return;
        }
        if (node2.type === "brace" && node2.invalid !== true && node2.nodes.length === 2) {
          q.push(append$1(q.pop(), ["{}"]));
          return;
        }
        if (node2.nodes && node2.ranges > 0) {
          let args = utils$c.reduce(node2.nodes);
          if (utils$c.exceedsLimit(...args, options2.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options2);
          if (range.length === 0) {
            range = stringify$5(node2, options2);
          }
          q.push(append$1(q.pop(), range));
          node2.nodes = [];
          return;
        }
        let enclose = utils$c.encloseBrace(node2);
        let queue2 = node2.queue;
        let block = node2;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue2 = block.queue;
        }
        for (let i = 0; i < node2.nodes.length; i++) {
          let child = node2.nodes[i];
          if (child.type === "comma" && node2.type === "brace") {
            if (i === 1)
              queue2.push("");
            queue2.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append$1(q.pop(), queue2, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue2.push(append$1(queue2.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node2);
          }
        }
        return queue2;
      };
      return utils$c.flatten(walk(ast));
    };
    expand_1$1 = expand$2;
    constants$3 = {
      MAX_LENGTH: 1024 * 64,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
    stringify$4 = stringify$7;
    ({
      MAX_LENGTH: MAX_LENGTH2,
      CHAR_BACKSLASH,
      CHAR_BACKTICK: (
        /* \ */
        CHAR_BACKTICK
      ),
      CHAR_COMMA: (
        /* ` */
        CHAR_COMMA2
      ),
      CHAR_DOT: (
        /* , */
        CHAR_DOT2
      ),
      CHAR_LEFT_PARENTHESES: (
        /* . */
        CHAR_LEFT_PARENTHESES2
      ),
      CHAR_RIGHT_PARENTHESES: (
        /* ( */
        CHAR_RIGHT_PARENTHESES2
      ),
      CHAR_LEFT_CURLY_BRACE: (
        /* ) */
        CHAR_LEFT_CURLY_BRACE2
      ),
      CHAR_RIGHT_CURLY_BRACE: (
        /* { */
        CHAR_RIGHT_CURLY_BRACE2
      ),
      CHAR_LEFT_SQUARE_BRACKET: (
        /* } */
        CHAR_LEFT_SQUARE_BRACKET2
      ),
      CHAR_RIGHT_SQUARE_BRACKET: (
        /* [ */
        CHAR_RIGHT_SQUARE_BRACKET2
      ),
      CHAR_DOUBLE_QUOTE: (
        /* ] */
        CHAR_DOUBLE_QUOTE
      ),
      CHAR_SINGLE_QUOTE: (
        /* " */
        CHAR_SINGLE_QUOTE
      ),
      CHAR_NO_BREAK_SPACE: (
        /* ' */
        CHAR_NO_BREAK_SPACE
      ),
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = constants$3);
    parse$c = (input, options2 = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options2 || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH2, opts.maxLength) : MAX_LENGTH2;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth3 = 0;
      let value2;
      const advance3 = () => input[index++];
      const push2 = (node2) => {
        if (node2.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node2.type === "text") {
          prev.value += node2.value;
          return;
        }
        block.nodes.push(node2);
        node2.parent = block;
        node2.prev = prev;
        prev = node2;
        return node2;
      };
      push2({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value2 = advance3();
        if (value2 === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value2 === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value2 === CHAR_BACKSLASH) {
          push2({ type: "text", value: (options2.keepEscaping ? value2 : "") + advance3() });
          continue;
        }
        if (value2 === CHAR_RIGHT_SQUARE_BRACKET2) {
          push2({ type: "text", value: "\\" + value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_SQUARE_BRACKET2) {
          brackets++;
          let next;
          while (index < length && (next = advance3())) {
            value2 += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET2) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value2 += advance3();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET2) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_PARENTHESES2) {
          block = push2({ type: "paren", nodes: [] });
          stack.push(block);
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_RIGHT_PARENTHESES2) {
          if (block.type !== "paren") {
            push2({ type: "text", value: value2 });
            continue;
          }
          block = stack.pop();
          push2({ type: "text", value: value2 });
          block = stack[stack.length - 1];
          continue;
        }
        if (value2 === CHAR_DOUBLE_QUOTE || value2 === CHAR_SINGLE_QUOTE || value2 === CHAR_BACKTICK) {
          let open2 = value2;
          let next;
          if (options2.keepQuotes !== true) {
            value2 = "";
          }
          while (index < length && (next = advance3())) {
            if (next === CHAR_BACKSLASH) {
              value2 += next + advance3();
              continue;
            }
            if (next === open2) {
              if (options2.keepQuotes === true)
                value2 += next;
              break;
            }
            value2 += next;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_CURLY_BRACE2) {
          depth3++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth: depth3,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push2(brace);
          stack.push(block);
          push2({ type: "open", value: value2 });
          continue;
        }
        if (value2 === CHAR_RIGHT_CURLY_BRACE2) {
          if (block.type !== "brace") {
            push2({ type: "text", value: value2 });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push2({ type, value: value2 });
          depth3--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value2 === CHAR_COMMA2 && depth3 > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open2 = block.nodes.shift();
            block.nodes = [open2, { type: "text", value: stringify$4(block) }];
          }
          push2({ type: "comma", value: value2 });
          block.commas++;
          continue;
        }
        if (value2 === CHAR_DOT2 && depth3 > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth3 === 0 || siblings.length === 0) {
            push2({ type: "text", value: value2 });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value2;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value2;
            prev = before;
            block.ranges--;
            continue;
          }
          push2({ type: "dot", value: value2 });
          continue;
        }
        push2({ type: "text", value: value2 });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node2) => {
            if (!node2.nodes) {
              if (node2.type === "open")
                node2.isOpen = true;
              if (node2.type === "close")
                node2.isClose = true;
              if (!node2.nodes)
                node2.type = "text";
              node2.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push2({ type: "eos" });
      return ast;
    };
    parse_1$2 = parse$c;
    stringify$3 = stringify$7;
    compile = compile_1;
    expand$1 = expand_1$1;
    parse$b = parse_1$2;
    braces$2 = (input, options2 = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern2 of input) {
          let result = braces$2.create(pattern2, options2);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces$2.create(input, options2));
      }
      if (options2 && options2.expand === true && options2.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces$2.parse = (input, options2 = {}) => parse$b(input, options2);
    braces$2.stringify = (input, options2 = {}) => {
      if (typeof input === "string") {
        return stringify$3(braces$2.parse(input, options2), options2);
      }
      return stringify$3(input, options2);
    };
    braces$2.compile = (input, options2 = {}) => {
      if (typeof input === "string") {
        input = braces$2.parse(input, options2);
      }
      return compile(input, options2);
    };
    braces$2.expand = (input, options2 = {}) => {
      if (typeof input === "string") {
        input = braces$2.parse(input, options2);
      }
      let result = expand$1(input, options2);
      if (options2.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options2.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces$2.create = (input, options2 = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options2.expand !== true ? braces$2.compile(input, options2) : braces$2.expand(input, options2);
    };
    braces_1 = braces$2;
    util = import_util.default;
    braces$1 = braces_1;
    picomatch$2 = picomatchExports2;
    utils$b = utils$k;
    isEmptyString = (val) => val === "" || val === "./";
    micromatch$1 = (list, patterns2, options2) => {
      patterns2 = [].concat(patterns2);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options2 && options2.onResult) {
          options2.onResult(state);
        }
      };
      for (let i = 0; i < patterns2.length; i++) {
        let isMatch = picomatch$2(String(patterns2[i]), { ...options2, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns2.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options2 && matches.length === 0) {
        if (options2.failglob === true) {
          throw new Error(`No matches found for "${patterns2.join(", ")}"`);
        }
        if (options2.nonull === true || options2.nullglob === true) {
          return options2.unescape ? patterns2.map((p) => p.replace(/\\/g, "")) : patterns2;
        }
      }
      return matches;
    };
    micromatch$1.match = micromatch$1;
    micromatch$1.matcher = (pattern2, options2) => picomatch$2(pattern2, options2);
    micromatch$1.isMatch = (str, patterns2, options2) => picomatch$2(patterns2, options2)(str);
    micromatch$1.any = micromatch$1.isMatch;
    micromatch$1.not = (list, patterns2, options2 = {}) => {
      patterns2 = [].concat(patterns2).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options2.onResult)
          options2.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch$1(list, patterns2, { ...options2, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch$1.contains = (str, pattern2, options2) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern2)) {
        return pattern2.some((p) => micromatch$1.contains(str, p, options2));
      }
      if (typeof pattern2 === "string") {
        if (isEmptyString(str) || isEmptyString(pattern2)) {
          return false;
        }
        if (str.includes(pattern2) || str.startsWith("./") && str.slice(2).includes(pattern2)) {
          return true;
        }
      }
      return micromatch$1.isMatch(str, pattern2, { ...options2, contains: true });
    };
    micromatch$1.matchKeys = (obj, patterns2, options2) => {
      if (!utils$b.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys2 = micromatch$1(Object.keys(obj), patterns2, options2);
      let res = {};
      for (let key of keys2)
        res[key] = obj[key];
      return res;
    };
    micromatch$1.some = (list, patterns2, options2) => {
      let items = [].concat(list);
      for (let pattern2 of [].concat(patterns2)) {
        let isMatch = picomatch$2(String(pattern2), options2);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch$1.every = (list, patterns2, options2) => {
      let items = [].concat(list);
      for (let pattern2 of [].concat(patterns2)) {
        let isMatch = picomatch$2(String(pattern2), options2);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch$1.all = (str, patterns2, options2) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns2).every((p) => picomatch$2(p, options2)(str));
    };
    micromatch$1.capture = (glob, input, options2) => {
      let posix3 = utils$b.isWindows(options2);
      let regex = picomatch$2.makeRe(String(glob), { ...options2, capture: true });
      let match = regex.exec(posix3 ? utils$b.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch$1.makeRe = (...args) => picomatch$2.makeRe(...args);
    micromatch$1.scan = (...args) => picomatch$2.scan(...args);
    micromatch$1.parse = (patterns2, options2) => {
      let res = [];
      for (let pattern2 of [].concat(patterns2 || [])) {
        for (let str of braces$1(String(pattern2), options2)) {
          res.push(picomatch$2.parse(str, options2));
        }
      }
      return res;
    };
    micromatch$1.braces = (pattern2, options2) => {
      if (typeof pattern2 !== "string")
        throw new TypeError("Expected a string");
      if (options2 && options2.nobrace === true || !/\{.*\}/.test(pattern2)) {
        return [pattern2];
      }
      return braces$1(pattern2, options2);
    };
    micromatch$1.braceExpand = (pattern2, options2) => {
      if (typeof pattern2 !== "string")
        throw new TypeError("Expected a string");
      return micromatch$1.braces(pattern2, { ...options2, expand: true });
    };
    micromatch_1 = micromatch$1;
    Object.defineProperty(pattern$1, "__esModule", { value: true });
    pattern$1.matchAny = pattern$1.convertPatternsToRe = pattern$1.makeRe = pattern$1.getPatternParts = pattern$1.expandBraceExpansion = pattern$1.expandPatternsWithBraceExpansion = pattern$1.isAffectDepthOfReadingPattern = pattern$1.endsWithSlashGlobStar = pattern$1.hasGlobStar = pattern$1.getBaseDirectory = pattern$1.isPatternRelatedToParentDirectory = pattern$1.getPatternsOutsideCurrentDirectory = pattern$1.getPatternsInsideCurrentDirectory = pattern$1.getPositivePatterns = pattern$1.getNegativePatterns = pattern$1.isPositivePattern = pattern$1.isNegativePattern = pattern$1.convertToNegativePattern = pattern$1.convertToPositivePattern = pattern$1.isDynamicPattern = pattern$1.isStaticPattern = void 0;
    path$f = import_path2.default;
    globParent$1 = globParent$2;
    micromatch = micromatch_1;
    GLOBSTAR$1 = "**";
    ESCAPE_SYMBOL = "\\";
    COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    pattern$1.isStaticPattern = isStaticPattern;
    pattern$1.isDynamicPattern = isDynamicPattern;
    pattern$1.convertToPositivePattern = convertToPositivePattern;
    pattern$1.convertToNegativePattern = convertToNegativePattern;
    pattern$1.isNegativePattern = isNegativePattern;
    pattern$1.isPositivePattern = isPositivePattern;
    pattern$1.getNegativePatterns = getNegativePatterns;
    pattern$1.getPositivePatterns = getPositivePatterns$1;
    pattern$1.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    pattern$1.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    pattern$1.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    pattern$1.getBaseDirectory = getBaseDirectory;
    pattern$1.hasGlobStar = hasGlobStar;
    pattern$1.endsWithSlashGlobStar = endsWithSlashGlobStar;
    pattern$1.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    pattern$1.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    pattern$1.expandBraceExpansion = expandBraceExpansion;
    pattern$1.getPatternParts = getPatternParts;
    pattern$1.makeRe = makeRe;
    pattern$1.convertPatternsToRe = convertPatternsToRe;
    pattern$1.matchAny = matchAny;
    stream$4 = {};
    Stream = import_stream.default;
    PassThrough = Stream.PassThrough;
    slice = Array.prototype.slice;
    merge2_1 = merge2$1;
    Object.defineProperty(stream$4, "__esModule", { value: true });
    stream$4.merge = void 0;
    merge2 = merge2_1;
    stream$4.merge = merge$1;
    string$2 = {};
    Object.defineProperty(string$2, "__esModule", { value: true });
    string$2.isEmpty = string$2.isString = void 0;
    string$2.isString = isString;
    string$2.isEmpty = isEmpty$1;
    Object.defineProperty(utils$g, "__esModule", { value: true });
    utils$g.string = utils$g.stream = utils$g.pattern = utils$g.path = utils$g.fs = utils$g.errno = utils$g.array = void 0;
    array = array$1;
    utils$g.array = array;
    errno = errno$1;
    utils$g.errno = errno;
    fs$g = fs$h;
    utils$g.fs = fs$g;
    path$e = path$h;
    utils$g.path = path$e;
    pattern = pattern$1;
    utils$g.pattern = pattern;
    stream$3 = stream$4;
    utils$g.stream = stream$3;
    string$1 = string$2;
    utils$g.string = string$1;
    Object.defineProperty(tasks, "__esModule", { value: true });
    tasks.convertPatternGroupToTask = tasks.convertPatternGroupsToTasks = tasks.groupPatternsByBaseDirectory = tasks.getNegativePatternsAsPositive = tasks.getPositivePatterns = tasks.convertPatternsToTasks = tasks.generate = void 0;
    utils$a = utils$g;
    tasks.generate = generate;
    tasks.convertPatternsToTasks = convertPatternsToTasks;
    tasks.getPositivePatterns = getPositivePatterns;
    tasks.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    tasks.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    tasks.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    tasks.convertPatternGroupToTask = convertPatternGroupToTask;
    patterns = {};
    Object.defineProperty(patterns, "__esModule", { value: true });
    patterns.removeDuplicateSlashes = patterns.transform = void 0;
    DOUBLE_SLASH_RE$1 = /(?!^)\/{2,}/g;
    patterns.transform = transform;
    patterns.removeDuplicateSlashes = removeDuplicateSlashes;
    async$7 = {};
    async$6 = {};
    out$3 = {};
    async$5 = {};
    async$4 = {};
    out$2 = {};
    async$3 = {};
    out$1 = {};
    async$2 = {};
    Object.defineProperty(async$2, "__esModule", { value: true });
    async$2.read = void 0;
    async$2.read = read$3;
    sync$8 = {};
    Object.defineProperty(sync$8, "__esModule", { value: true });
    sync$8.read = void 0;
    sync$8.read = read$2;
    settings$3 = {};
    fs$f = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
      const fs2 = import_fs.default;
      exports2.FILE_SYSTEM_ADAPTER = {
        lstat: fs2.lstat,
        stat: fs2.stat,
        lstatSync: fs2.lstatSync,
        statSync: fs2.statSync
      };
      function createFileSystemAdapter(fsMethods) {
        if (fsMethods === void 0) {
          return exports2.FILE_SYSTEM_ADAPTER;
        }
        return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
      }
      exports2.createFileSystemAdapter = createFileSystemAdapter;
    })(fs$f);
    Object.defineProperty(settings$3, "__esModule", { value: true });
    fs$e = fs$f;
    Settings$2 = class Settings {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs$e.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    settings$3.default = Settings$2;
    Object.defineProperty(out$1, "__esModule", { value: true });
    out$1.statSync = out$1.stat = out$1.Settings = void 0;
    async$1 = async$2;
    sync$7 = sync$8;
    settings_1$3 = settings$3;
    out$1.Settings = settings_1$3.default;
    out$1.stat = stat$4;
    out$1.statSync = statSync;
    queueMicrotask_1 = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : commonjsGlobal) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
    runParallel_1 = runParallel;
    queueMicrotask$1 = queueMicrotask_1;
    constants$22 = {};
    Object.defineProperty(constants$22, "__esModule", { value: true });
    constants$22.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    SUPPORTED_MAJOR_VERSION = 10;
    SUPPORTED_MINOR_VERSION = 10;
    IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    constants$22.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
    utils$9 = {};
    fs$d = {};
    Object.defineProperty(fs$d, "__esModule", { value: true });
    fs$d.createDirentFromStats = void 0;
    DirentFromStats2 = class {
      constructor(name2, stats) {
        this.name = name2;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    fs$d.createDirentFromStats = createDirentFromStats;
    Object.defineProperty(utils$9, "__esModule", { value: true });
    utils$9.fs = void 0;
    fs$c = fs$d;
    utils$9.fs = fs$c;
    common$a = {};
    Object.defineProperty(common$a, "__esModule", { value: true });
    common$a.joinPathSegments = void 0;
    common$a.joinPathSegments = joinPathSegments$1;
    Object.defineProperty(async$3, "__esModule", { value: true });
    async$3.readdir = async$3.readdirWithFileTypes = async$3.read = void 0;
    fsStat$5 = out$1;
    rpl = runParallel_1;
    constants_1$1 = constants$22;
    utils$8 = utils$9;
    common$9 = common$a;
    async$3.read = read$1;
    async$3.readdirWithFileTypes = readdirWithFileTypes$1;
    async$3.readdir = readdir$3;
    sync$6 = {};
    Object.defineProperty(sync$6, "__esModule", { value: true });
    sync$6.readdir = sync$6.readdirWithFileTypes = sync$6.read = void 0;
    fsStat$4 = out$1;
    constants_1 = constants$22;
    utils$7 = utils$9;
    common$8 = common$a;
    sync$6.read = read;
    sync$6.readdirWithFileTypes = readdirWithFileTypes;
    sync$6.readdir = readdir$2;
    settings$2 = {};
    fs$b = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
      const fs2 = import_fs.default;
      exports2.FILE_SYSTEM_ADAPTER = {
        lstat: fs2.lstat,
        stat: fs2.stat,
        lstatSync: fs2.lstatSync,
        statSync: fs2.statSync,
        readdir: fs2.readdir,
        readdirSync: fs2.readdirSync
      };
      function createFileSystemAdapter(fsMethods) {
        if (fsMethods === void 0) {
          return exports2.FILE_SYSTEM_ADAPTER;
        }
        return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
      }
      exports2.createFileSystemAdapter = createFileSystemAdapter;
    })(fs$b);
    Object.defineProperty(settings$2, "__esModule", { value: true });
    path$d = import_path2.default;
    fsStat$3 = out$1;
    fs$a = fs$b;
    Settings$1 = class Settings2 {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs$a.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$d.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat$3.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    settings$2.default = Settings$1;
    Object.defineProperty(out$2, "__esModule", { value: true });
    out$2.Settings = out$2.scandirSync = out$2.scandir = void 0;
    async = async$3;
    sync$5 = sync$6;
    settings_1$2 = settings$2;
    out$2.Settings = settings_1$2.default;
    out$2.scandir = scandir;
    out$2.scandirSync = scandirSync;
    queueExports = {};
    queue = {
      get exports() {
        return queueExports;
      },
      set exports(v) {
        queueExports = v;
      }
    };
    reusify_1 = reusify$1;
    reusify = reusify_1;
    queue.exports = fastqueue;
    queueExports.promise = queueAsPromised;
    common$7 = {};
    Object.defineProperty(common$7, "__esModule", { value: true });
    common$7.joinPathSegments = common$7.replacePathSegmentSeparator = common$7.isAppliedFilter = common$7.isFatalError = void 0;
    common$7.isFatalError = isFatalError;
    common$7.isAppliedFilter = isAppliedFilter;
    common$7.replacePathSegmentSeparator = replacePathSegmentSeparator;
    common$7.joinPathSegments = joinPathSegments;
    reader$1 = {};
    Object.defineProperty(reader$1, "__esModule", { value: true });
    common$6 = common$7;
    Reader$1 = class Reader {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common$6.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    reader$1.default = Reader$1;
    Object.defineProperty(async$4, "__esModule", { value: true });
    events_1 = import_events.default;
    fsScandir$2 = out$2;
    fastq = queueExports;
    common$5 = common$7;
    reader_1$4 = reader$1;
    AsyncReader = class extends reader_1$4.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir$2.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base3) {
        const queueItem = { directory, base: base3 };
        this._queue.push(queueItem, (error2) => {
          if (error2 !== null) {
            this._handleError(error2);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error2, entries) => {
          if (error2 !== null) {
            done(error2, void 0);
            return;
          }
          for (const entry2 of entries) {
            this._handleEntry(entry2, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error2) {
        if (this._isDestroyed || !common$5.isFatalError(this._settings, error2)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error2);
      }
      _handleEntry(entry2, base3) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry2.path;
        if (base3 !== void 0) {
          entry2.path = common$5.joinPathSegments(base3, entry2.name, this._settings.pathSegmentSeparator);
        }
        if (common$5.isAppliedFilter(this._settings.entryFilter, entry2)) {
          this._emitEntry(entry2);
        }
        if (entry2.dirent.isDirectory() && common$5.isAppliedFilter(this._settings.deepFilter, entry2)) {
          this._pushToQueue(fullpath, base3 === void 0 ? void 0 : entry2.path);
        }
      }
      _emitEntry(entry2) {
        this._emitter.emit("entry", entry2);
      }
    };
    async$4.default = AsyncReader;
    Object.defineProperty(async$5, "__esModule", { value: true });
    async_1$4 = async$4;
    AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1$4.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error2) => {
          callFailureCallback(callback, error2);
        });
        this._reader.onEntry((entry2) => {
          this._storage.push(entry2);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    async$5.default = AsyncProvider;
    stream$2 = {};
    Object.defineProperty(stream$2, "__esModule", { value: true });
    stream_1$5 = import_stream.default;
    async_1$3 = async$4;
    StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1$3.default(this._root, this._settings);
        this._stream = new stream_1$5.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error2) => {
          this._stream.emit("error", error2);
        });
        this._reader.onEntry((entry2) => {
          this._stream.push(entry2);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    stream$2.default = StreamProvider;
    sync$4 = {};
    sync$3 = {};
    Object.defineProperty(sync$3, "__esModule", { value: true });
    fsScandir$1 = out$2;
    common$4 = common$7;
    reader_1$3 = reader$1;
    SyncReader = class extends reader_1$3.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir$1.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base3) {
        this._queue.add({ directory, base: base3 });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base3) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry2 of entries) {
            this._handleEntry(entry2, base3);
          }
        } catch (error2) {
          this._handleError(error2);
        }
      }
      _handleError(error2) {
        if (!common$4.isFatalError(this._settings, error2)) {
          return;
        }
        throw error2;
      }
      _handleEntry(entry2, base3) {
        const fullpath = entry2.path;
        if (base3 !== void 0) {
          entry2.path = common$4.joinPathSegments(base3, entry2.name, this._settings.pathSegmentSeparator);
        }
        if (common$4.isAppliedFilter(this._settings.entryFilter, entry2)) {
          this._pushToStorage(entry2);
        }
        if (entry2.dirent.isDirectory() && common$4.isAppliedFilter(this._settings.deepFilter, entry2)) {
          this._pushToQueue(fullpath, base3 === void 0 ? void 0 : entry2.path);
        }
      }
      _pushToStorage(entry2) {
        this._storage.push(entry2);
      }
    };
    sync$3.default = SyncReader;
    Object.defineProperty(sync$4, "__esModule", { value: true });
    sync_1$3 = sync$3;
    SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1$3.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    sync$4.default = SyncProvider;
    settings$1 = {};
    Object.defineProperty(settings$1, "__esModule", { value: true });
    path$c = import_path2.default;
    fsScandir = out$2;
    Settings3 = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$c.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    settings$1.default = Settings3;
    Object.defineProperty(out$3, "__esModule", { value: true });
    out$3.Settings = out$3.walkStream = out$3.walkSync = out$3.walk = void 0;
    async_1$2 = async$5;
    stream_1$4 = stream$2;
    sync_1$2 = sync$4;
    settings_1$1 = settings$1;
    out$3.Settings = settings_1$1.default;
    out$3.walk = walk$2;
    out$3.walkSync = walkSync;
    out$3.walkStream = walkStream;
    reader = {};
    Object.defineProperty(reader, "__esModule", { value: true });
    path$b = import_path2.default;
    fsStat$2 = out$1;
    utils$6 = utils$g;
    Reader2 = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat$2.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path$b.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern2) {
        const entry2 = {
          name: pattern2,
          path: pattern2,
          dirent: utils$6.fs.createDirentFromStats(pattern2, stats)
        };
        if (this._settings.stats) {
          entry2.stats = stats;
        }
        return entry2;
      }
      _isFatalError(error2) {
        return !utils$6.errno.isEnoentCodeError(error2) && !this._settings.suppressErrors;
      }
    };
    reader.default = Reader2;
    stream$1 = {};
    Object.defineProperty(stream$1, "__esModule", { value: true });
    stream_1$3 = import_stream.default;
    fsStat$1 = out$1;
    fsWalk$2 = out$3;
    reader_1$2 = reader;
    ReaderStream = class extends reader_1$2.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk$2.walkStream;
        this._stat = fsStat$1.stat;
      }
      dynamic(root, options2) {
        return this._walkStream(root, options2);
      }
      static(patterns2, options2) {
        const filepaths = patterns2.map(this._getFullEntryPath, this);
        const stream4 = new stream_1$3.PassThrough({ objectMode: true });
        stream4._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns2[index], options2).then((entry2) => {
            if (entry2 !== null && options2.entryFilter(entry2)) {
              stream4.push(entry2);
            }
            if (index === filepaths.length - 1) {
              stream4.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream4.write(i);
        }
        return stream4;
      }
      _getEntry(filepath, pattern2, options2) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern2)).catch((error2) => {
          if (options2.errorFilter(error2)) {
            return null;
          }
          throw error2;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve5, reject) => {
          this._stat(filepath, this._fsStatSettings, (error2, stats) => {
            return error2 === null ? resolve5(stats) : reject(error2);
          });
        });
      }
    };
    stream$1.default = ReaderStream;
    Object.defineProperty(async$6, "__esModule", { value: true });
    fsWalk$1 = out$3;
    reader_1$1 = reader;
    stream_1$2 = stream$1;
    ReaderAsync = class extends reader_1$1.default {
      constructor() {
        super(...arguments);
        this._walkAsync = fsWalk$1.walk;
        this._readerStream = new stream_1$2.default(this._settings);
      }
      dynamic(root, options2) {
        return new Promise((resolve5, reject) => {
          this._walkAsync(root, options2, (error2, entries) => {
            if (error2 === null) {
              resolve5(entries);
            } else {
              reject(error2);
            }
          });
        });
      }
      async static(patterns2, options2) {
        const entries = [];
        const stream4 = this._readerStream.static(patterns2, options2);
        return new Promise((resolve5, reject) => {
          stream4.once("error", reject);
          stream4.on("data", (entry2) => entries.push(entry2));
          stream4.once("end", () => resolve5(entries));
        });
      }
    };
    async$6.default = ReaderAsync;
    provider = {};
    deep = {};
    partial = {};
    matcher = {};
    Object.defineProperty(matcher, "__esModule", { value: true });
    utils$5 = utils$g;
    Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        const patterns2 = utils$5.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern2 of patterns2) {
          const segments = this._getPatternSegments(pattern2);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern: pattern2,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern2) {
        const parts = utils$5.pattern.getPatternParts(pattern2, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils$5.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils$5.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils$5.array.splitWhen(segments, (segment) => segment.dynamic && utils$5.pattern.hasGlobStar(segment.pattern));
      }
    };
    matcher.default = Matcher;
    Object.defineProperty(partial, "__esModule", { value: true });
    matcher_1 = matcher;
    PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns2 = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern2 of patterns2) {
          const section = pattern2.sections[0];
          if (!pattern2.complete && levels > section.length) {
            return true;
          }
          const match = parts.every((part, index) => {
            const segment = pattern2.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    partial.default = PartialMatcher;
    Object.defineProperty(deep, "__esModule", { value: true });
    utils$4 = utils$g;
    partial_1 = partial;
    DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher2 = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry2) => this._filter(basePath, entry2, matcher2, negativeRe);
      }
      _getMatcher(patterns2) {
        return new partial_1.default(patterns2, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns2) {
        const affectDepthOfReadingPatterns = patterns2.filter(utils$4.pattern.isAffectDepthOfReadingPattern);
        return utils$4.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry2, matcher2, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry2.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry2)) {
          return false;
        }
        const filepath = utils$4.path.removeLeadingDotSegment(entry2.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher2)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry2) {
        return !this._settings.followSymbolicLinks && entry2.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher2) {
        return !this._settings.baseNameMatch && !matcher2.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils$4.pattern.matchAny(entryPath, patternsRe);
      }
    };
    deep.default = DeepFilter;
    entry$1 = {};
    Object.defineProperty(entry$1, "__esModule", { value: true });
    utils$32 = utils$g;
    EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils$32.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils$32.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry2) => this._filter(entry2, positiveRe, negativeRe);
      }
      _filter(entry2, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry2)) {
          return false;
        }
        if (this._onlyFileFilter(entry2) || this._onlyDirectoryFilter(entry2)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry2.path, negativeRe)) {
          return false;
        }
        const filepath = this._settings.baseNameMatch ? entry2.name : entry2.path;
        const isDirectory = entry2.dirent.isDirectory();
        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(entry2.path, negativeRe, isDirectory);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(entry2);
        }
        return isMatched;
      }
      _isDuplicateEntry(entry2) {
        return this.index.has(entry2.path);
      }
      _createIndexRecord(entry2) {
        this.index.set(entry2.path, void 0);
      }
      _onlyFileFilter(entry2) {
        return this._settings.onlyFiles && !entry2.dirent.isFile();
      }
      _onlyDirectoryFilter(entry2) {
        return this._settings.onlyDirectories && !entry2.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils$32.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils$32.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(entryPath, patternsRe, isDirectory) {
        const filepath = utils$32.path.removeLeadingDotSegment(entryPath);
        const isMatched = utils$32.pattern.matchAny(filepath, patternsRe);
        if (!isMatched && isDirectory) {
          return utils$32.pattern.matchAny(filepath + "/", patternsRe);
        }
        return isMatched;
      }
    };
    entry$1.default = EntryFilter;
    error$2 = {};
    Object.defineProperty(error$2, "__esModule", { value: true });
    utils$22 = utils$g;
    ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error2) => this._isNonFatalError(error2);
      }
      _isNonFatalError(error2) {
        return utils$22.errno.isEnoentCodeError(error2) || this._settings.suppressErrors;
      }
    };
    error$2.default = ErrorFilter;
    entry = {};
    Object.defineProperty(entry, "__esModule", { value: true });
    utils$12 = utils$g;
    EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry2) => this._transform(entry2);
      }
      _transform(entry2) {
        let filepath = entry2.path;
        if (this._settings.absolute) {
          filepath = utils$12.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils$12.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry2.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry2), { path: filepath });
      }
    };
    entry.default = EntryTransformer;
    Object.defineProperty(provider, "__esModule", { value: true });
    path$a = import_path2.default;
    deep_1 = deep;
    entry_1 = entry$1;
    error_1 = error$2;
    entry_2 = entry;
    Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path$a.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    provider.default = Provider;
    Object.defineProperty(async$7, "__esModule", { value: true });
    async_1$1 = async$6;
    provider_1$2 = provider;
    ProviderAsync = class extends provider_1$2.default {
      constructor() {
        super(...arguments);
        this._reader = new async_1$1.default(this._settings);
      }
      async read(task) {
        const root = this._getRootDirectory(task);
        const options2 = this._getReaderOptions(task);
        const entries = await this.api(root, task, options2);
        return entries.map((entry2) => options2.transform(entry2));
      }
      api(root, task, options2) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options2);
        }
        return this._reader.static(task.patterns, options2);
      }
    };
    async$7.default = ProviderAsync;
    stream = {};
    Object.defineProperty(stream, "__esModule", { value: true });
    stream_1$1 = import_stream.default;
    stream_2 = stream$1;
    provider_1$1 = provider;
    ProviderStream = class extends provider_1$1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options2 = this._getReaderOptions(task);
        const source = this.api(root, task, options2);
        const destination = new stream_1$1.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error2) => destination.emit("error", error2)).on("data", (entry2) => destination.emit("data", options2.transform(entry2))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options2) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options2);
        }
        return this._reader.static(task.patterns, options2);
      }
    };
    stream.default = ProviderStream;
    sync$2 = {};
    sync$1 = {};
    Object.defineProperty(sync$1, "__esModule", { value: true });
    fsStat = out$1;
    fsWalk = out$3;
    reader_1 = reader;
    ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options2) {
        return this._walkSync(root, options2);
      }
      static(patterns2, options2) {
        const entries = [];
        for (const pattern2 of patterns2) {
          const filepath = this._getFullEntryPath(pattern2);
          const entry2 = this._getEntry(filepath, pattern2, options2);
          if (entry2 === null || !options2.entryFilter(entry2)) {
            continue;
          }
          entries.push(entry2);
        }
        return entries;
      }
      _getEntry(filepath, pattern2, options2) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern2);
        } catch (error2) {
          if (options2.errorFilter(error2)) {
            return null;
          }
          throw error2;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    sync$1.default = ReaderSync;
    Object.defineProperty(sync$2, "__esModule", { value: true });
    sync_1$1 = sync$1;
    provider_1 = provider;
    ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1$1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options2 = this._getReaderOptions(task);
        const entries = this.api(root, task, options2);
        return entries.map(options2.transform);
      }
      api(root, task, options2) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options2);
        }
        return this._reader.static(task.patterns, options2);
      }
    };
    sync$2.default = ProviderSync;
    settings = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
      const fs2 = import_fs.default;
      const os2 = import_os.default;
      const CPU_COUNT = Math.max(os2.cpus().length, 1);
      exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
        lstat: fs2.lstat,
        lstatSync: fs2.lstatSync,
        stat: fs2.stat,
        statSync: fs2.statSync,
        readdir: fs2.readdir,
        readdirSync: fs2.readdirSync
      };
      class Settings4 {
        constructor(_options = {}) {
          this._options = _options;
          this.absolute = this._getValue(this._options.absolute, false);
          this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
          this.braceExpansion = this._getValue(this._options.braceExpansion, true);
          this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
          this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
          this.cwd = this._getValue(this._options.cwd, process.cwd());
          this.deep = this._getValue(this._options.deep, Infinity);
          this.dot = this._getValue(this._options.dot, false);
          this.extglob = this._getValue(this._options.extglob, true);
          this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
          this.fs = this._getFileSystemMethods(this._options.fs);
          this.globstar = this._getValue(this._options.globstar, true);
          this.ignore = this._getValue(this._options.ignore, []);
          this.markDirectories = this._getValue(this._options.markDirectories, false);
          this.objectMode = this._getValue(this._options.objectMode, false);
          this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
          this.onlyFiles = this._getValue(this._options.onlyFiles, true);
          this.stats = this._getValue(this._options.stats, false);
          this.suppressErrors = this._getValue(this._options.suppressErrors, false);
          this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
          this.unique = this._getValue(this._options.unique, true);
          if (this.onlyDirectories) {
            this.onlyFiles = false;
          }
          if (this.stats) {
            this.objectMode = true;
          }
        }
        _getValue(option, value2) {
          return option === void 0 ? value2 : option;
        }
        _getFileSystemMethods(methods4 = {}) {
          return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods4);
        }
      }
      exports2.default = Settings4;
    })(settings);
    taskManager = tasks;
    patternManager = patterns;
    async_1 = async$7;
    stream_1 = stream;
    sync_1 = sync$2;
    settings_1 = settings;
    utils2 = utils$g;
    (function(FastGlob2) {
      function sync2(source, options2) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options2);
        return utils2.array.flatten(works);
      }
      FastGlob2.sync = sync2;
      function stream4(source, options2) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options2);
        return utils2.stream.merge(works);
      }
      FastGlob2.stream = stream4;
      function generateTasks(source, options2) {
        assertPatternsInput(source);
        const patterns2 = patternManager.transform([].concat(source));
        const settings2 = new settings_1.default(options2);
        return taskManager.generate(patterns2, settings2);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern2(source, options2) {
        assertPatternsInput(source);
        const settings2 = new settings_1.default(options2);
        return utils2.pattern.isDynamicPattern(source, settings2);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern2;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils2.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
    })(FastGlob || (FastGlob = {}));
    debug$b = createDebugger("vite:ssr-external");
    _require$2 = (0, import_node_module.createRequire)(import_meta2.url);
    jsonLangs = `\\.(?:json|json5)(?:$|\\?)`;
    jsonLangRE = new RegExp(jsonLangs);
    isDebug$3 = process.env.DEBUG;
    debug$a = createDebugger("vite:optimize-deps");
    dist = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.lilconfigSync = exports2.lilconfig = exports2.defaultLoaders = void 0;
      const path4 = import_path2.default;
      const fs2 = import_fs.default;
      const os2 = import_os.default;
      const fsReadFileAsync = fs2.promises.readFile;
      function getDefaultSearchPlaces(name2) {
        return [
          "package.json",
          `.${name2}rc.json`,
          `.${name2}rc.js`,
          `${name2}.config.js`,
          `.${name2}rc.cjs`,
          `${name2}.config.cjs`
        ];
      }
      function getSearchPaths(startDir, stopDir) {
        return startDir.split(path4.sep).reduceRight((acc, _, ind, arr) => {
          const currentPath = arr.slice(0, ind + 1).join(path4.sep);
          if (!acc.passedStopDir)
            acc.searchPlaces.push(currentPath || path4.sep);
          if (currentPath === stopDir)
            acc.passedStopDir = true;
          return acc;
        }, { searchPlaces: [], passedStopDir: false }).searchPlaces;
      }
      exports2.defaultLoaders = Object.freeze({
        ".js": __require,
        ".json": __require,
        ".cjs": __require,
        noExt(_, content) {
          return JSON.parse(content);
        }
      });
      function getExtDesc(ext2) {
        return ext2 === "noExt" ? "files without extensions" : `extension "${ext2}"`;
      }
      function getOptions3(name2, options2 = {}) {
        const conf = {
          stopDir: os2.homedir(),
          searchPlaces: getDefaultSearchPlaces(name2),
          ignoreEmptySearchPlaces: true,
          transform: (x) => x,
          packageProp: [name2],
          ...options2,
          loaders: { ...exports2.defaultLoaders, ...options2.loaders }
        };
        conf.searchPlaces.forEach((place) => {
          const key = path4.extname(place) || "noExt";
          const loader = conf.loaders[key];
          if (!loader) {
            throw new Error(`No loader specified for ${getExtDesc(key)}, so searchPlaces item "${place}" is invalid`);
          }
          if (typeof loader !== "function") {
            throw new Error(`loader for ${getExtDesc(key)} is not a function (type provided: "${typeof loader}"), so searchPlaces item "${place}" is invalid`);
          }
        });
        return conf;
      }
      function getPackageProp(props, obj) {
        if (typeof props === "string" && props in obj)
          return obj[props];
        return (Array.isArray(props) ? props : props.split(".")).reduce((acc, prop) => acc === void 0 ? acc : acc[prop], obj) || null;
      }
      function getSearchItems(searchPlaces, searchPaths) {
        return searchPaths.reduce((acc, searchPath) => {
          searchPlaces.forEach((fileName) => acc.push({
            fileName,
            filepath: path4.join(searchPath, fileName),
            loaderKey: path4.extname(fileName) || "noExt"
          }));
          return acc;
        }, []);
      }
      function validateFilePath(filepath) {
        if (!filepath)
          throw new Error("load must pass a non-empty string");
      }
      function validateLoader(loader, ext2) {
        if (!loader)
          throw new Error(`No loader specified for extension "${ext2}"`);
        if (typeof loader !== "function")
          throw new Error("loader is not a function");
      }
      function lilconfig(name2, options2) {
        const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform: transform2 } = getOptions3(name2, options2);
        return {
          async search(searchFrom = process.cwd()) {
            const searchPaths = getSearchPaths(searchFrom, stopDir);
            const result = {
              config: null,
              filepath: ""
            };
            const searchItems = getSearchItems(searchPlaces, searchPaths);
            for (const { fileName, filepath, loaderKey } of searchItems) {
              try {
                await fs2.promises.access(filepath);
              } catch (_a) {
                continue;
              }
              const content = String(await fsReadFileAsync(filepath));
              const loader = loaders[loaderKey];
              if (fileName === "package.json") {
                const pkg = await loader(filepath, content);
                const maybeConfig = getPackageProp(packageProp, pkg);
                if (maybeConfig != null) {
                  result.config = maybeConfig;
                  result.filepath = filepath;
                  break;
                }
                continue;
              }
              const isEmpty2 = content.trim() === "";
              if (isEmpty2 && ignoreEmptySearchPlaces)
                continue;
              if (isEmpty2) {
                result.isEmpty = true;
                result.config = void 0;
              } else {
                validateLoader(loader, loaderKey);
                result.config = await loader(filepath, content);
              }
              result.filepath = filepath;
              break;
            }
            if (result.filepath === "" && result.config === null)
              return transform2(null);
            return transform2(result);
          },
          async load(filepath) {
            validateFilePath(filepath);
            const absPath = path4.resolve(process.cwd(), filepath);
            const { base: base3, ext: ext2 } = path4.parse(absPath);
            const loaderKey = ext2 || "noExt";
            const loader = loaders[loaderKey];
            validateLoader(loader, loaderKey);
            const content = String(await fsReadFileAsync(absPath));
            if (base3 === "package.json") {
              const pkg = await loader(absPath, content);
              return transform2({
                config: getPackageProp(packageProp, pkg),
                filepath: absPath
              });
            }
            const result = {
              config: null,
              filepath: absPath
            };
            const isEmpty2 = content.trim() === "";
            if (isEmpty2 && ignoreEmptySearchPlaces)
              return transform2({
                config: void 0,
                filepath: absPath,
                isEmpty: true
              });
            result.config = isEmpty2 ? void 0 : await loader(absPath, content);
            return transform2(isEmpty2 ? { ...result, isEmpty: isEmpty2, config: void 0 } : result);
          }
        };
      }
      exports2.lilconfig = lilconfig;
      function lilconfigSync(name2, options2) {
        const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform: transform2 } = getOptions3(name2, options2);
        return {
          search(searchFrom = process.cwd()) {
            const searchPaths = getSearchPaths(searchFrom, stopDir);
            const result = {
              config: null,
              filepath: ""
            };
            const searchItems = getSearchItems(searchPlaces, searchPaths);
            for (const { fileName, filepath, loaderKey } of searchItems) {
              try {
                fs2.accessSync(filepath);
              } catch (_a) {
                continue;
              }
              const loader = loaders[loaderKey];
              const content = String(fs2.readFileSync(filepath));
              if (fileName === "package.json") {
                const pkg = loader(filepath, content);
                const maybeConfig = getPackageProp(packageProp, pkg);
                if (maybeConfig != null) {
                  result.config = maybeConfig;
                  result.filepath = filepath;
                  break;
                }
                continue;
              }
              const isEmpty2 = content.trim() === "";
              if (isEmpty2 && ignoreEmptySearchPlaces)
                continue;
              if (isEmpty2) {
                result.isEmpty = true;
                result.config = void 0;
              } else {
                validateLoader(loader, loaderKey);
                result.config = loader(filepath, content);
              }
              result.filepath = filepath;
              break;
            }
            if (result.filepath === "" && result.config === null)
              return transform2(null);
            return transform2(result);
          },
          load(filepath) {
            validateFilePath(filepath);
            const absPath = path4.resolve(process.cwd(), filepath);
            const { base: base3, ext: ext2 } = path4.parse(absPath);
            const loaderKey = ext2 || "noExt";
            const loader = loaders[loaderKey];
            validateLoader(loader, loaderKey);
            const content = String(fs2.readFileSync(absPath));
            if (base3 === "package.json") {
              const pkg = loader(absPath, content);
              return transform2({
                config: getPackageProp(packageProp, pkg),
                filepath: absPath
              });
            }
            const result = {
              config: null,
              filepath: absPath
            };
            const isEmpty2 = content.trim() === "";
            if (isEmpty2 && ignoreEmptySearchPlaces)
              return transform2({
                filepath: absPath,
                config: void 0,
                isEmpty: true
              });
            result.config = isEmpty2 ? void 0 : loader(absPath, content);
            return transform2(isEmpty2 ? { ...result, isEmpty: isEmpty2, config: void 0 } : result);
          }
        };
      }
      exports2.lilconfigSync = lilconfigSync;
    })(dist);
    ALIAS = Symbol.for("yaml.alias");
    DOC = Symbol.for("yaml.document");
    MAP = Symbol.for("yaml.map");
    PAIR = Symbol.for("yaml.pair");
    SCALAR$1 = Symbol.for("yaml.scalar");
    SEQ = Symbol.for("yaml.seq");
    NODE_TYPE = Symbol.for("yaml.node.type");
    isAlias = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === ALIAS;
    isDocument = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === DOC;
    isMap = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === MAP;
    isPair = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === PAIR;
    isScalar$1 = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === SCALAR$1;
    isSeq = (node2) => !!node2 && typeof node2 === "object" && node2[NODE_TYPE] === SEQ;
    hasAnchor = (node2) => (isScalar$1(node2) || isCollection$1(node2)) && !!node2.anchor;
    NodeBase2 = class {
      constructor(type) {
        Object.defineProperty(this, NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
    };
    BREAK$1 = Symbol("break visit");
    SKIP$1 = Symbol("skip children");
    REMOVE$1 = Symbol("remove node");
    visit$1.BREAK = BREAK$1;
    visit$1.SKIP = SKIP$1;
    visit$1.REMOVE = REMOVE$1;
    visitAsync.BREAK = BREAK$1;
    visitAsync.SKIP = SKIP$1;
    visitAsync.REMOVE = REMOVE$1;
    escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    Directives = class {
      constructor(yaml2, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml2);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
      }
      clone() {
        const copy = new Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name2 = parts.shift();
        switch (name2) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle2, prefix] = parts;
            this.tags[handle2] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version5] = parts;
            if (version5 === "1.1" || version5 === "1.2") {
              this.yaml.version = version5;
              return true;
            } else {
              const isValid = /^\d+\.\d+$/.test(version5);
              onError(6, `Unsupported YAML version ${version5}`, isValid);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name2}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle2, suffix] = source.match(/^(.*!)([^!]*)$/);
        if (!suffix)
          onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle2];
        if (prefix)
          return prefix + decodeURIComponent(suffix);
        if (handle2 === "!")
          return source;
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle2, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle2 + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && isNode$1(doc.contents)) {
          const tags = {};
          visit$1(doc.contents, (_key, node2) => {
            if (isNode$1(node2) && node2.tag)
              tags[node2.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle2, prefix] of tagEntries) {
          if (handle2 === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle2} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    Alias = class extends NodeBase2 {
      constructor(source) {
        super(ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc) {
        let found2 = void 0;
        visit$1(doc, {
          Node: (_key, node2) => {
            if (node2 === this)
              return visit$1.BREAK;
            if (node2.anchor === this.source)
              found2 = node2;
          }
        });
        return found2;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        const data3 = anchors.get(source);
        if (!data3 || data3.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data3.count += 1;
          if (data3.aliasCount === 0)
            data3.aliasCount = getAliasCount(doc, source, anchors);
          if (data3.count * data3.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data3.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src2 = `*${this.source}`;
        if (ctx) {
          anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src2} `;
        }
        return src2;
      }
    };
    isScalarValue = (value2) => !value2 || typeof value2 !== "function" && typeof value2 !== "object";
    Scalar = class extends NodeBase2 {
      constructor(value2) {
        super(SCALAR$1);
        this.value = value2;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    defaultTagPrefix = "tag:yaml.org,2002:";
    isEmptyPath = (path4) => path4 == null || typeof path4 === "object" && !!path4[Symbol.iterator]().next().done;
    Collection = class extends NodeBase2 {
      constructor(type, schema2) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema2,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema2) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema2)
          copy.schema = schema2;
        copy.items = copy.items.map((it) => isNode$1(it) || isPair(it) ? it.clone(schema2) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path4, value2) {
        if (isEmptyPath(path4))
          this.add(value2);
        else {
          const [key, ...rest] = path4;
          const node2 = this.get(key, true);
          if (isCollection$1(node2))
            node2.addIn(rest, value2);
          else if (node2 === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value2));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path4) {
        const [key, ...rest] = path4;
        if (rest.length === 0)
          return this.delete(key);
        const node2 = this.get(key, true);
        if (isCollection$1(node2))
          return node2.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path4, keepScalar) {
        const [key, ...rest] = path4;
        const node2 = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && isScalar$1(node2) ? node2.value : node2;
        else
          return isCollection$1(node2) ? node2.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node2) => {
          if (!isPair(node2))
            return false;
          const n2 = node2.value;
          return n2 == null || allowScalar && isScalar$1(n2) && n2.value == null && !n2.commentBefore && !n2.comment && !n2.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path4) {
        const [key, ...rest] = path4;
        if (rest.length === 0)
          return this.has(key);
        const node2 = this.get(key, true);
        return isCollection$1(node2) ? node2.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path4, value2) {
        const [key, ...rest] = path4;
        if (rest.length === 0) {
          this.set(key, value2);
        } else {
          const node2 = this.get(key, true);
          if (isCollection$1(node2))
            node2.setIn(rest, value2);
          else if (node2 === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value2));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    Collection.maxFlowStringSingleLineLength = 60;
    stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
    FOLD_FLOW = "flow";
    FOLD_BLOCK = "block";
    FOLD_QUOTED = "quoted";
    getFoldOptions = (ctx) => ({
      indentAtStart: ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    MERGE_KEY = "<<";
    isMergeKey = (key) => key === MERGE_KEY || isScalar$1(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
    Pair = class {
      constructor(key, value2 = null) {
        Object.defineProperty(this, NODE_TYPE, { value: PAIR });
        this.key = key;
        this.value = value2;
      }
      clone(schema2) {
        let { key, value: value2 } = this;
        if (isNode$1(key))
          key = key.clone(schema2);
        if (isNode$1(value2))
          value2 = value2.clone(schema2);
        return new Pair(key, value2);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    YAMLMap = class extends Collection {
      constructor(schema2) {
        super(MAP, schema2);
        this.items = [];
      }
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair(pair, pair?.value);
        } else
          _pair = new Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (isScalar$1(prev.value) && isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node2 = it?.value;
        return (!keepScalar && isScalar$1(node2) ? node2.value : node2) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value2) {
        this.add(new Pair(key, value2), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map2 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map2);
        for (const item of this.items)
          addPairToJSMap(ctx, map2, item);
        return map2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    map = {
      collection: "map",
      createNode: createMap,
      default: true,
      nodeClass: YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map2, onError) {
        if (!isMap(map2))
          onError("Expected a mapping for this tag");
        return map2;
      }
    };
    YAMLSeq = class extends Collection {
      constructor(schema2) {
        super(SEQ, schema2);
        this.items = [];
      }
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      add(value2) {
        this.items.push(value2);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && isScalar$1(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value2) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (isScalar$1(prev) && isScalarValue(value2))
          prev.value = value2;
        else
          this.items[idx] = value2;
      }
      toJSON(_, ctx) {
        const seq2 = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq2);
        let i = 0;
        for (const item of this.items)
          seq2.push(toJS(item, String(i++), ctx));
        return seq2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
    };
    seq = {
      collection: "seq",
      createNode: createSeq,
      default: true,
      nodeClass: YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      }
    };
    string = {
      identify: (value2) => typeof value2 === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    nullTag = {
      identify: (value2) => value2 == null,
      createNode: () => new Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    boolTag = {
      identify: (value2) => typeof value2 === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value: value2 }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value2 === sv)
            return source;
        }
        return value2 ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    floatNaN$1 = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber
    };
    floatExp$1 = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node2) {
        const num = Number(node2.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node2);
      }
    };
    float$1 = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node2 = new Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node2.minFractionDigits = str.length - dot - 1;
        return node2;
      },
      stringify: stringifyNumber
    };
    intIdentify$2 = (value2) => typeof value2 === "bigint" || Number.isInteger(value2);
    intResolve$1 = (str, offset4, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset4), radix);
    intOct$1 = {
      identify: (value2) => intIdentify$2(value2) && value2 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve$1(str, 2, 8, opt),
      stringify: (node2) => intStringify$1(node2, 8, "0o")
    };
    int$1 = {
      identify: intIdentify$2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve$1(str, 0, 10, opt),
      stringify: stringifyNumber
    };
    intHex$1 = {
      identify: (value2) => intIdentify$2(value2) && value2 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve$1(str, 2, 16, opt),
      stringify: (node2) => intStringify$1(node2, 16, "0x")
    };
    schema$2 = [
      map,
      seq,
      string,
      nullTag,
      boolTag,
      intOct$1,
      int$1,
      intHex$1,
      floatNaN$1,
      floatExp$1,
      float$1
    ];
    stringifyJSON = ({ value: value2 }) => JSON.stringify(value2);
    jsonScalars = [
      {
        identify: (value2) => typeof value2 === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value2) => value2 == null,
        createNode: () => new Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value2) => typeof value2 === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify$1,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value: value2 }) => intIdentify$1(value2) ? value2.toString() : JSON.stringify(value2)
      },
      {
        identify: (value2) => typeof value2 === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ];
    jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    schema$1 = [map, seq].concat(jsonScalars, jsonError);
    binary = {
      identify: (value2) => value2 instanceof Uint8Array,
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src2, onError) {
        if (typeof Buffer === "function") {
          return Buffer.from(src2, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src2.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i)
            buffer[i] = str.charCodeAt(i);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src2;
        }
      },
      stringify({ comment, type, value: value2 }, ctx, onComment, onChompKeep) {
        const buf = value2;
        let str;
        if (typeof Buffer === "function") {
          str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = Scalar.BLOCK_LITERAL;
        if (type !== Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n2 = Math.ceil(str.length / lineWidth);
          const lines = new Array(n2);
          for (let i = 0, o = 0; i < n2; ++i, o += lineWidth) {
            lines[i] = str.substr(o, lineWidth);
          }
          str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      }
    };
    pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    YAMLOMap = class extends YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map2 = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map2);
        for (const pair of this.items) {
          let key, value2;
          if (isPair(pair)) {
            key = toJS(pair.key, "", ctx);
            value2 = toJS(pair.value, key, ctx);
          } else {
            key = toJS(pair, "", ctx);
          }
          if (map2.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map2.set(key, value2);
        }
        return map2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    omap = {
      collection: "seq",
      identify: (value2) => value2 instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq2, onError) {
        const pairs2 = resolvePairs(seq2, onError);
        const seenKeys = [];
        for (const { key } of pairs2.items) {
          if (isScalar$1(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs2);
      },
      createNode(schema2, iterable, ctx) {
        const pairs2 = createPairs(schema2, iterable, ctx);
        const omap2 = new YAMLOMap();
        omap2.items = pairs2.items;
        return omap2;
      }
    };
    trueTag = {
      identify: (value2) => value2 === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar(true),
      stringify: boolStringify
    };
    falseTag = {
      identify: (value2) => value2 === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => new Scalar(false),
      stringify: boolStringify
    };
    floatNaN = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber
    };
    floatExp = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node2) {
        const num = Number(node2.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node2);
      }
    };
    float = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node2 = new Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f = str.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node2.minFractionDigits = f.length;
        }
        return node2;
      },
      stringify: stringifyNumber
    };
    intIdentify = (value2) => typeof value2 === "bigint" || Number.isInteger(value2);
    intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
      stringify: (node2) => intStringify(node2, 2, "0b")
    };
    intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
      stringify: (node2) => intStringify(node2, 8, "0")
    };
    int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber
    };
    intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node2) => intStringify(node2, 16, "0x")
    };
    YAMLSet = class extends YAMLMap {
      constructor(schema2) {
        super(schema2);
        this.tag = YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (isPair(key))
          pair = key;
        else if (typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair(key.key, null);
        else
          pair = new Pair(key, null);
        const prev = findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = findPair(this.items, key);
        return !keepPair && isPair(pair) ? isScalar$1(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value2) {
        if (typeof value2 !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value2}`);
        const prev = findPair(this.items, key);
        if (prev && !value2) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value2) {
          this.items.push(new Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    set = {
      collection: "map",
      identify: (value2) => value2 instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      resolve(map2, onError) {
        if (isMap(map2)) {
          if (map2.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map2);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map2;
      },
      createNode(schema2, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new YAMLSet(schema2);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value2 of iterable) {
            if (typeof replacer === "function")
              value2 = replacer.call(iterable, value2, value2);
            set2.items.push(createPair(value2, null, ctx));
          }
        return set2;
      }
    };
    intTime = {
      identify: (value2) => typeof value2 === "bigint" || Number.isInteger(value2),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    floatTime = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    timestamp = {
      identify: (value2) => value2 instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({ value: value2 }) => value2.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    schema = [
      map,
      seq,
      string,
      nullTag,
      trueTag,
      falseTag,
      intBin,
      intOct,
      int,
      intHex,
      floatNaN,
      floatExp,
      float,
      binary,
      omap,
      pairs,
      set,
      intTime,
      floatTime,
      timestamp
    ];
    schemas = /* @__PURE__ */ new Map([
      ["core", schema$2],
      ["failsafe", [map, seq, string]],
      ["json", schema$1],
      ["yaml11", schema],
      ["yaml-1.1", schema]
    ]);
    tagsByName = {
      binary,
      bool: boolTag,
      float: float$1,
      floatExp: floatExp$1,
      floatNaN: floatNaN$1,
      floatTime,
      int: int$1,
      intHex: intHex$1,
      intOct: intOct$1,
      intTime,
      map,
      null: nullTag,
      omap,
      pairs,
      seq,
      set,
      timestamp
    };
    coreKnownTags = {
      "tag:yaml.org,2002:binary": binary,
      "tag:yaml.org,2002:omap": omap,
      "tag:yaml.org,2002:pairs": pairs,
      "tag:yaml.org,2002:set": set,
      "tag:yaml.org,2002:timestamp": timestamp
    };
    sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    Schema = class {
      constructor({ compat, customTags, merge, resolveKnownTags, schema: schema2, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
        this.merge = !!merge;
        this.name = typeof schema2 === "string" && schema2 || "core";
        this.knownTags = resolveKnownTags ? coreKnownTags : {};
        this.tags = getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, MAP, { value: map });
        Object.defineProperty(this, SCALAR$1, { value: string });
        Object.defineProperty(this, SEQ, { value: seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
    Document = class {
      constructor(value2, replacer, options2) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, NODE_TYPE, { value: DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options2 === void 0 && replacer) {
          options2 = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          uniqueKeys: true,
          version: "1.2"
        }, options2);
        this.options = opt;
        let { version: version5 } = opt;
        if (options2?._directives) {
          this.directives = options2._directives.atDocument();
          if (this.directives.yaml.explicit)
            version5 = this.directives.yaml.version;
        } else
          this.directives = new Directives({ version: version5 });
        this.setSchema(version5, options2);
        if (value2 === void 0)
          this.contents = null;
        else {
          this.contents = this.createNode(value2, _replacer, options2);
        }
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(Document.prototype, {
          [NODE_TYPE]: { value: DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = isNode$1(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value2) {
        if (assertCollection(this.contents))
          this.contents.add(value2);
      }
      /** Adds a value to the document. */
      addIn(path4, value2) {
        if (assertCollection(this.contents))
          this.contents.addIn(path4, value2);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node2, name2) {
        if (!node2.anchor) {
          const prev = anchorNames(this);
          node2.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name2 || prev.has(name2) ? findNewAnchor(name2 || "a", prev) : name2;
        }
        return new Alias(node2.anchor);
      }
      createNode(value2, replacer, options2) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value2 = replacer.call({ "": value2 }, "", value2);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options2 === void 0 && replacer) {
          options2 = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options2 ?? {};
        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node2 = createNode(value2, tag, ctx);
        if (flow && isCollection$1(node2))
          node2.flow = true;
        setAnchors();
        return node2;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value2, options2 = {}) {
        const k = this.createNode(key, null, options2);
        const v = this.createNode(value2, null, options2);
        return new Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path4) {
        if (isEmptyPath(path4)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path4) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return isCollection$1(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path4, keepScalar) {
        if (isEmptyPath(path4))
          return !keepScalar && isScalar$1(this.contents) ? this.contents.value : this.contents;
        return isCollection$1(this.contents) ? this.contents.getIn(path4, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return isCollection$1(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path4) {
        if (isEmptyPath(path4))
          return this.contents !== void 0;
        return isCollection$1(this.contents) ? this.contents.hasIn(path4) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value2) {
        if (this.contents == null) {
          this.contents = collectionFromPath(this.schema, [key], value2);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value2);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path4, value2) {
        if (isEmptyPath(path4))
          this.contents = value2;
        else if (this.contents == null) {
          this.contents = collectionFromPath(this.schema, Array.from(path4), value2);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path4, value2);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version5, options2 = {}) {
        if (typeof version5 === "number")
          version5 = String(version5);
        let opt;
        switch (version5) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new Directives({ version: "1.1" });
            opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version5;
            else
              this.directives = new Directives({ version: version5 });
            opt = { merge: false, resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version5);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options2.schema instanceof Object)
          this.schema = options2.schema;
        else if (opt)
          this.schema = new Schema(Object.assign(opt, options2));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100,
          stringify: stringify$2
        };
        const res = toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options2 = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options2 && (!Number.isInteger(options2.indent) || Number(options2.indent) <= 0)) {
          const s = JSON.stringify(options2.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument(this, options2);
      }
    };
    YAMLError = class extends Error {
      constructor(name2, pos, code, message) {
        super();
        this.name = name2;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    prettifyError = (src2, lc) => (error2) => {
      if (error2.pos[0] === -1)
        return;
      error2.linePos = error2.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error2.linePos[0];
      error2.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src2.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src2.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error2.linePos[1];
        if (end && end.line === line && end.col > col) {
          count = Math.min(end.col - col, 80 - ci);
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error2.message += `:

${lineStr}
${pointer}
`;
      }
    };
    startColMsg = "All mapping items must start at the same column";
    blockMsg = "Block collections are not allowed within flow collections";
    isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    escapeCodes = {
      "0": "\0",
      a: "\x07",
      b: "\b",
      e: "\x1B",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	",
      v: "\v",
      N: "\x85",
      _: "\xA0",
      L: "\u2028",
      P: "\u2029",
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    CN = { composeNode, composeEmptyNode };
    Composer = class {
      constructor(options2 = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new YAMLWarning(pos, code, message));
          else
            this.errors.push(new YAMLParseError(pos, code, message));
        };
        this.directives = new Directives({ version: options2.version || "1.2" });
        this.options = options2;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (isCollection$1(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset4, message, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset4;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error2 = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error2);
            else
              this.doc.errors.push(error2);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    stringify$1 = (cst2) => "type" in cst2 ? stringifyToken(cst2) : stringifyItem(cst2);
    BREAK = Symbol("break visit");
    SKIP = Symbol("skip children");
    REMOVE = Symbol("remove item");
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst2, path4) => {
      let item = cst2;
      for (const [field, index] of path4) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index];
        } else
          return void 0;
      }
      return item;
    };
    visit.parentCollection = (cst2, path4) => {
      const parent = visit.itemAtPath(cst2, path4.slice(0, -1));
      const field = path4[path4.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    BOM = "\uFEFF";
    DOCUMENT = "";
    FLOW_END = "";
    SCALAR = "";
    isCollection = (token) => !!token && "items" in token;
    isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    cst = {
      __proto__: null,
      BOM,
      DOCUMENT,
      FLOW_END,
      SCALAR,
      createScalarToken,
      isCollection,
      isScalar,
      prettyToken,
      resolveAsScalar,
      setScalarValue,
      stringify: stringify$1,
      tokenType,
      visit
    };
    hexDigits = "0123456789ABCDEFabcdef".split("");
    tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
    invalidFlowScalarChars = ",[]{}".split("");
    invalidAnchorChars = " ,[]{}\n\r	".split("");
    isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
    Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n2) {
        return this.buffer[this.pos + n2];
      }
      continueScalar(offset4) {
        let ch = this.buffer[offset4];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset4];
          if (ch === "\r") {
            const next = this.buffer[indent + offset4 + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset4 + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset4 + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset4, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset4 + 3]))
            return -1;
        }
        return offset4;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n2) {
        return this.pos + n2 <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n2) {
        return this.buffer.substr(this.pos, n2);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          const cs = line.indexOf("#");
          if (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	")
              dirEnd = cs - 1;
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n2 = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n2);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if (s === "---" && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return "doc";
          } else if (s === "..." && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            return "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n2 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n2;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n2 = yield* this.pushIndicators();
        switch (line[n2]) {
          case "#":
            yield* this.pushCount(line.length - n2);
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n2 += yield* this.parseBlockScalarHeader();
            n2 += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n2);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n2 = 0;
        while (line[n2] === ",") {
          n2 += yield* this.pushCount(1);
          n2 += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n2 += yield* this.pushIndicators();
        switch (line[n2]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n2);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n2 = 0;
            while (this.buffer[end - 1 - n2] === "\\")
              n2 += 1;
            if (n2 % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop:
          for (let i = this.pos; ch = this.buffer[i]; ++i) {
            switch (ch) {
              case " ":
                indent += 1;
                break;
              case "\n":
                nl = i;
                indent = 0;
                break;
              case "\r": {
                const next = this.buffer[i + 1];
                if (!next && !this.atEnd)
                  return this.setNext("block-scalar");
                if (next === "\n")
                  break;
              }
              default:
                break loop;
            }
          }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else
            this.indentNext += this.blockScalarIndent;
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        if (!this.blockScalarKeep) {
          do {
            let i = nl - 1;
            let ch2 = this.buffer[i];
            if (ch2 === "\r")
              ch2 = this.buffer[--i];
            const lastChar = i;
            while (ch2 === " " || ch2 === "	")
              ch2 = this.buffer[--i];
            if (ch2 === "\n" && i >= this.pos && i + 1 + indent > lastChar)
              nl = i;
            else
              break;
          } while (true);
        }
        yield SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next = this.buffer[i + 1];
            if (isEmpty(next) || inFlow && next === ",")
              break;
            end = i;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i += 1;
                ch = "\n";
                next = this.buffer[i + 1];
              } else
                end = i;
            }
            if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && invalidFlowScalarChars.includes(ch))
              break;
            end = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n2) {
        if (n2 > 0) {
          yield this.buffer.substr(this.pos, n2);
          this.pos += n2;
          return n2;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          case "?":
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.includes(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.includes(this.buffer[i + 1]) && hexDigits.includes(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n2 = i - this.pos;
        if (n2 > 0) {
          yield this.buffer.substr(this.pos, n2);
          this.pos = i;
        }
        return n2;
      }
      *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
    LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset4) => this.lineStarts.push(offset4);
        this.linePos = (offset4) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset4)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset4)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset4 };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset4 - start + 1 };
        };
      }
    };
    Parser4 = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n2) {
        return this.stack[this.stack.length - n2];
      }
      *pop(error2) {
        const token = error2 ?? this.stack.pop();
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep2;
          if (scalar.end) {
            sep2 = scalar.end;
            sep2.push(this.sourceToken);
            delete scalar.end;
          } else
            sep2 = [this.sourceToken];
          const map2 = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep: sep2 }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map2;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map2) {
        const it = map2.items[map2.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                map2.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map2.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map2.indent)) {
                const prev = map2.items[map2.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map2.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map2.indent) {
          const atNextItem = !this.onKeyLine && this.indent === map2.indent && it.sep;
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map2.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map2.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !includesToken(it.start, "explicit-key-ind")) {
                it.start.push(this.sourceToken);
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map2.items.push({ start });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken] }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (includesToken(it.start, "explicit-key-ind")) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep2 = it.sep;
                  sep2.push(this.sourceToken);
                  delete it.key, delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep: sep2 }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map2.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs2 = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map2.items.push({ start, key: fs2, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs2);
              } else {
                Object.assign(it, { key: fs2, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map2);
              if (bv) {
                if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind")) {
                  map2.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq2) {
        const it = seq2.items[seq2.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                seq2.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq2.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq2.indent)) {
                const prev = seq2.items[seq2.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq2.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq2.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq2.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq2.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq2.indent) {
          const bv = this.startBlockValue(seq2);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs2 = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs2, sep: [] });
              else if (it.sep)
                this.stack.push(fs2);
              else
                Object.assign(it, { key: fs2, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep2 = fc.end.splice(1, fc.end.length);
            sep2.push(this.sourceToken);
            const map2 = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep: sep2 }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map2;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    YAML = {
      __proto__: null,
      Alias,
      CST: cst,
      Composer,
      Document,
      Lexer,
      LineCounter,
      Pair,
      Parser: Parser4,
      Scalar,
      Schema,
      YAMLError,
      YAMLMap,
      YAMLParseError,
      YAMLSeq,
      YAMLWarning,
      isAlias,
      isCollection: isCollection$1,
      isDocument,
      isMap,
      isNode: isNode$1,
      isPair,
      isScalar: isScalar$1,
      isSeq,
      parse: parse$a,
      parseAllDocuments,
      parseDocument,
      stringify,
      visit: visit$1,
      visitAsync
    };
    browser$1 = {
      __proto__: null,
      Alias,
      CST: cst,
      Composer,
      Document,
      Lexer,
      LineCounter,
      Pair,
      Parser: Parser4,
      Scalar,
      Schema,
      YAMLError,
      YAMLMap,
      YAMLParseError,
      YAMLSeq,
      YAMLWarning,
      default: YAML,
      isAlias,
      isCollection: isCollection$1,
      isDocument,
      isMap,
      isNode: isNode$1,
      isPair,
      isScalar: isScalar$1,
      isSeq,
      parse: parse$a,
      parseAllDocuments,
      parseDocument,
      stringify,
      visit: visit$1,
      visitAsync
    };
    require$$3$1 = /* @__PURE__ */ getAugmentedNamespace(browser$1);
    ({ createRequire, createRequireFromPath } = import_module.default);
    req_1 = req$2;
    req$1 = req_1;
    options = (config2, file) => {
      if (config2.parser && typeof config2.parser === "string") {
        try {
          config2.parser = req$1(config2.parser, file);
        } catch (err) {
          throw new Error(`Loading PostCSS Parser failed: ${err.message}

(@${file})`);
        }
      }
      if (config2.syntax && typeof config2.syntax === "string") {
        try {
          config2.syntax = req$1(config2.syntax, file);
        } catch (err) {
          throw new Error(`Loading PostCSS Syntax failed: ${err.message}

(@${file})`);
        }
      }
      if (config2.stringifier && typeof config2.stringifier === "string") {
        try {
          config2.stringifier = req$1(config2.stringifier, file);
        } catch (err) {
          throw new Error(`Loading PostCSS Stringifier failed: ${err.message}

(@${file})`);
        }
      }
      if (config2.plugins) {
        delete config2.plugins;
      }
      return config2;
    };
    options_1 = options;
    req = req_1;
    load = (plugin, options2, file) => {
      try {
        if (options2 === null || options2 === void 0 || Object.keys(options2).length === 0) {
          return req(plugin, file);
        } else {
          return req(plugin, file)(options2);
        }
      } catch (err) {
        throw new Error(`Loading PostCSS Plugin failed: ${err.message}

(@${file})`);
      }
    };
    plugins = (config2, file) => {
      let plugins2 = [];
      if (Array.isArray(config2.plugins)) {
        plugins2 = config2.plugins.filter(Boolean);
      } else {
        plugins2 = Object.keys(config2.plugins).filter((plugin) => {
          return config2.plugins[plugin] !== false ? plugin : "";
        }).map((plugin) => {
          return load(plugin, config2.plugins[plugin], file);
        });
      }
      if (plugins2.length && plugins2.length > 0) {
        plugins2.forEach((plugin, i) => {
          if (plugin.default) {
            plugin = plugin.default;
          }
          if (plugin.postcss === true) {
            plugin = plugin();
          } else if (plugin.postcss) {
            plugin = plugin.postcss;
          }
          if (
            // eslint-disable-next-line
            !(typeof plugin === "object" && Array.isArray(plugin.plugins) || typeof plugin === "object" && plugin.postcssPlugin || typeof plugin === "function")
          ) {
            throw new TypeError(`Invalid PostCSS Plugin found at: plugins[${i}]

(@${file})`);
          }
        });
      }
      return plugins2;
    };
    plugins_1 = plugins;
    resolve3 = import_path2.default.resolve;
    url$4 = import_url.default;
    config$1 = dist;
    yaml = require$$3$1;
    loadOptions = options_1;
    loadPlugins = plugins_1;
    interopRequireDefault = (obj) => obj && obj.__esModule ? obj : { default: obj };
    processResult = (ctx, result) => {
      const file = result.filepath || "";
      let config2 = interopRequireDefault(result.config).default || {};
      if (typeof config2 === "function") {
        config2 = config2(ctx);
      } else {
        config2 = Object.assign({}, config2, ctx);
      }
      if (!config2.plugins) {
        config2.plugins = [];
      }
      return {
        plugins: loadPlugins(config2, file),
        options: loadOptions(config2, file),
        file
      };
    };
    createContext = (ctx) => {
      ctx = Object.assign({
        cwd: process.cwd(),
        env: process.env.NODE_ENV
      }, ctx);
      if (!ctx.env) {
        process.env.NODE_ENV = "development";
      }
      return ctx;
    };
    importDefault = async (filepath) => {
      const module2 = await import(url$4.pathToFileURL(filepath).href);
      return module2.default;
    };
    addTypeScriptLoader = (options2 = {}, loader) => {
      const moduleName = "postcss";
      return {
        ...options2,
        searchPlaces: [
          ...options2.searchPlaces || [],
          "package.json",
          `.${moduleName}rc`,
          `.${moduleName}rc.json`,
          `.${moduleName}rc.yaml`,
          `.${moduleName}rc.yml`,
          `.${moduleName}rc.ts`,
          `.${moduleName}rc.js`,
          `.${moduleName}rc.cjs`,
          `.${moduleName}rc.mjs`,
          `${moduleName}.config.ts`,
          `${moduleName}.config.js`,
          `${moduleName}.config.cjs`,
          `${moduleName}.config.mjs`
        ],
        loaders: {
          ...options2.loaders,
          ".yaml": (filepath, content) => yaml.parse(content),
          ".yml": (filepath, content) => yaml.parse(content),
          ".js": importDefault,
          ".cjs": importDefault,
          ".mjs": importDefault,
          ".ts": loader
        }
      };
    };
    withTypeScriptLoader = (rcFunc) => {
      return (ctx, path4, options2) => {
        return rcFunc(ctx, path4, addTypeScriptLoader(options2, (configFile) => {
          let registerer = { enabled() {
          } };
          try {
            registerer = __require("ts-node").register();
            return __require(configFile);
          } catch (err) {
            if (err.code === "MODULE_NOT_FOUND") {
              throw new Error(
                `'ts-node' is required for the TypeScript configuration files. Make sure it is installed
Error: ${err.message}`
              );
            }
            throw err;
          } finally {
            registerer.enabled(false);
          }
        }));
      };
    };
    rc = withTypeScriptLoader((ctx, path4, options2) => {
      ctx = createContext(ctx);
      path4 = path4 ? resolve3(path4) : process.cwd();
      return config$1.lilconfig("postcss", options2).search(path4).then((result) => {
        if (!result) {
          throw new Error(`No PostCSS Config found in: ${path4}`);
        }
        return processResult(ctx, result);
      });
    });
    mainExports = {};
    main$1 = {
      get exports() {
        return mainExports;
      },
      set exports(v) {
        mainExports = v;
      }
    };
    name = "dotenv";
    version$12 = "16.0.3";
    description = "Loads environment variables from .env file";
    main = "lib/main.js";
    types2 = "lib/main.d.ts";
    exports = {
      ".": {
        require: "./lib/main.js",
        types: "./lib/main.d.ts",
        "default": "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    };
    scripts = {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      "lint-readme": "standard-markdown",
      pretest: "npm run lint && npm run dts-check",
      test: "tap tests/*.js --100 -Rspec",
      prerelease: "npm test",
      release: "standard-version"
    };
    repository = {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    };
    keywords2 = [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ];
    readmeFilename = "README.md";
    license = "BSD-2-Clause";
    devDependencies = {
      "@types/node": "^17.0.9",
      decache: "^4.6.1",
      dtslint: "^3.7.0",
      sinon: "^12.0.1",
      standard: "^16.0.4",
      "standard-markdown": "^7.1.0",
      "standard-version": "^9.3.2",
      tap: "^15.1.6",
      tar: "^6.1.11",
      typescript: "^4.5.4"
    };
    engines = {
      node: ">=12"
    };
    require$$3 = {
      name,
      version: version$12,
      description,
      main,
      types: types2,
      exports,
      scripts,
      repository,
      keywords: keywords2,
      readmeFilename,
      license,
      devDependencies,
      engines
    };
    fs$9 = import_fs.default;
    path$9 = import_path2.default;
    os$2 = import_os.default;
    packageJson = require$$3;
    version3 = packageJson.version;
    LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    DotenvModule = {
      config,
      parse: parse$9
    };
    mainExports.config = DotenvModule.config;
    parse_1$1 = mainExports.parse = DotenvModule.parse;
    main$1.exports = DotenvModule;
    modulePreloadPolyfillId = "vite/modulepreload-polyfill";
    resolvedModulePreloadPolyfillId = "\0" + modulePreloadPolyfillId;
    moduleScriptRE = /[ \t]*<script[^>]*type\s*=\s*(?:"module"|'module'|module)[^>]*>/i;
    modulePreloadLinkRE = /[ \t]*<link[^>]*rel\s*=\s*(?:"modulepreload"|'modulepreload'|modulepreload)[\s\S]*?\/>/i;
    importMapAppendRE = new RegExp([moduleScriptRE, modulePreloadLinkRE].map((r) => r.source).join("|"), "i");
    cssModuleRE = new RegExp(`\\.module${CSS_LANGS_RE.source}`);
    varRE = /^var\(/i;
    cssUrlRE = /(?<=^|[^\w\-\u0080-\uffff])url\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/;
    cssDataUriRE = /(?<=^|[^\w\-\u0080-\uffff])data-uri\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/;
    importCssRE = /@import ('[^']+\.css'|"[^"]+\.css"|[^'")]+\.css)/;
    cssImageSetRE = /(?<=image-set\()((?:[\w\-]{1,256}\([^)]*\)|[^)])*)(?=\))/;
    UrlRewritePostcssPlugin = (opts) => {
      if (!opts) {
        throw new Error("base or replace is required");
      }
      return {
        postcssPlugin: "vite-url-rewrite",
        Once(root) {
          const promises2 = [];
          root.walkDecls((declaration) => {
            const importer = declaration.source?.input.file;
            if (!importer) {
              opts.logger.warnOnce("\nA PostCSS plugin did not pass the `from` option to `postcss.parse`. This may cause imported assets to be incorrectly transformed. If you've recently added a PostCSS plugin that raised this warning, please contact the package author to fix the issue.");
            }
            const isCssUrl = cssUrlRE.test(declaration.value);
            const isCssImageSet = cssImageSetRE.test(declaration.value);
            if (isCssUrl || isCssImageSet) {
              const replacerForDeclaration = (rawUrl) => {
                return opts.replacer(rawUrl, importer);
              };
              const rewriterToUse = isCssImageSet ? rewriteCssImageSet : rewriteCssUrls;
              promises2.push(rewriterToUse(declaration.value, replacerForDeclaration).then((url2) => {
                declaration.value = url2;
              }));
            }
          });
          if (promises2.length) {
            return Promise.all(promises2);
          }
        }
      };
    };
    UrlRewritePostcssPlugin.postcss = true;
    cssNotProcessedRE = /(?:gradient|element|cross-fade|image)\(/;
    loadedPreprocessors = {};
    _require$1 = (0, import_node_module.createRequire)(import_meta2.url);
    scss = async (source, root, options2, resolvers) => {
      const render = loadPreprocessor("sass", root).render;
      const internalImporter = (url2, importer2, done) => {
        importer2 = cleanScssBugUrl(importer2);
        resolvers.sass(url2, importer2).then((resolved) => {
          if (resolved) {
            rebaseUrls(resolved, options2.filename, options2.alias, "$").then((data4) => done?.(fixScssBugImportValue(data4))).catch((data4) => done?.(data4));
          } else {
            done?.(null);
          }
        });
      };
      const importer = [internalImporter];
      if (options2.importer) {
        Array.isArray(options2.importer) ? importer.unshift(...options2.importer) : importer.unshift(options2.importer);
      }
      const { content: data3, map: additionalMap } = await getSource(source, options2.filename, options2.additionalData, options2.enableSourcemap);
      const finalOptions = {
        ...options2,
        data: data3,
        file: options2.filename,
        outFile: options2.filename,
        importer,
        ...options2.enableSourcemap ? {
          sourceMap: true,
          omitSourceMapUrl: true,
          sourceMapRoot: import_node_path4.default.dirname(options2.filename)
        } : {}
      };
      try {
        const result = await new Promise((resolve5, reject) => {
          render(finalOptions, (err, res) => {
            if (err) {
              reject(err);
            } else {
              resolve5(res);
            }
          });
        });
        const deps = result.stats.includedFiles.map((f) => cleanScssBugUrl(f));
        const map2 = result.map ? JSON.parse(result.map.toString()) : void 0;
        return {
          code: result.css.toString(),
          map: map2,
          additionalMap,
          deps
        };
      } catch (e) {
        e.message = `[sass] ${e.message}`;
        e.id = e.file;
        e.frame = e.formatted;
        return { code: "", error: e, deps: [] };
      }
    };
    sass = (source, root, options2, aliasResolver) => scss(source, root, {
      ...options2,
      indentedSyntax: true
    }, aliasResolver);
    less = async (source, root, options2, resolvers) => {
      const nodeLess = loadPreprocessor("less", root);
      const viteResolverPlugin = createViteLessPlugin(nodeLess, options2.filename, options2.alias, resolvers);
      const { content, map: additionalMap } = await getSource(source, options2.filename, options2.additionalData, options2.enableSourcemap);
      let result;
      try {
        result = await nodeLess.render(content, {
          ...options2,
          plugins: [viteResolverPlugin, ...options2.plugins || []],
          ...options2.enableSourcemap ? {
            sourceMap: {
              outputSourceFiles: true,
              sourceMapFileInline: false
            }
          } : {}
        });
      } catch (e) {
        const error2 = e;
        const normalizedError = new Error(`[less] ${error2.message || error2.type}`);
        normalizedError.loc = {
          file: error2.filename || options2.filename,
          line: error2.line,
          column: error2.column
        };
        return { code: "", error: normalizedError, deps: [] };
      }
      const map2 = result.map && JSON.parse(result.map);
      if (map2) {
        delete map2.sourcesContent;
      }
      return {
        code: result.css.toString(),
        map: map2,
        additionalMap,
        deps: result.imports
      };
    };
    styl = async (source, root, options2) => {
      const nodeStylus = loadPreprocessor("stylus", root);
      const { content, map: additionalMap } = await getSource(source, options2.filename, options2.additionalData, options2.enableSourcemap, "\n");
      const importsDeps = (options2.imports ?? []).map((dep) => import_node_path4.default.resolve(dep));
      try {
        const ref3 = nodeStylus(content, options2);
        if (options2.define) {
          for (const key in options2.define) {
            ref3.define(key, options2.define[key]);
          }
        }
        if (options2.enableSourcemap) {
          ref3.set("sourcemap", {
            comment: false,
            inline: false,
            basePath: root
          });
        }
        const result = ref3.render();
        const deps = [...ref3.deps(), ...importsDeps];
        const map2 = ref3.sourcemap;
        return {
          code: result,
          map: formatStylusSourceMap(map2, root),
          additionalMap,
          deps
        };
      } catch (e) {
        e.message = `[stylus] ${e.message}`;
        return { code: "", error: e, deps: [] };
      }
    };
    preProcessors = Object.freeze({
      [
        "less"
        /* PreprocessLang.less */
      ]: less,
      [
        "sass"
        /* PreprocessLang.sass */
      ]: sass,
      [
        "scss"
        /* PreprocessLang.scss */
      ]: scss,
      [
        "styl"
        /* PreprocessLang.styl */
      ]: styl,
      [
        "stylus"
        /* PreprocessLang.stylus */
      ]: styl
    });
    base2 = {};
    base2.Program = base2.BlockStatement = base2.StaticBlock = function(node2, st, c) {
      for (var i = 0, list = node2.body; i < list.length; i += 1) {
        var stmt = list[i];
        c(stmt, st, "Statement");
      }
    };
    base2.Statement = skipThrough2;
    base2.EmptyStatement = ignore2;
    base2.ExpressionStatement = base2.ParenthesizedExpression = base2.ChainExpression = function(node2, st, c) {
      return c(node2.expression, st, "Expression");
    };
    base2.IfStatement = function(node2, st, c) {
      c(node2.test, st, "Expression");
      c(node2.consequent, st, "Statement");
      if (node2.alternate) {
        c(node2.alternate, st, "Statement");
      }
    };
    base2.LabeledStatement = function(node2, st, c) {
      return c(node2.body, st, "Statement");
    };
    base2.BreakStatement = base2.ContinueStatement = ignore2;
    base2.WithStatement = function(node2, st, c) {
      c(node2.object, st, "Expression");
      c(node2.body, st, "Statement");
    };
    base2.SwitchStatement = function(node2, st, c) {
      c(node2.discriminant, st, "Expression");
      for (var i$1 = 0, list$1 = node2.cases; i$1 < list$1.length; i$1 += 1) {
        var cs = list$1[i$1];
        if (cs.test) {
          c(cs.test, st, "Expression");
        }
        for (var i = 0, list = cs.consequent; i < list.length; i += 1) {
          var cons = list[i];
          c(cons, st, "Statement");
        }
      }
    };
    base2.SwitchCase = function(node2, st, c) {
      if (node2.test) {
        c(node2.test, st, "Expression");
      }
      for (var i = 0, list = node2.consequent; i < list.length; i += 1) {
        var cons = list[i];
        c(cons, st, "Statement");
      }
    };
    base2.ReturnStatement = base2.YieldExpression = base2.AwaitExpression = function(node2, st, c) {
      if (node2.argument) {
        c(node2.argument, st, "Expression");
      }
    };
    base2.ThrowStatement = base2.SpreadElement = function(node2, st, c) {
      return c(node2.argument, st, "Expression");
    };
    base2.TryStatement = function(node2, st, c) {
      c(node2.block, st, "Statement");
      if (node2.handler) {
        c(node2.handler, st);
      }
      if (node2.finalizer) {
        c(node2.finalizer, st, "Statement");
      }
    };
    base2.CatchClause = function(node2, st, c) {
      if (node2.param) {
        c(node2.param, st, "Pattern");
      }
      c(node2.body, st, "Statement");
    };
    base2.WhileStatement = base2.DoWhileStatement = function(node2, st, c) {
      c(node2.test, st, "Expression");
      c(node2.body, st, "Statement");
    };
    base2.ForStatement = function(node2, st, c) {
      if (node2.init) {
        c(node2.init, st, "ForInit");
      }
      if (node2.test) {
        c(node2.test, st, "Expression");
      }
      if (node2.update) {
        c(node2.update, st, "Expression");
      }
      c(node2.body, st, "Statement");
    };
    base2.ForInStatement = base2.ForOfStatement = function(node2, st, c) {
      c(node2.left, st, "ForInit");
      c(node2.right, st, "Expression");
      c(node2.body, st, "Statement");
    };
    base2.ForInit = function(node2, st, c) {
      if (node2.type === "VariableDeclaration") {
        c(node2, st);
      } else {
        c(node2, st, "Expression");
      }
    };
    base2.DebuggerStatement = ignore2;
    base2.FunctionDeclaration = function(node2, st, c) {
      return c(node2, st, "Function");
    };
    base2.VariableDeclaration = function(node2, st, c) {
      for (var i = 0, list = node2.declarations; i < list.length; i += 1) {
        var decl = list[i];
        c(decl, st);
      }
    };
    base2.VariableDeclarator = function(node2, st, c) {
      c(node2.id, st, "Pattern");
      if (node2.init) {
        c(node2.init, st, "Expression");
      }
    };
    base2.Function = function(node2, st, c) {
      if (node2.id) {
        c(node2.id, st, "Pattern");
      }
      for (var i = 0, list = node2.params; i < list.length; i += 1) {
        var param = list[i];
        c(param, st, "Pattern");
      }
      c(node2.body, st, node2.expression ? "Expression" : "Statement");
    };
    base2.Pattern = function(node2, st, c) {
      if (node2.type === "Identifier") {
        c(node2, st, "VariablePattern");
      } else if (node2.type === "MemberExpression") {
        c(node2, st, "MemberPattern");
      } else {
        c(node2, st);
      }
    };
    base2.VariablePattern = ignore2;
    base2.MemberPattern = skipThrough2;
    base2.RestElement = function(node2, st, c) {
      return c(node2.argument, st, "Pattern");
    };
    base2.ArrayPattern = function(node2, st, c) {
      for (var i = 0, list = node2.elements; i < list.length; i += 1) {
        var elt = list[i];
        if (elt) {
          c(elt, st, "Pattern");
        }
      }
    };
    base2.ObjectPattern = function(node2, st, c) {
      for (var i = 0, list = node2.properties; i < list.length; i += 1) {
        var prop = list[i];
        if (prop.type === "Property") {
          if (prop.computed) {
            c(prop.key, st, "Expression");
          }
          c(prop.value, st, "Pattern");
        } else if (prop.type === "RestElement") {
          c(prop.argument, st, "Pattern");
        }
      }
    };
    base2.Expression = skipThrough2;
    base2.ThisExpression = base2.Super = base2.MetaProperty = ignore2;
    base2.ArrayExpression = function(node2, st, c) {
      for (var i = 0, list = node2.elements; i < list.length; i += 1) {
        var elt = list[i];
        if (elt) {
          c(elt, st, "Expression");
        }
      }
    };
    base2.ObjectExpression = function(node2, st, c) {
      for (var i = 0, list = node2.properties; i < list.length; i += 1) {
        var prop = list[i];
        c(prop, st);
      }
    };
    base2.FunctionExpression = base2.ArrowFunctionExpression = base2.FunctionDeclaration;
    base2.SequenceExpression = function(node2, st, c) {
      for (var i = 0, list = node2.expressions; i < list.length; i += 1) {
        var expr = list[i];
        c(expr, st, "Expression");
      }
    };
    base2.TemplateLiteral = function(node2, st, c) {
      for (var i = 0, list = node2.quasis; i < list.length; i += 1) {
        var quasi = list[i];
        c(quasi, st);
      }
      for (var i$1 = 0, list$1 = node2.expressions; i$1 < list$1.length; i$1 += 1) {
        var expr = list$1[i$1];
        c(expr, st, "Expression");
      }
    };
    base2.TemplateElement = ignore2;
    base2.UnaryExpression = base2.UpdateExpression = function(node2, st, c) {
      c(node2.argument, st, "Expression");
    };
    base2.BinaryExpression = base2.LogicalExpression = function(node2, st, c) {
      c(node2.left, st, "Expression");
      c(node2.right, st, "Expression");
    };
    base2.AssignmentExpression = base2.AssignmentPattern = function(node2, st, c) {
      c(node2.left, st, "Pattern");
      c(node2.right, st, "Expression");
    };
    base2.ConditionalExpression = function(node2, st, c) {
      c(node2.test, st, "Expression");
      c(node2.consequent, st, "Expression");
      c(node2.alternate, st, "Expression");
    };
    base2.NewExpression = base2.CallExpression = function(node2, st, c) {
      c(node2.callee, st, "Expression");
      if (node2.arguments) {
        for (var i = 0, list = node2.arguments; i < list.length; i += 1) {
          var arg = list[i];
          c(arg, st, "Expression");
        }
      }
    };
    base2.MemberExpression = function(node2, st, c) {
      c(node2.object, st, "Expression");
      if (node2.computed) {
        c(node2.property, st, "Expression");
      }
    };
    base2.ExportNamedDeclaration = base2.ExportDefaultDeclaration = function(node2, st, c) {
      if (node2.declaration) {
        c(node2.declaration, st, node2.type === "ExportNamedDeclaration" || node2.declaration.id ? "Statement" : "Expression");
      }
      if (node2.source) {
        c(node2.source, st, "Expression");
      }
    };
    base2.ExportAllDeclaration = function(node2, st, c) {
      if (node2.exported) {
        c(node2.exported, st);
      }
      c(node2.source, st, "Expression");
    };
    base2.ImportDeclaration = function(node2, st, c) {
      for (var i = 0, list = node2.specifiers; i < list.length; i += 1) {
        var spec = list[i];
        c(spec, st);
      }
      c(node2.source, st, "Expression");
    };
    base2.ImportExpression = function(node2, st, c) {
      c(node2.source, st, "Expression");
    };
    base2.ImportSpecifier = base2.ImportDefaultSpecifier = base2.ImportNamespaceSpecifier = base2.Identifier = base2.PrivateIdentifier = base2.Literal = ignore2;
    base2.TaggedTemplateExpression = function(node2, st, c) {
      c(node2.tag, st, "Expression");
      c(node2.quasi, st, "Expression");
    };
    base2.ClassDeclaration = base2.ClassExpression = function(node2, st, c) {
      return c(node2, st, "Class");
    };
    base2.Class = function(node2, st, c) {
      if (node2.id) {
        c(node2.id, st, "Pattern");
      }
      if (node2.superClass) {
        c(node2.superClass, st, "Expression");
      }
      c(node2.body, st);
    };
    base2.ClassBody = function(node2, st, c) {
      for (var i = 0, list = node2.body; i < list.length; i += 1) {
        var elt = list[i];
        c(elt, st);
      }
    };
    base2.MethodDefinition = base2.PropertyDefinition = base2.Property = function(node2, st, c) {
      if (node2.computed) {
        c(node2.key, st, "Expression");
      }
      if (node2.value) {
        c(node2.value, st, "Expression");
      }
    };
    ({ isMatch: isMatch$1, scan: scan2 } = micromatch_1);
    ({ basename: basename2, dirname: dirname2, relative: relative2, join } = import_node_path4.posix);
    debugHmr = createDebugger("vite:hmr");
    normalizedClientDir = normalizePath$3(CLIENT_DIR);
    Stats = import_fs.default.Stats;
    convertSourceMap = {};
    (function(exports2) {
      Object.defineProperty(exports2, "commentRegex", {
        get: function getCommentRegex() {
          return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;
        }
      });
      Object.defineProperty(exports2, "mapFileCommentRegex", {
        get: function getMapFileCommentRegex() {
          return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg;
        }
      });
      var decodeBase64;
      if (typeof Buffer !== "undefined") {
        if (typeof Buffer.from === "function") {
          decodeBase64 = decodeBase64WithBufferFrom;
        } else {
          decodeBase64 = decodeBase64WithNewBuffer;
        }
      } else {
        decodeBase64 = decodeBase64WithAtob;
      }
      function decodeBase64WithBufferFrom(base64) {
        return Buffer.from(base64, "base64").toString();
      }
      function decodeBase64WithNewBuffer(base64) {
        if (typeof value === "number") {
          throw new TypeError("The value to decode must not be of type number.");
        }
        return new Buffer(base64, "base64").toString();
      }
      function decodeBase64WithAtob(base64) {
        return decodeURIComponent(escape(atob(base64)));
      }
      function stripComment(sm) {
        return sm.split(",").pop();
      }
      function readFromFileMap(sm, read2) {
        var r = exports2.mapFileCommentRegex.exec(sm);
        var filename = r[1] || r[2];
        try {
          var sm = read2(filename);
          if (sm != null && typeof sm.catch === "function") {
            return sm.catch(throwError);
          } else {
            return sm;
          }
        } catch (e) {
          throwError(e);
        }
        function throwError(e) {
          throw new Error("An error occurred while trying to read the map file at " + filename + "\n" + e.stack);
        }
      }
      function Converter(sm, opts) {
        opts = opts || {};
        if (opts.hasComment) {
          sm = stripComment(sm);
        }
        if (opts.encoding === "base64") {
          sm = decodeBase64(sm);
        } else if (opts.encoding === "uri") {
          sm = decodeURIComponent(sm);
        }
        if (opts.isJSON || opts.encoding) {
          sm = JSON.parse(sm);
        }
        this.sourcemap = sm;
      }
      Converter.prototype.toJSON = function(space2) {
        return JSON.stringify(this.sourcemap, null, space2);
      };
      if (typeof Buffer !== "undefined") {
        if (typeof Buffer.from === "function") {
          Converter.prototype.toBase64 = encodeBase64WithBufferFrom;
        } else {
          Converter.prototype.toBase64 = encodeBase64WithNewBuffer;
        }
      } else {
        Converter.prototype.toBase64 = encodeBase64WithBtoa;
      }
      function encodeBase64WithBufferFrom() {
        var json = this.toJSON();
        return Buffer.from(json, "utf8").toString("base64");
      }
      function encodeBase64WithNewBuffer() {
        var json = this.toJSON();
        if (typeof json === "number") {
          throw new TypeError("The json to encode must not be of type number.");
        }
        return new Buffer(json, "utf8").toString("base64");
      }
      function encodeBase64WithBtoa() {
        var json = this.toJSON();
        return btoa(unescape(encodeURIComponent(json)));
      }
      Converter.prototype.toURI = function() {
        var json = this.toJSON();
        return encodeURIComponent(json);
      };
      Converter.prototype.toComment = function(options2) {
        var encoding, content, data3;
        if (options2 != null && options2.encoding === "uri") {
          encoding = "";
          content = this.toURI();
        } else {
          encoding = ";base64";
          content = this.toBase64();
        }
        data3 = "sourceMappingURL=data:application/json;charset=utf-8" + encoding + "," + content;
        return options2 != null && options2.multiline ? "/*# " + data3 + " */" : "//# " + data3;
      };
      Converter.prototype.toObject = function() {
        return JSON.parse(this.toJSON());
      };
      Converter.prototype.addProperty = function(key, value2) {
        if (this.sourcemap.hasOwnProperty(key))
          throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
        return this.setProperty(key, value2);
      };
      Converter.prototype.setProperty = function(key, value2) {
        this.sourcemap[key] = value2;
        return this;
      };
      Converter.prototype.getProperty = function(key) {
        return this.sourcemap[key];
      };
      exports2.fromObject = function(obj) {
        return new Converter(obj);
      };
      exports2.fromJSON = function(json) {
        return new Converter(json, { isJSON: true });
      };
      exports2.fromURI = function(uri) {
        return new Converter(uri, { encoding: "uri" });
      };
      exports2.fromBase64 = function(base64) {
        return new Converter(base64, { encoding: "base64" });
      };
      exports2.fromComment = function(comment) {
        var m, encoding;
        comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
        m = exports2.commentRegex.exec(comment);
        encoding = m && m[4] || "uri";
        return new Converter(comment, { encoding, hasComment: true });
      };
      function makeConverter(sm) {
        return new Converter(sm, { isJSON: true });
      }
      exports2.fromMapFileComment = function(comment, read2) {
        if (typeof read2 === "string") {
          throw new Error(
            "String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading"
          );
        }
        var sm = readFromFileMap(comment, read2);
        if (sm != null && typeof sm.then === "function") {
          return sm.then(makeConverter);
        } else {
          return makeConverter(sm);
        }
      };
      exports2.fromSource = function(content) {
        var m = content.match(exports2.commentRegex);
        return m ? exports2.fromComment(m.pop()) : null;
      };
      exports2.fromMapFileSource = function(content, read2) {
        if (typeof read2 === "string") {
          throw new Error(
            "String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading"
          );
        }
        var m = content.match(exports2.mapFileCommentRegex);
        return m ? exports2.fromMapFileComment(m.pop(), read2) : null;
      };
      exports2.removeComments = function(src2) {
        return src2.replace(exports2.commentRegex, "");
      };
      exports2.removeMapFileComments = function(src2) {
        return src2.replace(exports2.mapFileCommentRegex, "");
      };
      exports2.generateMapFileComment = function(file, options2) {
        var data3 = "sourceMappingURL=" + file;
        return options2 && options2.multiline ? "/*# " + data3 + " */" : "//# " + data3;
      };
    })(convertSourceMap);
    debugLoad = createDebugger("vite:load");
    debugTransform = createDebugger("vite:transform");
    debugCache$1 = createDebugger("vite:cache");
    isDebug$2 = !!process.env.DEBUG;
    isDebug$1 = !!process.env.DEBUG;
    debug$9 = createDebugger("vite:import-analysis");
    clientDir = normalizePath$3(CLIENT_DIR);
    normalizedClientEntry = normalizePath$3(CLIENT_ENTRY);
    normalizedEnvEntry = normalizePath$3(ENV_ENTRY);
    wasmHelper = async (opts = {}, url2) => {
      let result;
      if (url2.startsWith("data:")) {
        const urlContent = url2.replace(/^data:.*?base64,/, "");
        let bytes;
        if (typeof Buffer === "function" && typeof Buffer.from === "function") {
          bytes = Buffer.from(urlContent, "base64");
        } else if (typeof atob === "function") {
          const binaryString = atob(urlContent);
          bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
        } else {
          throw new Error("Failed to decode base64-encoded data URL, Buffer and atob are not supported");
        }
        result = await WebAssembly.instantiate(bytes, opts);
      } else {
        const response = await fetch(url2);
        const contentType = response.headers.get("Content-Type") || "";
        if ("instantiateStreaming" in WebAssembly && contentType.startsWith("application/wasm")) {
          result = await WebAssembly.instantiateStreaming(response, opts);
        } else {
          const buffer = await response.arrayBuffer();
          result = await WebAssembly.instantiate(buffer, opts);
        }
      }
      return result.instance;
    };
    wasmHelperCode = wasmHelper.toString();
    debug$8 = createDebugger("vite:deps");
    isDebugEnabled$1 = _debug("vite:deps").enabled;
    debuggerViteDeps = createDebugger("vite:deps");
    isDebugEnabled = _debug("vite:deps").enabled;
    MAX_TEMP_DIR_AGE_MS = 24 * 60 * 60 * 1e3;
    preloadMarker = `__VITE_PRELOAD__`;
    preloadMarkerWithQuote = `"${preloadMarker}"`;
    srcExports = {};
    src = {
      get exports() {
        return srcExports;
      },
      set exports(v) {
        srcExports = v;
      }
    };
    browserExports = {};
    browser = {
      get exports() {
        return browserExports;
      },
      set exports(v) {
        browserExports = v;
      }
    };
    debugExports = {};
    debug$6 = {
      get exports() {
        return debugExports;
      },
      set exports(v) {
        debugExports = v;
      }
    };
    nodeExports = {};
    node = {
      get exports() {
        return nodeExports;
      },
      set exports(v) {
        nodeExports = v;
      }
    };
    (function(module2) {
      if (typeof process !== "undefined" && process.type === "renderer") {
        module2.exports = requireBrowser();
      } else {
        module2.exports = requireNode();
      }
    })(src);
    encodeurl = encodeUrl$1;
    ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
    UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
    UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
    matchHtmlRegExp = /["'&<>]/;
    escapeHtml_1 = escapeHtml$1;
    onFinishedExports = {};
    onFinished$2 = {
      get exports() {
        return onFinishedExports;
      },
      set exports(v) {
        onFinishedExports = v;
      }
    };
    eeFirst = first$1;
    onFinished$2.exports = onFinished$1;
    onFinishedExports.isFinished = isFinished$1;
    first = eeFirst;
    defer$2 = typeof setImmediate === "function" ? setImmediate : function(fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    parseurlExports = {};
    parseurl$1 = {
      get exports() {
        return parseurlExports;
      },
      set exports(v) {
        parseurlExports = v;
      }
    };
    url$3 = import_url.default;
    parse$7 = url$3.parse;
    Url = url$3.Url;
    parseurl$1.exports = parseurl;
    parseurlExports.original = originalurl;
    require$$0$12 = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "306": "(Unused)",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Unordered Collection",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
    codes = require$$0$12;
    statuses$1 = status;
    status.STATUS_CODES = codes;
    status.codes = populateStatusesMap(status, codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    unpipe_1 = unpipe$1;
    debug$5 = srcExports("finalhandler");
    encodeUrl = encodeurl;
    escapeHtml = escapeHtml_1;
    onFinished = onFinishedExports;
    parseUrl$1 = parseurlExports;
    statuses = statuses$1;
    unpipe = unpipe_1;
    DOUBLE_SPACE_REGEXP = /\x20{2}/g;
    NEWLINE_REGEXP = /\n/g;
    defer$1 = typeof setImmediate === "function" ? setImmediate : function(fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    isFinished = onFinished.isFinished;
    finalhandler_1 = finalhandler$1;
    utilsMergeExports = {};
    utilsMerge = {
      get exports() {
        return utilsMergeExports;
      },
      set exports(v) {
        utilsMergeExports = v;
      }
    };
    (function(module2, exports2) {
      module2.exports = function(a, b) {
        if (a && b) {
          for (var key in b) {
            a[key] = b[key];
          }
        }
        return a;
      };
    })(utilsMerge);
    debug$4 = srcExports("connect:dispatcher");
    EventEmitter$3 = import_events.default.EventEmitter;
    finalhandler = finalhandler_1;
    http$4 = import_http.default;
    parseUrl = parseurlExports;
    env2 = process.env.NODE_ENV || "development";
    proto = {};
    defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    proto.use = function use(route, fn) {
      var handle2 = fn;
      var path4 = route;
      if (typeof route !== "string") {
        handle2 = route;
        path4 = "/";
      }
      if (typeof handle2.handle === "function") {
        var server = handle2;
        server.route = path4;
        handle2 = function(req2, res, next) {
          server.handle(req2, res, next);
        };
      }
      if (handle2 instanceof http$4.Server) {
        handle2 = handle2.listeners("request")[0];
      }
      if (path4[path4.length - 1] === "/") {
        path4 = path4.slice(0, -1);
      }
      debug$4("use %s %s", path4 || "/", handle2.name || "anonymous");
      this.stack.push({ route: path4, handle: handle2 });
      return this;
    };
    proto.handle = function handle(req2, res, out) {
      var index = 0;
      var protohost = getProtohost(req2.url) || "";
      var removed = "";
      var slashAdded = false;
      var stack = this.stack;
      var done = out || finalhandler(req2, res, {
        env: env2,
        onerror: logerror
      });
      req2.originalUrl = req2.originalUrl || req2.url;
      function next(err) {
        if (slashAdded) {
          req2.url = req2.url.substr(1);
          slashAdded = false;
        }
        if (removed.length !== 0) {
          req2.url = protohost + removed + req2.url.substr(protohost.length);
          removed = "";
        }
        var layer = stack[index++];
        if (!layer) {
          defer(done, err);
          return;
        }
        var path4 = parseUrl(req2).pathname || "/";
        var route = layer.route;
        if (path4.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {
          return next(err);
        }
        var c = path4.length > route.length && path4[route.length];
        if (c && c !== "/" && c !== ".") {
          return next(err);
        }
        if (route.length !== 0 && route !== "/") {
          removed = route;
          req2.url = protohost + req2.url.substr(protohost.length + removed.length);
          if (!protohost && req2.url[0] !== "/") {
            req2.url = "/" + req2.url;
            slashAdded = true;
          }
        }
        call(layer.handle, route, err, req2, res, next);
      }
      next();
    };
    proto.listen = function listen() {
      var server = http$4.createServer(this);
      return server.listen.apply(server, arguments);
    };
    libExports$1 = {};
    lib$1 = {
      get exports() {
        return libExports$1;
      },
      set exports(v) {
        libExports$1 = v;
      }
    };
    getOwnPropertySymbols = Object.getOwnPropertySymbols;
    hasOwnProperty2 = Object.prototype.hasOwnProperty;
    propIsEnumerable = Object.prototype.propertyIsEnumerable;
    objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty2.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
    varyExports = {};
    vary$1 = {
      get exports() {
        return varyExports;
      },
      set exports(v) {
        varyExports = v;
      }
    };
    vary$1.exports = vary;
    varyExports.append = append;
    FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
    (function() {
      var assign = objectAssign;
      var vary2 = varyExports;
      var defaults = {
        origin: "*",
        methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
        preflightContinue: false,
        optionsSuccessStatus: 204
      };
      function isString2(s) {
        return typeof s === "string" || s instanceof String;
      }
      function isOriginAllowed(origin, allowedOrigin) {
        if (Array.isArray(allowedOrigin)) {
          for (var i = 0; i < allowedOrigin.length; ++i) {
            if (isOriginAllowed(origin, allowedOrigin[i])) {
              return true;
            }
          }
          return false;
        } else if (isString2(allowedOrigin)) {
          return origin === allowedOrigin;
        } else if (allowedOrigin instanceof RegExp) {
          return allowedOrigin.test(origin);
        } else {
          return !!allowedOrigin;
        }
      }
      function configureOrigin(options2, req2) {
        var requestOrigin = req2.headers.origin, headers = [], isAllowed;
        if (!options2.origin || options2.origin === "*") {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: "*"
          }]);
        } else if (isString2(options2.origin)) {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: options2.origin
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        } else {
          isAllowed = isOriginAllowed(requestOrigin, options2.origin);
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: isAllowed ? requestOrigin : false
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        }
        return headers;
      }
      function configureMethods(options2) {
        var methods4 = options2.methods;
        if (methods4.join) {
          methods4 = options2.methods.join(",");
        }
        return {
          key: "Access-Control-Allow-Methods",
          value: methods4
        };
      }
      function configureCredentials(options2) {
        if (options2.credentials === true) {
          return {
            key: "Access-Control-Allow-Credentials",
            value: "true"
          };
        }
        return null;
      }
      function configureAllowedHeaders(options2, req2) {
        var allowedHeaders = options2.allowedHeaders || options2.headers;
        var headers = [];
        if (!allowedHeaders) {
          allowedHeaders = req2.headers["access-control-request-headers"];
          headers.push([{
            key: "Vary",
            value: "Access-Control-Request-Headers"
          }]);
        } else if (allowedHeaders.join) {
          allowedHeaders = allowedHeaders.join(",");
        }
        if (allowedHeaders && allowedHeaders.length) {
          headers.push([{
            key: "Access-Control-Allow-Headers",
            value: allowedHeaders
          }]);
        }
        return headers;
      }
      function configureExposedHeaders(options2) {
        var headers = options2.exposedHeaders;
        if (!headers) {
          return null;
        } else if (headers.join) {
          headers = headers.join(",");
        }
        if (headers && headers.length) {
          return {
            key: "Access-Control-Expose-Headers",
            value: headers
          };
        }
        return null;
      }
      function configureMaxAge(options2) {
        var maxAge = (typeof options2.maxAge === "number" || options2.maxAge) && options2.maxAge.toString();
        if (maxAge && maxAge.length) {
          return {
            key: "Access-Control-Max-Age",
            value: maxAge
          };
        }
        return null;
      }
      function applyHeaders(headers, res) {
        for (var i = 0, n2 = headers.length; i < n2; i++) {
          var header = headers[i];
          if (header) {
            if (Array.isArray(header)) {
              applyHeaders(header, res);
            } else if (header.key === "Vary" && header.value) {
              vary2(res, header.value);
            } else if (header.value) {
              res.setHeader(header.key, header.value);
            }
          }
        }
      }
      function cors(options2, req2, res, next) {
        var headers = [], method = req2.method && req2.method.toUpperCase && req2.method.toUpperCase();
        if (method === "OPTIONS") {
          headers.push(configureOrigin(options2, req2));
          headers.push(configureCredentials(options2));
          headers.push(configureMethods(options2));
          headers.push(configureAllowedHeaders(options2, req2));
          headers.push(configureMaxAge(options2));
          headers.push(configureExposedHeaders(options2));
          applyHeaders(headers, res);
          if (options2.preflightContinue) {
            next();
          } else {
            res.statusCode = options2.optionsSuccessStatus;
            res.setHeader("Content-Length", "0");
            res.end();
          }
        } else {
          headers.push(configureOrigin(options2, req2));
          headers.push(configureCredentials(options2));
          headers.push(configureExposedHeaders(options2));
          applyHeaders(headers, res);
          next();
        }
      }
      function middlewareWrapper(o) {
        var optionsCallback = null;
        if (typeof o === "function") {
          optionsCallback = o;
        } else {
          optionsCallback = function(req2, cb) {
            cb(null, o);
          };
        }
        return function corsMiddleware(req2, res, next) {
          optionsCallback(req2, function(err, options2) {
            if (err) {
              next(err);
            } else {
              var corsOptions = assign({}, defaults, options2);
              var originCallback = null;
              if (corsOptions.origin && typeof corsOptions.origin === "function") {
                originCallback = corsOptions.origin;
              } else if (corsOptions.origin) {
                originCallback = function(origin, cb) {
                  cb(null, corsOptions.origin);
                };
              }
              if (originCallback) {
                originCallback(req2.headers.origin, function(err2, origin) {
                  if (err2 || !origin) {
                    next(err2);
                  } else {
                    corsOptions.origin = origin;
                    cors(corsOptions, req2, res, next);
                  }
                });
              } else {
                next();
              }
            }
          });
        };
      }
      lib$1.exports = middlewareWrapper;
    })();
    chokidar = {};
    fs$8 = import_fs.default;
    ({ Readable } = import_stream.default);
    sysPath$3 = import_path2.default;
    ({ promisify: promisify$3 } = import_util.default);
    picomatch$12 = picomatchExports2;
    readdir$1 = promisify$3(fs$8.readdir);
    stat$3 = promisify$3(fs$8.stat);
    lstat$2 = promisify$3(fs$8.lstat);
    realpath$1 = promisify$3(fs$8.realpath);
    BANG$2 = "!";
    RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
    NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
    FILE_TYPE = "files";
    DIR_TYPE = "directories";
    FILE_DIR_TYPE = "files_directories";
    EVERYTHING_TYPE = "all";
    ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
    isNormalFlowError = (error2) => NORMAL_FLOW_ERRORS.has(error2.code);
    [maj, min] = process.versions.node.split(".").slice(0, 2).map((n2) => Number.parseInt(n2, 10));
    wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
    normalizeFilter = (filter2) => {
      if (filter2 === void 0)
        return;
      if (typeof filter2 === "function")
        return filter2;
      if (typeof filter2 === "string") {
        const glob = picomatch$12(filter2.trim());
        return (entry2) => glob(entry2.basename);
      }
      if (Array.isArray(filter2)) {
        const positive = [];
        const negative = [];
        for (const item of filter2) {
          const trimmed = item.trim();
          if (trimmed.charAt(0) === BANG$2) {
            negative.push(picomatch$12(trimmed.slice(1)));
          } else {
            positive.push(picomatch$12(trimmed));
          }
        }
        if (negative.length > 0) {
          if (positive.length > 0) {
            return (entry2) => positive.some((f) => f(entry2.basename)) && !negative.some((f) => f(entry2.basename));
          }
          return (entry2) => !negative.some((f) => f(entry2.basename));
        }
        return (entry2) => positive.some((f) => f(entry2.basename));
      }
    };
    ReaddirpStream = class extends Readable {
      static get defaultOptions() {
        return {
          root: ".",
          /* eslint-disable no-unused-vars */
          fileFilter: (path4) => true,
          directoryFilter: (path4) => true,
          /* eslint-enable no-unused-vars */
          type: FILE_TYPE,
          lstat: false,
          depth: 2147483648,
          alwaysStat: false
        };
      }
      constructor(options2 = {}) {
        super({
          objectMode: true,
          autoDestroy: true,
          highWaterMark: options2.highWaterMark || 4096
        });
        const opts = { ...ReaddirpStream.defaultOptions, ...options2 };
        const { root, type } = opts;
        this._fileFilter = normalizeFilter(opts.fileFilter);
        this._directoryFilter = normalizeFilter(opts.directoryFilter);
        const statMethod = opts.lstat ? lstat$2 : stat$3;
        if (wantBigintFsStats) {
          this._stat = (path4) => statMethod(path4, { bigint: true });
        } else {
          this._stat = statMethod;
        }
        this._maxDepth = opts.depth;
        this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsEverything = type === EVERYTHING_TYPE;
        this._root = sysPath$3.resolve(root);
        this._isDirent = "Dirent" in fs$8 && !opts.alwaysStat;
        this._statsProp = this._isDirent ? "dirent" : "stats";
        this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
        this.parents = [this._exploreDir(root, 1)];
        this.reading = false;
        this.parent = void 0;
      }
      async _read(batch) {
        if (this.reading)
          return;
        this.reading = true;
        try {
          while (!this.destroyed && batch > 0) {
            const { path: path4, depth: depth3, files = [] } = this.parent || {};
            if (files.length > 0) {
              const slice2 = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path4));
              for (const entry2 of await Promise.all(slice2)) {
                if (this.destroyed)
                  return;
                const entryType = await this._getEntryType(entry2);
                if (entryType === "directory" && this._directoryFilter(entry2)) {
                  if (depth3 <= this._maxDepth) {
                    this.parents.push(this._exploreDir(entry2.fullPath, depth3 + 1));
                  }
                  if (this._wantsDir) {
                    this.push(entry2);
                    batch--;
                  }
                } else if ((entryType === "file" || this._includeAsFile(entry2)) && this._fileFilter(entry2)) {
                  if (this._wantsFile) {
                    this.push(entry2);
                    batch--;
                  }
                }
              }
            } else {
              const parent = this.parents.pop();
              if (!parent) {
                this.push(null);
                break;
              }
              this.parent = await parent;
              if (this.destroyed)
                return;
            }
          }
        } catch (error2) {
          this.destroy(error2);
        } finally {
          this.reading = false;
        }
      }
      async _exploreDir(path4, depth3) {
        let files;
        try {
          files = await readdir$1(path4, this._rdOptions);
        } catch (error2) {
          this._onError(error2);
        }
        return { files, depth: depth3, path: path4 };
      }
      async _formatEntry(dirent, path4) {
        let entry2;
        try {
          const basename3 = this._isDirent ? dirent.name : dirent;
          const fullPath = sysPath$3.resolve(sysPath$3.join(path4, basename3));
          entry2 = { path: sysPath$3.relative(this._root, fullPath), fullPath, basename: basename3 };
          entry2[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        } catch (err) {
          this._onError(err);
        }
        return entry2;
      }
      _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
          this.emit("warn", err);
        } else {
          this.destroy(err);
        }
      }
      async _getEntryType(entry2) {
        const stats = entry2 && entry2[this._statsProp];
        if (!stats) {
          return;
        }
        if (stats.isFile()) {
          return "file";
        }
        if (stats.isDirectory()) {
          return "directory";
        }
        if (stats && stats.isSymbolicLink()) {
          const full = entry2.fullPath;
          try {
            const entryRealPath = await realpath$1(full);
            const entryRealPathStats = await lstat$2(entryRealPath);
            if (entryRealPathStats.isFile()) {
              return "file";
            }
            if (entryRealPathStats.isDirectory()) {
              const len = entryRealPath.length;
              if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {
                const recursiveError = new Error(
                  `Circular symlink detected: "${full}" points to "${entryRealPath}"`
                );
                recursiveError.code = RECURSIVE_ERROR_CODE;
                return this._onError(recursiveError);
              }
              return "directory";
            }
          } catch (error2) {
            this._onError(error2);
          }
        }
      }
      _includeAsFile(entry2) {
        const stats = entry2 && entry2[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
      }
    };
    readdirp$1 = (root, options2 = {}) => {
      let type = options2.entryType || options2.type;
      if (type === "both")
        type = FILE_DIR_TYPE;
      if (type)
        options2.type = type;
      if (!root) {
        throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
      } else if (typeof root !== "string") {
        throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
      } else if (type && !ALL_TYPES.includes(type)) {
        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
      }
      options2.root = root;
      return new ReaddirpStream(options2);
    };
    readdirpPromise = (root, options2 = {}) => {
      return new Promise((resolve5, reject) => {
        const files = [];
        readdirp$1(root, options2).on("data", (entry2) => files.push(entry2)).on("end", () => resolve5(files)).on("error", (error2) => reject(error2));
      });
    };
    readdirp$1.promise = readdirpPromise;
    readdirp$1.ReaddirpStream = ReaddirpStream;
    readdirp$1.default = readdirp$1;
    readdirp_1 = readdirp$1;
    anymatchExports = {};
    anymatch$2 = {
      get exports() {
        return anymatchExports;
      },
      set exports(v) {
        anymatchExports = v;
      }
    };
    normalizePath$2 = function(path4, stripTrailing) {
      if (typeof path4 !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path4 === "\\" || path4 === "/")
        return "/";
      var len = path4.length;
      if (len <= 1)
        return path4;
      var prefix = "";
      if (len > 4 && path4[3] === "\\") {
        var ch = path4[2];
        if ((ch === "?" || ch === ".") && path4.slice(0, 2) === "\\\\") {
          path4 = path4.slice(2);
          prefix = "//";
        }
      }
      var segs = path4.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
    Object.defineProperty(anymatchExports, "__esModule", { value: true });
    picomatch2 = picomatchExports2;
    normalizePath$1 = normalizePath$2;
    BANG$1 = "!";
    DEFAULT_OPTIONS = { returnIndex: false };
    arrify$1 = (item) => Array.isArray(item) ? item : [item];
    createPattern = (matcher2, options2) => {
      if (typeof matcher2 === "function") {
        return matcher2;
      }
      if (typeof matcher2 === "string") {
        const glob = picomatch2(matcher2, options2);
        return (string2) => matcher2 === string2 || glob(string2);
      }
      if (matcher2 instanceof RegExp) {
        return (string2) => matcher2.test(string2);
      }
      return (string2) => false;
    };
    matchPatterns = (patterns2, negPatterns, args, returnIndex) => {
      const isList = Array.isArray(args);
      const _path = isList ? args[0] : args;
      if (!isList && typeof _path !== "string") {
        throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
      }
      const path4 = normalizePath$1(_path);
      for (let index = 0; index < negPatterns.length; index++) {
        const nglob = negPatterns[index];
        if (nglob(path4)) {
          return returnIndex ? -1 : false;
        }
      }
      const applied = isList && [path4].concat(args.slice(1));
      for (let index = 0; index < patterns2.length; index++) {
        const pattern2 = patterns2[index];
        if (isList ? pattern2(...applied) : pattern2(path4)) {
          return returnIndex ? index : true;
        }
      }
      return returnIndex ? -1 : false;
    };
    anymatch$1 = (matchers, testString, options2 = DEFAULT_OPTIONS) => {
      if (matchers == null) {
        throw new TypeError("anymatch: specify first argument");
      }
      const opts = typeof options2 === "boolean" ? { returnIndex: options2 } : options2;
      const returnIndex = opts.returnIndex || false;
      const mtchers = arrify$1(matchers);
      const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG$1).map((item) => item.slice(1)).map((item) => picomatch2(item, opts));
      const patterns2 = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG$1).map((matcher2) => createPattern(matcher2, opts));
      if (testString == null) {
        return (testString2, ri = false) => {
          const returnIndex2 = typeof ri === "boolean" ? ri : false;
          return matchPatterns(patterns2, negatedGlobs, testString2, returnIndex2);
        };
      }
      return matchPatterns(patterns2, negatedGlobs, testString, returnIndex);
    };
    anymatch$1.default = anymatch$1;
    anymatch$2.exports = anymatch$1;
    binaryExtensionsExports = {};
    binaryExtensions$1 = {
      get exports() {
        return binaryExtensionsExports;
      },
      set exports(v) {
        binaryExtensionsExports = v;
      }
    };
    require$$02 = [
      "3dm",
      "3ds",
      "3g2",
      "3gp",
      "7z",
      "a",
      "aac",
      "adp",
      "ai",
      "aif",
      "aiff",
      "alz",
      "ape",
      "apk",
      "appimage",
      "ar",
      "arj",
      "asf",
      "au",
      "avi",
      "bak",
      "baml",
      "bh",
      "bin",
      "bk",
      "bmp",
      "btif",
      "bz2",
      "bzip2",
      "cab",
      "caf",
      "cgm",
      "class",
      "cmx",
      "cpio",
      "cr2",
      "cur",
      "dat",
      "dcm",
      "deb",
      "dex",
      "djvu",
      "dll",
      "dmg",
      "dng",
      "doc",
      "docm",
      "docx",
      "dot",
      "dotm",
      "dra",
      "DS_Store",
      "dsk",
      "dts",
      "dtshd",
      "dvb",
      "dwg",
      "dxf",
      "ecelp4800",
      "ecelp7470",
      "ecelp9600",
      "egg",
      "eol",
      "eot",
      "epub",
      "exe",
      "f4v",
      "fbs",
      "fh",
      "fla",
      "flac",
      "flatpak",
      "fli",
      "flv",
      "fpx",
      "fst",
      "fvt",
      "g3",
      "gh",
      "gif",
      "graffle",
      "gz",
      "gzip",
      "h261",
      "h263",
      "h264",
      "icns",
      "ico",
      "ief",
      "img",
      "ipa",
      "iso",
      "jar",
      "jpeg",
      "jpg",
      "jpgv",
      "jpm",
      "jxr",
      "key",
      "ktx",
      "lha",
      "lib",
      "lvp",
      "lz",
      "lzh",
      "lzma",
      "lzo",
      "m3u",
      "m4a",
      "m4v",
      "mar",
      "mdi",
      "mht",
      "mid",
      "midi",
      "mj2",
      "mka",
      "mkv",
      "mmr",
      "mng",
      "mobi",
      "mov",
      "movie",
      "mp3",
      "mp4",
      "mp4a",
      "mpeg",
      "mpg",
      "mpga",
      "mxu",
      "nef",
      "npx",
      "numbers",
      "nupkg",
      "o",
      "odp",
      "ods",
      "odt",
      "oga",
      "ogg",
      "ogv",
      "otf",
      "ott",
      "pages",
      "pbm",
      "pcx",
      "pdb",
      "pdf",
      "pea",
      "pgm",
      "pic",
      "png",
      "pnm",
      "pot",
      "potm",
      "potx",
      "ppa",
      "ppam",
      "ppm",
      "pps",
      "ppsm",
      "ppsx",
      "ppt",
      "pptm",
      "pptx",
      "psd",
      "pya",
      "pyc",
      "pyo",
      "pyv",
      "qt",
      "rar",
      "ras",
      "raw",
      "resources",
      "rgb",
      "rip",
      "rlc",
      "rmf",
      "rmvb",
      "rpm",
      "rtf",
      "rz",
      "s3m",
      "s7z",
      "scpt",
      "sgi",
      "shar",
      "snap",
      "sil",
      "sketch",
      "slk",
      "smv",
      "snk",
      "so",
      "stl",
      "suo",
      "sub",
      "swf",
      "tar",
      "tbz",
      "tbz2",
      "tga",
      "tgz",
      "thmx",
      "tif",
      "tiff",
      "tlz",
      "ttc",
      "ttf",
      "txz",
      "udf",
      "uvh",
      "uvi",
      "uvm",
      "uvp",
      "uvs",
      "uvu",
      "viv",
      "vob",
      "war",
      "wav",
      "wax",
      "wbmp",
      "wdp",
      "weba",
      "webm",
      "webp",
      "whl",
      "wim",
      "wm",
      "wma",
      "wmv",
      "wmx",
      "woff",
      "woff2",
      "wrm",
      "wvx",
      "xbm",
      "xif",
      "xla",
      "xlam",
      "xls",
      "xlsb",
      "xlsm",
      "xlsx",
      "xlt",
      "xltm",
      "xltx",
      "xm",
      "xmind",
      "xpi",
      "xpm",
      "xwd",
      "xz",
      "z",
      "zip",
      "zipx"
    ];
    (function(module2) {
      module2.exports = require$$02;
    })(binaryExtensions$1);
    path$8 = import_path2.default;
    binaryExtensions = binaryExtensionsExports;
    extensions = new Set(binaryExtensions);
    isBinaryPath$1 = (filePath) => extensions.has(path$8.extname(filePath).slice(1).toLowerCase());
    constants$12 = {};
    (function(exports2) {
      const { sep: sep2 } = import_path2.default;
      const { platform: platform3 } = process;
      const os2 = import_os.default;
      exports2.EV_ALL = "all";
      exports2.EV_READY = "ready";
      exports2.EV_ADD = "add";
      exports2.EV_CHANGE = "change";
      exports2.EV_ADD_DIR = "addDir";
      exports2.EV_UNLINK = "unlink";
      exports2.EV_UNLINK_DIR = "unlinkDir";
      exports2.EV_RAW = "raw";
      exports2.EV_ERROR = "error";
      exports2.STR_DATA = "data";
      exports2.STR_END = "end";
      exports2.STR_CLOSE = "close";
      exports2.FSEVENT_CREATED = "created";
      exports2.FSEVENT_MODIFIED = "modified";
      exports2.FSEVENT_DELETED = "deleted";
      exports2.FSEVENT_MOVED = "moved";
      exports2.FSEVENT_CLONED = "cloned";
      exports2.FSEVENT_UNKNOWN = "unknown";
      exports2.FSEVENT_TYPE_FILE = "file";
      exports2.FSEVENT_TYPE_DIRECTORY = "directory";
      exports2.FSEVENT_TYPE_SYMLINK = "symlink";
      exports2.KEY_LISTENERS = "listeners";
      exports2.KEY_ERR = "errHandlers";
      exports2.KEY_RAW = "rawEmitters";
      exports2.HANDLER_KEYS = [exports2.KEY_LISTENERS, exports2.KEY_ERR, exports2.KEY_RAW];
      exports2.DOT_SLASH = `.${sep2}`;
      exports2.BACK_SLASH_RE = /\\/g;
      exports2.DOUBLE_SLASH_RE = /\/\//;
      exports2.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
      exports2.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
      exports2.REPLACER_RE = /^\.[/\\]/;
      exports2.SLASH = "/";
      exports2.SLASH_SLASH = "//";
      exports2.BRACE_START = "{";
      exports2.BANG = "!";
      exports2.ONE_DOT = ".";
      exports2.TWO_DOTS = "..";
      exports2.STAR = "*";
      exports2.GLOBSTAR = "**";
      exports2.ROOT_GLOBSTAR = "/**/*";
      exports2.SLASH_GLOBSTAR = "/**";
      exports2.DIR_SUFFIX = "Dir";
      exports2.ANYMATCH_OPTS = { dot: true };
      exports2.STRING_TYPE = "string";
      exports2.FUNCTION_TYPE = "function";
      exports2.EMPTY_STR = "";
      exports2.EMPTY_FN = () => {
      };
      exports2.IDENTITY_FN = (val) => val;
      exports2.isWindows = platform3 === "win32";
      exports2.isMacos = platform3 === "darwin";
      exports2.isLinux = platform3 === "linux";
      exports2.isIBMi = os2.type() === "OS400";
    })(constants$12);
    fs$7 = import_fs.default;
    sysPath$2 = import_path2.default;
    ({ promisify: promisify$2 } = import_util.default);
    isBinaryPath = isBinaryPath$1;
    ({
      isWindows: isWindows$2,
      isLinux,
      EMPTY_FN: EMPTY_FN$2,
      EMPTY_STR: EMPTY_STR$1,
      KEY_LISTENERS,
      KEY_ERR,
      KEY_RAW,
      HANDLER_KEYS,
      EV_CHANGE: EV_CHANGE$2,
      EV_ADD: EV_ADD$2,
      EV_ADD_DIR: EV_ADD_DIR$2,
      EV_ERROR: EV_ERROR$2,
      STR_DATA: STR_DATA$1,
      STR_END: STR_END$2,
      BRACE_START: BRACE_START$1,
      STAR: STAR2
    } = constants$12);
    THROTTLE_MODE_WATCH = "watch";
    open$1 = promisify$2(fs$7.open);
    stat$2 = promisify$2(fs$7.stat);
    lstat$1 = promisify$2(fs$7.lstat);
    close = promisify$2(fs$7.close);
    fsrealpath = promisify$2(fs$7.realpath);
    statMethods$1 = { lstat: lstat$1, stat: stat$2 };
    foreach = (val, fn) => {
      if (val instanceof Set) {
        val.forEach(fn);
      } else {
        fn(val);
      }
    };
    addAndConvert = (main2, prop, item) => {
      let container = main2[prop];
      if (!(container instanceof Set)) {
        main2[prop] = container = /* @__PURE__ */ new Set([container]);
      }
      container.add(item);
    };
    clearItem = (cont) => (key) => {
      const set2 = cont[key];
      if (set2 instanceof Set) {
        set2.clear();
      } else {
        delete cont[key];
      }
    };
    delFromSet = (main2, prop, item) => {
      const container = main2[prop];
      if (container instanceof Set) {
        container.delete(item);
      } else if (container === item) {
        delete main2[prop];
      }
    };
    isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
    FsWatchInstances = /* @__PURE__ */ new Map();
    fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
      const cont = FsWatchInstances.get(fullPath);
      if (!cont)
        return;
      foreach(cont[type], (listener2) => {
        listener2(val1, val2, val3);
      });
    };
    setFsWatchListener = (path4, fullPath, options2, handlers) => {
      const { listener: listener2, errHandler, rawEmitter } = handlers;
      let cont = FsWatchInstances.get(fullPath);
      let watcher;
      if (!options2.persistent) {
        watcher = createFsWatchInstance(
          path4,
          options2,
          listener2,
          errHandler,
          rawEmitter
        );
        return watcher.close.bind(watcher);
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener2);
        addAndConvert(cont, KEY_ERR, errHandler);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        watcher = createFsWatchInstance(
          path4,
          options2,
          fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
          errHandler,
          // no need to use broadcast here
          fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
        );
        if (!watcher)
          return;
        watcher.on(EV_ERROR$2, async (error2) => {
          const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
          cont.watcherUnusable = true;
          if (isWindows$2 && error2.code === "EPERM") {
            try {
              const fd = await open$1(path4, "r");
              await close(fd);
              broadcastErr(error2);
            } catch (err) {
            }
          } else {
            broadcastErr(error2);
          }
        });
        cont = {
          listeners: listener2,
          errHandlers: errHandler,
          rawEmitters: rawEmitter,
          watcher
        };
        FsWatchInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener2);
        delFromSet(cont, KEY_ERR, errHandler);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          cont.watcher.close();
          FsWatchInstances.delete(fullPath);
          HANDLER_KEYS.forEach(clearItem(cont));
          cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    FsWatchFileInstances = /* @__PURE__ */ new Map();
    setFsWatchFileListener = (path4, fullPath, options2, handlers) => {
      const { listener: listener2, rawEmitter } = handlers;
      let cont = FsWatchFileInstances.get(fullPath);
      const copts = cont && cont.options;
      if (copts && (copts.persistent < options2.persistent || copts.interval > options2.interval)) {
        fs$7.unwatchFile(fullPath);
        cont = void 0;
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener2);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        cont = {
          listeners: listener2,
          rawEmitters: rawEmitter,
          options: options2,
          watcher: fs$7.watchFile(fullPath, options2, (curr, prev) => {
            foreach(cont.rawEmitters, (rawEmitter2) => {
              rawEmitter2(EV_CHANGE$2, fullPath, { curr, prev });
            });
            const currmtime = curr.mtimeMs;
            if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
              foreach(cont.listeners, (listener3) => listener3(path4, curr));
            }
          })
        };
        FsWatchFileInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener2);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          FsWatchFileInstances.delete(fullPath);
          fs$7.unwatchFile(fullPath);
          cont.options = cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    NodeFsHandler$1 = class NodeFsHandler {
      /**
       * @param {import("../index").FSWatcher} fsW
       */
      constructor(fsW) {
        this.fsw = fsW;
        this._boundHandleError = (error2) => fsW._handleError(error2);
      }
      /**
       * Watch file for changes with fs_watchFile or fs_watch.
       * @param {String} path to file or dir
       * @param {Function} listener on fs change
       * @returns {Function} closer for the watcher instance
       */
      _watchWithNodeFs(path4, listener2) {
        const opts = this.fsw.options;
        const directory = sysPath$2.dirname(path4);
        const basename3 = sysPath$2.basename(path4);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename3);
        const absolutePath = sysPath$2.resolve(path4);
        const options2 = { persistent: opts.persistent };
        if (!listener2)
          listener2 = EMPTY_FN$2;
        let closer;
        if (opts.usePolling) {
          options2.interval = opts.enableBinaryInterval && isBinaryPath(basename3) ? opts.binaryInterval : opts.interval;
          closer = setFsWatchFileListener(path4, absolutePath, options2, {
            listener: listener2,
            rawEmitter: this.fsw._emitRaw
          });
        } else {
          closer = setFsWatchListener(path4, absolutePath, options2, {
            listener: listener2,
            errHandler: this._boundHandleError,
            rawEmitter: this.fsw._emitRaw
          });
        }
        return closer;
      }
      /**
       * Watch a file and emit add event if warranted.
       * @param {Path} file Path
       * @param {fs.Stats} stats result of fs_stat
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @returns {Function} closer for the watcher instance
       */
      _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
          return;
        }
        const dirname3 = sysPath$2.dirname(file);
        const basename3 = sysPath$2.basename(file);
        const parent = this.fsw._getWatchedDir(dirname3);
        let prevStats = stats;
        if (parent.has(basename3))
          return;
        const listener2 = async (path4, newStats) => {
          if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
            return;
          if (!newStats || newStats.mtimeMs === 0) {
            try {
              const newStats2 = await stat$2(file);
              if (this.fsw.closed)
                return;
              const at3 = newStats2.atimeMs;
              const mt = newStats2.mtimeMs;
              if (!at3 || at3 <= mt || mt !== prevStats.mtimeMs) {
                this.fsw._emit(EV_CHANGE$2, file, newStats2);
              }
              if (isLinux && prevStats.ino !== newStats2.ino) {
                this.fsw._closeFile(path4);
                prevStats = newStats2;
                this.fsw._addPathCloser(path4, this._watchWithNodeFs(file, listener2));
              } else {
                prevStats = newStats2;
              }
            } catch (error2) {
              this.fsw._remove(dirname3, basename3);
            }
          } else if (parent.has(basename3)) {
            const at3 = newStats.atimeMs;
            const mt = newStats.mtimeMs;
            if (!at3 || at3 <= mt || mt !== prevStats.mtimeMs) {
              this.fsw._emit(EV_CHANGE$2, file, newStats);
            }
            prevStats = newStats;
          }
        };
        const closer = this._watchWithNodeFs(file, listener2);
        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
          if (!this.fsw._throttle(EV_ADD$2, file, 0))
            return;
          this.fsw._emit(EV_ADD$2, file, stats);
        }
        return closer;
      }
      /**
       * Handle symlinks encountered while reading a dir.
       * @param {Object} entry returned by readdirp
       * @param {String} directory path of dir being read
       * @param {String} path of this item
       * @param {String} item basename of this item
       * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
       */
      async _handleSymlink(entry2, directory, path4, item) {
        if (this.fsw.closed) {
          return;
        }
        const full = entry2.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
          this.fsw._incrReadyCount();
          let linkPath;
          try {
            linkPath = await fsrealpath(path4);
          } catch (e) {
            this.fsw._emitReady();
            return true;
          }
          if (this.fsw.closed)
            return;
          if (dir.has(item)) {
            if (this.fsw._symlinkPaths.get(full) !== linkPath) {
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV_CHANGE$2, path4, entry2.stats);
            }
          } else {
            dir.add(item);
            this.fsw._symlinkPaths.set(full, linkPath);
            this.fsw._emit(EV_ADD$2, path4, entry2.stats);
          }
          this.fsw._emitReady();
          return true;
        }
        if (this.fsw._symlinkPaths.has(full)) {
          return true;
        }
        this.fsw._symlinkPaths.set(full, true);
      }
      _handleRead(directory, initialAdd, wh, target, dir, depth3, throttler) {
        directory = sysPath$2.join(directory, EMPTY_STR$1);
        if (!wh.hasGlob) {
          throttler = this.fsw._throttle("readdir", directory, 1e3);
          if (!throttler)
            return;
        }
        const previous = this.fsw._getWatchedDir(wh.path);
        const current3 = /* @__PURE__ */ new Set();
        let stream4 = this.fsw._readdirp(directory, {
          fileFilter: (entry2) => wh.filterPath(entry2),
          directoryFilter: (entry2) => wh.filterDir(entry2),
          depth: 0
        }).on(STR_DATA$1, async (entry2) => {
          if (this.fsw.closed) {
            stream4 = void 0;
            return;
          }
          const item = entry2.path;
          let path4 = sysPath$2.join(directory, item);
          current3.add(item);
          if (entry2.stats.isSymbolicLink() && await this._handleSymlink(entry2, directory, path4, item)) {
            return;
          }
          if (this.fsw.closed) {
            stream4 = void 0;
            return;
          }
          if (item === target || !target && !previous.has(item)) {
            this.fsw._incrReadyCount();
            path4 = sysPath$2.join(dir, sysPath$2.relative(dir, path4));
            this._addToNodeFs(path4, initialAdd, wh, depth3 + 1);
          }
        }).on(EV_ERROR$2, this._boundHandleError);
        return new Promise(
          (resolve5) => stream4.once(STR_END$2, () => {
            if (this.fsw.closed) {
              stream4 = void 0;
              return;
            }
            const wasThrottled = throttler ? throttler.clear() : false;
            resolve5();
            previous.getChildren().filter((item) => {
              return item !== directory && !current3.has(item) && // in case of intersecting globs;
              // a path may have been filtered out of this readdir, but
              // shouldn't be removed because it matches a different glob
              (!wh.hasGlob || wh.filterPath({
                fullPath: sysPath$2.resolve(directory, item)
              }));
            }).forEach((item) => {
              this.fsw._remove(directory, item);
            });
            stream4 = void 0;
            if (wasThrottled)
              this._handleRead(directory, false, wh, target, dir, depth3, throttler);
          })
        );
      }
      /**
       * Read directory to add / remove files from `@watched` list and re-read it on change.
       * @param {String} dir fs path
       * @param {fs.Stats} stats
       * @param {Boolean} initialAdd
       * @param {Number} depth relative to user-supplied path
       * @param {String} target child path targeted for watch
       * @param {Object} wh Common watch helpers for this path
       * @param {String} realpath
       * @returns {Promise<Function>} closer for the watcher instance.
       */
      async _handleDir(dir, stats, initialAdd, depth3, target, wh, realpath4) {
        const parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));
        const tracked = parentDir.has(sysPath$2.basename(dir));
        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
          if (!wh.hasGlob || wh.globFilter(dir))
            this.fsw._emit(EV_ADD_DIR$2, dir, stats);
        }
        parentDir.add(sysPath$2.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth3 <= oDepth) && !this.fsw._symlinkPaths.has(realpath4)) {
          if (!target) {
            await this._handleRead(dir, initialAdd, wh, target, dir, depth3, throttler);
            if (this.fsw.closed)
              return;
          }
          closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
            if (stats2 && stats2.mtimeMs === 0)
              return;
            this._handleRead(dirPath, false, wh, target, dir, depth3, throttler);
          });
        }
        return closer;
      }
      /**
       * Handle added file, directory, or glob pattern.
       * Delegates call to _handleFile / _handleDir after checks.
       * @param {String} path to file or ir
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @param {Object} priorWh depth relative to user-supplied path
       * @param {Number} depth Child path actually targeted for watch
       * @param {String=} target Child path actually targeted for watch
       * @returns {Promise}
       */
      async _addToNodeFs(path4, initialAdd, priorWh, depth3, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path4) || this.fsw.closed) {
          ready();
          return false;
        }
        const wh = this.fsw._getWatchHelpers(path4, depth3);
        if (!wh.hasGlob && priorWh) {
          wh.hasGlob = priorWh.hasGlob;
          wh.globFilter = priorWh.globFilter;
          wh.filterPath = (entry2) => priorWh.filterPath(entry2);
          wh.filterDir = (entry2) => priorWh.filterDir(entry2);
        }
        try {
          const stats = await statMethods$1[wh.statMethod](wh.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            ready();
            return false;
          }
          const follow = this.fsw.options.followSymlinks && !path4.includes(STAR2) && !path4.includes(BRACE_START$1);
          let closer;
          if (stats.isDirectory()) {
            const absPath = sysPath$2.resolve(path4);
            const targetPath = follow ? await fsrealpath(path4) : path4;
            if (this.fsw.closed)
              return;
            closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth3, target, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (absPath !== targetPath && targetPath !== void 0) {
              this.fsw._symlinkPaths.set(absPath, targetPath);
            }
          } else if (stats.isSymbolicLink()) {
            const targetPath = follow ? await fsrealpath(path4) : path4;
            if (this.fsw.closed)
              return;
            const parent = sysPath$2.dirname(wh.watchPath);
            this.fsw._getWatchedDir(parent).add(wh.watchPath);
            this.fsw._emit(EV_ADD$2, wh.watchPath, stats);
            closer = await this._handleDir(parent, stats, initialAdd, depth3, path4, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (targetPath !== void 0) {
              this.fsw._symlinkPaths.set(sysPath$2.resolve(path4), targetPath);
            }
          } else {
            closer = this._handleFile(wh.watchPath, stats, initialAdd);
          }
          ready();
          this.fsw._addPathCloser(path4, closer);
          return false;
        } catch (error2) {
          if (this.fsw._handleError(error2)) {
            ready();
            return path4;
          }
        }
      }
    };
    nodefsHandler = NodeFsHandler$1;
    fseventsHandlerExports = {};
    fseventsHandler = {
      get exports() {
        return fseventsHandlerExports;
      },
      set exports(v) {
        fseventsHandlerExports = v;
      }
    };
    fs$6 = import_fs.default;
    sysPath$1 = import_path2.default;
    ({ promisify: promisify$1 } = import_util.default);
    try {
      fsevents = __require("fsevents");
    } catch (error2) {
      if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR)
        console.error(error2);
    }
    if (fsevents) {
      const mtch = process.version.match(/v(\d+)\.(\d+)/);
      if (mtch && mtch[1] && mtch[2]) {
        const maj2 = Number.parseInt(mtch[1], 10);
        const min2 = Number.parseInt(mtch[2], 10);
        if (maj2 === 8 && min2 < 16) {
          fsevents = void 0;
        }
      }
    }
    ({
      EV_ADD: EV_ADD$1,
      EV_CHANGE: EV_CHANGE$1,
      EV_ADD_DIR: EV_ADD_DIR$1,
      EV_UNLINK: EV_UNLINK$1,
      EV_ERROR: EV_ERROR$1,
      STR_DATA,
      STR_END: STR_END$1,
      FSEVENT_CREATED,
      FSEVENT_MODIFIED,
      FSEVENT_DELETED,
      FSEVENT_MOVED,
      FSEVENT_UNKNOWN: (
        // FSEVENT_CLONED,
        FSEVENT_UNKNOWN
      ),
      FSEVENT_TYPE_FILE,
      FSEVENT_TYPE_DIRECTORY,
      FSEVENT_TYPE_SYMLINK,
      ROOT_GLOBSTAR,
      DIR_SUFFIX,
      DOT_SLASH,
      FUNCTION_TYPE: FUNCTION_TYPE$1,
      EMPTY_FN: EMPTY_FN$1,
      IDENTITY_FN
    } = constants$12);
    Depth = (value2) => isNaN(value2) ? {} : { depth: value2 };
    stat$1 = promisify$1(fs$6.stat);
    lstat2 = promisify$1(fs$6.lstat);
    realpath3 = promisify$1(fs$6.realpath);
    statMethods = { stat: stat$1, lstat: lstat2 };
    FSEventsWatchers = /* @__PURE__ */ new Map();
    consolidateThreshhold = 10;
    wrongEventFlags = /* @__PURE__ */ new Set([
      69888,
      70400,
      71424,
      72704,
      73472,
      131328,
      131840,
      262912
    ]);
    createFSEventsInstance = (path4, callback) => {
      const stop = fsevents.watch(path4, callback);
      return { stop };
    };
    couldConsolidate = (path4) => {
      let count = 0;
      for (const watchPath of FSEventsWatchers.keys()) {
        if (watchPath.indexOf(path4) === 0) {
          count++;
          if (count >= consolidateThreshhold) {
            return true;
          }
        }
      }
      return false;
    };
    canUse = () => fsevents && FSEventsWatchers.size < 128;
    calcDepth = (path4, root) => {
      let i = 0;
      while (!path4.indexOf(root) && (path4 = sysPath$1.dirname(path4)) !== root)
        i++;
      return i;
    };
    sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
    FsEventsHandler$1 = class FsEventsHandler {
      /**
       * @param {import('../index').FSWatcher} fsw
       */
      constructor(fsw) {
        this.fsw = fsw;
      }
      checkIgnored(path4, stats) {
        const ipaths = this.fsw._ignoredPaths;
        if (this.fsw._isIgnored(path4, stats)) {
          ipaths.add(path4);
          if (stats && stats.isDirectory()) {
            ipaths.add(path4 + ROOT_GLOBSTAR);
          }
          return true;
        }
        ipaths.delete(path4);
        ipaths.delete(path4 + ROOT_GLOBSTAR);
      }
      addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts) {
        const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;
        this.handleEvent(event, path4, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
      async checkExists(path4, fullPath, realPath, parent, watchedDir, item, info, opts) {
        try {
          const stats = await stat$1(path4);
          if (this.fsw.closed)
            return;
          if (sameTypes(info, stats)) {
            this.addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK$1, path4, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        } catch (error2) {
          if (error2.code === "EACCES") {
            this.addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK$1, path4, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        }
      }
      handleEvent(event, path4, fullPath, realPath, parent, watchedDir, item, info, opts) {
        if (this.fsw.closed || this.checkIgnored(path4))
          return;
        if (event === EV_UNLINK$1) {
          const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;
          if (isDirectory || watchedDir.has(item)) {
            this.fsw._remove(parent, item, isDirectory);
          }
        } else {
          if (event === EV_ADD$1) {
            if (info.type === FSEVENT_TYPE_DIRECTORY)
              this.fsw._getWatchedDir(path4);
            if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
              const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
              return this._addToFsEvents(path4, false, true, curDepth);
            }
            this.fsw._getWatchedDir(parent).add(item);
          }
          const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
          this.fsw._emit(eventName, path4);
          if (eventName === EV_ADD_DIR$1)
            this._addToFsEvents(path4, false, true);
        }
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} watchPath  - file/dir path to be watched with fsevents
       * @param {String} realPath   - real path (in case of symlinks)
       * @param {Function} transform  - path transformer
       * @param {Function} globFilter - path filter in case a glob pattern was provided
       * @returns {Function} closer for the watcher instance
      */
      _watchWithFsEvents(watchPath, realPath, transform2, globFilter) {
        if (this.fsw.closed || this.fsw._isIgnored(watchPath))
          return;
        const opts = this.fsw.options;
        const watchCallback = async (fullPath, flags, info) => {
          if (this.fsw.closed)
            return;
          if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth)
            return;
          const path4 = transform2(sysPath$1.join(
            watchPath,
            sysPath$1.relative(watchPath, fullPath)
          ));
          if (globFilter && !globFilter(path4))
            return;
          const parent = sysPath$1.dirname(path4);
          const item = sysPath$1.basename(path4);
          const watchedDir = this.fsw._getWatchedDir(
            info.type === FSEVENT_TYPE_DIRECTORY ? path4 : parent
          );
          if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
            if (typeof opts.ignored === FUNCTION_TYPE$1) {
              let stats;
              try {
                stats = await stat$1(path4);
              } catch (error2) {
              }
              if (this.fsw.closed)
                return;
              if (this.checkIgnored(path4, stats))
                return;
              if (sameTypes(info, stats)) {
                this.addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
              } else {
                this.handleEvent(EV_UNLINK$1, path4, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            } else {
              this.checkExists(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          } else {
            switch (info.event) {
              case FSEVENT_CREATED:
              case FSEVENT_MODIFIED:
                return this.addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
              case FSEVENT_DELETED:
              case FSEVENT_MOVED:
                return this.checkExists(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          }
        };
        const closer = setFSEventsListener(
          watchPath,
          realPath,
          watchCallback,
          this.fsw._emitRaw
        );
        this.fsw._emitReady();
        return closer;
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} linkPath path to symlink
       * @param {String} fullPath absolute path to the symlink
       * @param {Function} transform pre-existing path transformer
       * @param {Number} curDepth level of subdirectories traversed to where symlink is
       * @returns {Promise<void>}
       */
      async _handleFsEventsSymlink(linkPath, fullPath, transform2, curDepth) {
        if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))
          return;
        this.fsw._symlinkPaths.set(fullPath, true);
        this.fsw._incrReadyCount();
        try {
          const linkTarget = await realpath3(linkPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(linkTarget)) {
            return this.fsw._emitReady();
          }
          this.fsw._incrReadyCount();
          this._addToFsEvents(linkTarget || linkPath, (path4) => {
            let aliasedPath = linkPath;
            if (linkTarget && linkTarget !== DOT_SLASH) {
              aliasedPath = path4.replace(linkTarget, linkPath);
            } else if (path4 !== DOT_SLASH) {
              aliasedPath = sysPath$1.join(linkPath, path4);
            }
            return transform2(aliasedPath);
          }, false, curDepth);
        } catch (error2) {
          if (this.fsw._handleError(error2)) {
            return this.fsw._emitReady();
          }
        }
      }
      /**
       *
       * @param {Path} newPath
       * @param {fs.Stats} stats
       */
      emitAdd(newPath, stats, processPath, opts, forceAdd) {
        const pp3 = processPath(newPath);
        const isDir = stats.isDirectory();
        const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp3));
        const base3 = sysPath$1.basename(pp3);
        if (isDir)
          this.fsw._getWatchedDir(pp3);
        if (dirObj.has(base3))
          return;
        dirObj.add(base3);
        if (!opts.ignoreInitial || forceAdd === true) {
          this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp3, stats);
        }
      }
      initWatch(realPath, path4, wh, processPath) {
        if (this.fsw.closed)
          return;
        const closer = this._watchWithFsEvents(
          wh.watchPath,
          sysPath$1.resolve(realPath || wh.watchPath),
          processPath,
          wh.globFilter
        );
        this.fsw._addPathCloser(path4, closer);
      }
      /**
       * Handle added path with fsevents
       * @param {String} path file/dir path or glob pattern
       * @param {Function|Boolean=} transform converts working path to what the user expects
       * @param {Boolean=} forceAdd ensure add is emitted
       * @param {Number=} priorDepth Level of subdirectories already traversed.
       * @returns {Promise<void>}
       */
      async _addToFsEvents(path4, transform2, forceAdd, priorDepth) {
        if (this.fsw.closed) {
          return;
        }
        const opts = this.fsw.options;
        const processPath = typeof transform2 === FUNCTION_TYPE$1 ? transform2 : IDENTITY_FN;
        const wh = this.fsw._getWatchHelpers(path4);
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            throw null;
          }
          if (stats.isDirectory()) {
            if (!wh.globFilter)
              this.emitAdd(processPath(path4), stats, processPath, opts, forceAdd);
            if (priorDepth && priorDepth > opts.depth)
              return;
            this.fsw._readdirp(wh.watchPath, {
              fileFilter: (entry2) => wh.filterPath(entry2),
              directoryFilter: (entry2) => wh.filterDir(entry2),
              ...Depth(opts.depth - (priorDepth || 0))
            }).on(STR_DATA, (entry2) => {
              if (this.fsw.closed) {
                return;
              }
              if (entry2.stats.isDirectory() && !wh.filterPath(entry2))
                return;
              const joinedPath = sysPath$1.join(wh.watchPath, entry2.path);
              const { fullPath } = entry2;
              if (wh.followSymlinks && entry2.stats.isSymbolicLink()) {
                const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;
                this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
              } else {
                this.emitAdd(joinedPath, entry2.stats, processPath, opts, forceAdd);
              }
            }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {
              this.fsw._emitReady();
            });
          } else {
            this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
            this.fsw._emitReady();
          }
        } catch (error2) {
          if (!error2 || this.fsw._handleError(error2)) {
            this.fsw._emitReady();
            this.fsw._emitReady();
          }
        }
        if (opts.persistent && forceAdd !== true) {
          if (typeof transform2 === FUNCTION_TYPE$1) {
            this.initWatch(void 0, path4, wh, processPath);
          } else {
            let realPath;
            try {
              realPath = await realpath3(wh.watchPath);
            } catch (e) {
            }
            this.initWatch(realPath, path4, wh, processPath);
          }
        }
      }
    };
    fseventsHandler.exports = FsEventsHandler$1;
    fseventsHandlerExports.canUse = canUse;
    ({ EventEmitter: EventEmitter$2 } = import_events.default);
    fs$5 = import_fs.default;
    sysPath = import_path2.default;
    ({ promisify } = import_util.default);
    readdirp = readdirp_1;
    anymatch = anymatchExports.default;
    globParent2 = globParent$2;
    isGlob2 = isGlob$2;
    braces = braces_1;
    normalizePath = normalizePath$2;
    NodeFsHandler2 = nodefsHandler;
    FsEventsHandler2 = fseventsHandlerExports;
    ({
      EV_ALL,
      EV_READY,
      EV_ADD,
      EV_CHANGE,
      EV_UNLINK,
      EV_ADD_DIR,
      EV_UNLINK_DIR,
      EV_RAW,
      EV_ERROR,
      STR_CLOSE,
      STR_END,
      BACK_SLASH_RE,
      DOUBLE_SLASH_RE,
      SLASH_OR_BACK_SLASH_RE,
      DOT_RE,
      REPLACER_RE,
      SLASH,
      SLASH_SLASH,
      BRACE_START,
      BANG,
      ONE_DOT,
      TWO_DOTS,
      GLOBSTAR,
      SLASH_GLOBSTAR,
      ANYMATCH_OPTS,
      STRING_TYPE,
      FUNCTION_TYPE,
      EMPTY_STR,
      EMPTY_FN,
      isWindows: isWindows$1,
      isMacos,
      isIBMi
    } = constants$12);
    stat = promisify(fs$5.stat);
    readdir2 = promisify(fs$5.readdir);
    arrify = (value2 = []) => Array.isArray(value2) ? value2 : [value2];
    flatten = (list, result = []) => {
      list.forEach((item) => {
        if (Array.isArray(item)) {
          flatten(item, result);
        } else {
          result.push(item);
        }
      });
      return result;
    };
    unifyPaths = (paths_) => {
      const paths = flatten(arrify(paths_));
      if (!paths.every((p) => typeof p === STRING_TYPE)) {
        throw new TypeError(`Non-string provided as watch path: ${paths}`);
      }
      return paths.map(normalizePathToUnix);
    };
    toUnix = (string2) => {
      let str = string2.replace(BACK_SLASH_RE, SLASH);
      let prepend = false;
      if (str.startsWith(SLASH_SLASH)) {
        prepend = true;
      }
      while (str.match(DOUBLE_SLASH_RE)) {
        str = str.replace(DOUBLE_SLASH_RE, SLASH);
      }
      if (prepend) {
        str = SLASH + str;
      }
      return str;
    };
    normalizePathToUnix = (path4) => toUnix(sysPath.normalize(toUnix(path4)));
    normalizeIgnored = (cwd = EMPTY_STR) => (path4) => {
      if (typeof path4 !== STRING_TYPE)
        return path4;
      return normalizePathToUnix(sysPath.isAbsolute(path4) ? path4 : sysPath.join(cwd, path4));
    };
    getAbsolutePath = (path4, cwd) => {
      if (sysPath.isAbsolute(path4)) {
        return path4;
      }
      if (path4.startsWith(BANG)) {
        return BANG + sysPath.join(cwd, path4.slice(1));
      }
      return sysPath.join(cwd, path4);
    };
    undef = (opts, key) => opts[key] === void 0;
    DirEntry = class {
      /**
       * @param {Path} dir
       * @param {Function} removeWatcher
       */
      constructor(dir, removeWatcher) {
        this.path = dir;
        this._removeWatcher = removeWatcher;
        this.items = /* @__PURE__ */ new Set();
      }
      add(item) {
        const { items } = this;
        if (!items)
          return;
        if (item !== ONE_DOT && item !== TWO_DOTS)
          items.add(item);
      }
      async remove(item) {
        const { items } = this;
        if (!items)
          return;
        items.delete(item);
        if (items.size > 0)
          return;
        const dir = this.path;
        try {
          await readdir2(dir);
        } catch (err) {
          if (this._removeWatcher) {
            this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
          }
        }
      }
      has(item) {
        const { items } = this;
        if (!items)
          return;
        return items.has(item);
      }
      /**
       * @returns {Array<String>}
       */
      getChildren() {
        const { items } = this;
        if (!items)
          return;
        return [...items.values()];
      }
      dispose() {
        this.items.clear();
        delete this.path;
        delete this._removeWatcher;
        delete this.items;
        Object.freeze(this);
      }
    };
    STAT_METHOD_F = "stat";
    STAT_METHOD_L = "lstat";
    WatchHelper = class {
      constructor(path4, watchPath, follow, fsw) {
        this.fsw = fsw;
        this.path = path4 = path4.replace(REPLACER_RE, EMPTY_STR);
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath.resolve(watchPath);
        this.hasGlob = watchPath !== path4;
        if (path4 === EMPTY_STR)
          this.hasGlob = false;
        this.globSymlink = this.hasGlob && follow ? void 0 : false;
        this.globFilter = this.hasGlob ? anymatch(path4, void 0, ANYMATCH_OPTS) : false;
        this.dirParts = this.getDirParts(path4);
        this.dirParts.forEach((parts) => {
          if (parts.length > 1)
            parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
      }
      checkGlobSymlink(entry2) {
        if (this.globSymlink === void 0) {
          this.globSymlink = entry2.fullParentDir === this.fullWatchPath ? false : { realPath: entry2.fullParentDir, linkPath: this.fullWatchPath };
        }
        if (this.globSymlink) {
          return entry2.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
        }
        return entry2.fullPath;
      }
      entryPath(entry2) {
        return sysPath.join(
          this.watchPath,
          sysPath.relative(this.watchPath, this.checkGlobSymlink(entry2))
        );
      }
      filterPath(entry2) {
        const { stats } = entry2;
        if (stats && stats.isSymbolicLink())
          return this.filterDir(entry2);
        const resolvedPath = this.entryPath(entry2);
        const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
        return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
      }
      getDirParts(path4) {
        if (!this.hasGlob)
          return [];
        const parts = [];
        const expandedPath = path4.includes(BRACE_START) ? braces.expand(path4) : [path4];
        expandedPath.forEach((path5) => {
          parts.push(sysPath.relative(this.watchPath, path5).split(SLASH_OR_BACK_SLASH_RE));
        });
        return parts;
      }
      filterDir(entry2) {
        if (this.hasGlob) {
          const entryParts = this.getDirParts(this.checkGlobSymlink(entry2));
          let globstar = false;
          this.unmatchedGlob = !this.dirParts.some((parts) => {
            return parts.every((part, i) => {
              if (part === GLOBSTAR)
                globstar = true;
              return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
            });
          });
        }
        return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry2), entry2.stats);
      }
    };
    FSWatcher = class extends EventEmitter$2 {
      // Not indenting methods for history sake; for now.
      constructor(_opts) {
        super();
        const opts = {};
        if (_opts)
          Object.assign(opts, _opts);
        this._watched = /* @__PURE__ */ new Map();
        this._closers = /* @__PURE__ */ new Map();
        this._ignoredPaths = /* @__PURE__ */ new Set();
        this._throttled = /* @__PURE__ */ new Map();
        this._symlinkPaths = /* @__PURE__ */ new Map();
        this._streams = /* @__PURE__ */ new Set();
        this.closed = false;
        if (undef(opts, "persistent"))
          opts.persistent = true;
        if (undef(opts, "ignoreInitial"))
          opts.ignoreInitial = false;
        if (undef(opts, "ignorePermissionErrors"))
          opts.ignorePermissionErrors = false;
        if (undef(opts, "interval"))
          opts.interval = 100;
        if (undef(opts, "binaryInterval"))
          opts.binaryInterval = 300;
        if (undef(opts, "disableGlobbing"))
          opts.disableGlobbing = false;
        opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
        if (undef(opts, "useFsEvents"))
          opts.useFsEvents = !opts.usePolling;
        const canUseFsEvents = FsEventsHandler2.canUse();
        if (!canUseFsEvents)
          opts.useFsEvents = false;
        if (undef(opts, "usePolling") && !opts.useFsEvents) {
          opts.usePolling = isMacos;
        }
        if (isIBMi) {
          opts.usePolling = true;
        }
        const envPoll = process.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== void 0) {
          const envLower = envPoll.toLowerCase();
          if (envLower === "false" || envLower === "0") {
            opts.usePolling = false;
          } else if (envLower === "true" || envLower === "1") {
            opts.usePolling = true;
          } else {
            opts.usePolling = !!envLower;
          }
        }
        const envInterval = process.env.CHOKIDAR_INTERVAL;
        if (envInterval) {
          opts.interval = Number.parseInt(envInterval, 10);
        }
        if (undef(opts, "atomic"))
          opts.atomic = !opts.usePolling && !opts.useFsEvents;
        if (opts.atomic)
          this._pendingUnlinks = /* @__PURE__ */ new Map();
        if (undef(opts, "followSymlinks"))
          opts.followSymlinks = true;
        if (undef(opts, "awaitWriteFinish"))
          opts.awaitWriteFinish = false;
        if (opts.awaitWriteFinish === true)
          opts.awaitWriteFinish = {};
        const awf = opts.awaitWriteFinish;
        if (awf) {
          if (!awf.stabilityThreshold)
            awf.stabilityThreshold = 2e3;
          if (!awf.pollInterval)
            awf.pollInterval = 100;
          this._pendingWrites = /* @__PURE__ */ new Map();
        }
        if (opts.ignored)
          opts.ignored = arrify(opts.ignored);
        let readyCalls = 0;
        this._emitReady = () => {
          readyCalls++;
          if (readyCalls >= this._readyCount) {
            this._emitReady = EMPTY_FN;
            this._readyEmitted = true;
            process.nextTick(() => this.emit(EV_READY));
          }
        };
        this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
        this._readyEmitted = false;
        this.options = opts;
        if (opts.useFsEvents) {
          this._fsEventsHandler = new FsEventsHandler2(this);
        } else {
          this._nodeFsHandler = new NodeFsHandler2(this);
        }
        Object.freeze(opts);
      }
      // Public methods
      /**
       * Adds paths to be watched on an existing FSWatcher instance
       * @param {Path|Array<Path>} paths_
       * @param {String=} _origAdd private; for handling non-existent paths to be watched
       * @param {Boolean=} _internal private; indicates a non-user add
       * @returns {FSWatcher} for chaining
       */
      add(paths_, _origAdd, _internal) {
        const { cwd, disableGlobbing } = this.options;
        this.closed = false;
        let paths = unifyPaths(paths_);
        if (cwd) {
          paths = paths.map((path4) => {
            const absPath = getAbsolutePath(path4, cwd);
            if (disableGlobbing || !isGlob2(path4)) {
              return absPath;
            }
            return normalizePath(absPath);
          });
        }
        paths = paths.filter((path4) => {
          if (path4.startsWith(BANG)) {
            this._ignoredPaths.add(path4.slice(1));
            return false;
          }
          this._ignoredPaths.delete(path4);
          this._ignoredPaths.delete(path4 + SLASH_GLOBSTAR);
          this._userIgnored = void 0;
          return true;
        });
        if (this.options.useFsEvents && this._fsEventsHandler) {
          if (!this._readyCount)
            this._readyCount = paths.length;
          if (this.options.persistent)
            this._readyCount *= 2;
          paths.forEach((path4) => this._fsEventsHandler._addToFsEvents(path4));
        } else {
          if (!this._readyCount)
            this._readyCount = 0;
          this._readyCount += paths.length;
          Promise.all(
            paths.map(async (path4) => {
              const res = await this._nodeFsHandler._addToNodeFs(path4, !_internal, 0, 0, _origAdd);
              if (res)
                this._emitReady();
              return res;
            })
          ).then((results) => {
            if (this.closed)
              return;
            results.filter((item) => item).forEach((item) => {
              this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
            });
          });
        }
        return this;
      }
      /**
       * Close watchers or start ignoring events from specified paths.
       * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
       * @returns {FSWatcher} for chaining
      */
      unwatch(paths_) {
        if (this.closed)
          return this;
        const paths = unifyPaths(paths_);
        const { cwd } = this.options;
        paths.forEach((path4) => {
          if (!sysPath.isAbsolute(path4) && !this._closers.has(path4)) {
            if (cwd)
              path4 = sysPath.join(cwd, path4);
            path4 = sysPath.resolve(path4);
          }
          this._closePath(path4);
          this._ignoredPaths.add(path4);
          if (this._watched.has(path4)) {
            this._ignoredPaths.add(path4 + SLASH_GLOBSTAR);
          }
          this._userIgnored = void 0;
        });
        return this;
      }
      /**
       * Close watchers and remove all listeners from watched paths.
       * @returns {Promise<void>}.
      */
      close() {
        if (this.closed)
          return this._closePromise;
        this.closed = true;
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList) => closerList.forEach((closer) => {
          const promise2 = closer();
          if (promise2 instanceof Promise)
            closers.push(promise2);
        }));
        this._streams.forEach((stream4) => stream4.destroy());
        this._userIgnored = void 0;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent) => dirent.dispose());
        ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key) => {
          this[`_${key}`].clear();
        });
        this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
        return this._closePromise;
      }
      /**
       * Expose list of watched paths
       * @returns {Object} for chaining
      */
      getWatched() {
        const watchList = {};
        this._watched.forEach((entry2, dir) => {
          const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
          watchList[key || ONE_DOT] = entry2.getChildren().sort();
        });
        return watchList;
      }
      emitWithAll(event, args) {
        this.emit(...args);
        if (event !== EV_ERROR)
          this.emit(EV_ALL, ...args);
      }
      // Common helpers
      // --------------
      /**
       * Normalize and emit events.
       * Calling _emit DOES NOT MEAN emit() would be called!
       * @param {EventName} event Type of event
       * @param {Path} path File or directory path
       * @param {*=} val1 arguments to be passed with event
       * @param {*=} val2
       * @param {*=} val3
       * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      async _emit(event, path4, val1, val2, val3) {
        if (this.closed)
          return;
        const opts = this.options;
        if (isWindows$1)
          path4 = sysPath.normalize(path4);
        if (opts.cwd)
          path4 = sysPath.relative(opts.cwd, path4);
        const args = [event, path4];
        if (val3 !== void 0)
          args.push(val1, val2, val3);
        else if (val2 !== void 0)
          args.push(val1, val2);
        else if (val1 !== void 0)
          args.push(val1);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path4))) {
          pw.lastChange = /* @__PURE__ */ new Date();
          return this;
        }
        if (opts.atomic) {
          if (event === EV_UNLINK) {
            this._pendingUnlinks.set(path4, args);
            setTimeout(() => {
              this._pendingUnlinks.forEach((entry2, path5) => {
                this.emit(...entry2);
                this.emit(EV_ALL, ...entry2);
                this._pendingUnlinks.delete(path5);
              });
            }, typeof opts.atomic === "number" ? opts.atomic : 100);
            return this;
          }
          if (event === EV_ADD && this._pendingUnlinks.has(path4)) {
            event = args[0] = EV_CHANGE;
            this._pendingUnlinks.delete(path4);
          }
        }
        if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
          const awfEmit = (err, stats) => {
            if (err) {
              event = args[0] = EV_ERROR;
              args[1] = err;
              this.emitWithAll(event, args);
            } else if (stats) {
              if (args.length > 2) {
                args[2] = stats;
              } else {
                args.push(stats);
              }
              this.emitWithAll(event, args);
            }
          };
          this._awaitWriteFinish(path4, awf.stabilityThreshold, event, awfEmit);
          return this;
        }
        if (event === EV_CHANGE) {
          const isThrottled = !this._throttle(EV_CHANGE, path4, 50);
          if (isThrottled)
            return this;
        }
        if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
          const fullPath = opts.cwd ? sysPath.join(opts.cwd, path4) : path4;
          let stats;
          try {
            stats = await stat(fullPath);
          } catch (err) {
          }
          if (!stats || this.closed)
            return;
          args.push(stats);
        }
        this.emitWithAll(event, args);
        return this;
      }
      /**
       * Common handler for errors
       * @param {Error} error
       * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      _handleError(error2) {
        const code = error2 && error2.code;
        if (error2 && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
          this.emit(EV_ERROR, error2);
        }
        return error2 || this.closed;
      }
      /**
       * Helper utility for throttling
       * @param {ThrottleType} actionType type being throttled
       * @param {Path} path being acted upon
       * @param {Number} timeout duration of time to suppress duplicate actions
       * @returns {Object|false} tracking object or false if action should be suppressed
       */
      _throttle(actionType, path4, timeout2) {
        if (!this._throttled.has(actionType)) {
          this._throttled.set(actionType, /* @__PURE__ */ new Map());
        }
        const action = this._throttled.get(actionType);
        const actionPath = action.get(path4);
        if (actionPath) {
          actionPath.count++;
          return false;
        }
        let timeoutObject;
        const clear = () => {
          const item = action.get(path4);
          const count = item ? item.count : 0;
          action.delete(path4);
          clearTimeout(timeoutObject);
          if (item)
            clearTimeout(item.timeoutObject);
          return count;
        };
        timeoutObject = setTimeout(clear, timeout2);
        const thr = { timeoutObject, clear, count: 0 };
        action.set(path4, thr);
        return thr;
      }
      _incrReadyCount() {
        return this._readyCount++;
      }
      /**
       * Awaits write operation to finish.
       * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
       * @param {Path} path being acted upon
       * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
       * @param {EventName} event
       * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
       */
      _awaitWriteFinish(path4, threshold, event, awfEmit) {
        let timeoutHandler;
        let fullPath = path4;
        if (this.options.cwd && !sysPath.isAbsolute(path4)) {
          fullPath = sysPath.join(this.options.cwd, path4);
        }
        const now = /* @__PURE__ */ new Date();
        const awaitWriteFinish = (prevStat) => {
          fs$5.stat(fullPath, (err, curStat) => {
            if (err || !this._pendingWrites.has(path4)) {
              if (err && err.code !== "ENOENT")
                awfEmit(err);
              return;
            }
            const now2 = Number(/* @__PURE__ */ new Date());
            if (prevStat && curStat.size !== prevStat.size) {
              this._pendingWrites.get(path4).lastChange = now2;
            }
            const pw = this._pendingWrites.get(path4);
            const df = now2 - pw.lastChange;
            if (df >= threshold) {
              this._pendingWrites.delete(path4);
              awfEmit(void 0, curStat);
            } else {
              timeoutHandler = setTimeout(
                awaitWriteFinish,
                this.options.awaitWriteFinish.pollInterval,
                curStat
              );
            }
          });
        };
        if (!this._pendingWrites.has(path4)) {
          this._pendingWrites.set(path4, {
            lastChange: now,
            cancelWait: () => {
              this._pendingWrites.delete(path4);
              clearTimeout(timeoutHandler);
              return event;
            }
          });
          timeoutHandler = setTimeout(
            awaitWriteFinish,
            this.options.awaitWriteFinish.pollInterval
          );
        }
      }
      _getGlobIgnored() {
        return [...this._ignoredPaths.values()];
      }
      /**
       * Determines whether user has asked to ignore this path.
       * @param {Path} path filepath or dir
       * @param {fs.Stats=} stats result of fs.stat
       * @returns {Boolean}
       */
      _isIgnored(path4, stats) {
        if (this.options.atomic && DOT_RE.test(path4))
          return true;
        if (!this._userIgnored) {
          const { cwd } = this.options;
          const ign = this.options.ignored;
          const ignored = ign && ign.map(normalizeIgnored(cwd));
          const paths = arrify(ignored).filter((path5) => typeof path5 === STRING_TYPE && !isGlob2(path5)).map((path5) => path5 + SLASH_GLOBSTAR);
          const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
          this._userIgnored = anymatch(list, void 0, ANYMATCH_OPTS);
        }
        return this._userIgnored([path4, stats]);
      }
      _isntIgnored(path4, stat2) {
        return !this._isIgnored(path4, stat2);
      }
      /**
       * Provides a set of common helpers and properties relating to symlink and glob handling.
       * @param {Path} path file, directory, or glob pattern being watched
       * @param {Number=} depth at any depth > 0, this isn't a glob
       * @returns {WatchHelper} object containing helpers for this path
       */
      _getWatchHelpers(path4, depth3) {
        const watchPath = depth3 || this.options.disableGlobbing || !isGlob2(path4) ? path4 : globParent2(path4);
        const follow = this.options.followSymlinks;
        return new WatchHelper(path4, watchPath, follow, this);
      }
      // Directory helpers
      // -----------------
      /**
       * Provides directory tracking objects
       * @param {String} directory path of the directory
       * @returns {DirEntry} the directory's tracking object
       */
      _getWatchedDir(directory) {
        if (!this._boundRemove)
          this._boundRemove = this._remove.bind(this);
        const dir = sysPath.resolve(directory);
        if (!this._watched.has(dir))
          this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
      }
      // File helpers
      // ------------
      /**
       * Check for read permissions.
       * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
       * @param {fs.Stats} stats - object, result of fs_stat
       * @returns {Boolean} indicates whether the file can be read
      */
      _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors)
          return true;
        const md = stats && Number.parseInt(stats.mode, 10);
        const st = md & 511;
        const it = Number.parseInt(st.toString(8)[0], 10);
        return Boolean(4 & it);
      }
      /**
       * Handles emitting unlink events for
       * files and directories, and via recursion, for
       * files and directories within directories that are unlinked
       * @param {String} directory within which the following item is located
       * @param {String} item      base path of item/directory
       * @returns {void}
      */
      _remove(directory, item, isDirectory) {
        const path4 = sysPath.join(directory, item);
        const fullPath = sysPath.resolve(path4);
        isDirectory = isDirectory != null ? isDirectory : this._watched.has(path4) || this._watched.has(fullPath);
        if (!this._throttle("remove", path4, 100))
          return;
        if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
          this.add(directory, item, true);
        }
        const wp = this._getWatchedDir(path4);
        const nestedDirectoryChildren = wp.getChildren();
        nestedDirectoryChildren.forEach((nested) => this._remove(path4, nested));
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        if (this._symlinkPaths.has(fullPath)) {
          this._symlinkPaths.delete(fullPath);
        }
        let relPath = path4;
        if (this.options.cwd)
          relPath = sysPath.relative(this.options.cwd, path4);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
          const event = this._pendingWrites.get(relPath).cancelWait();
          if (event === EV_ADD)
            return;
        }
        this._watched.delete(path4);
        this._watched.delete(fullPath);
        const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
        if (wasTracked && !this._isIgnored(path4))
          this._emit(eventName, path4);
        if (!this.options.useFsEvents) {
          this._closePath(path4);
        }
      }
      /**
       * Closes all watchers for a path
       * @param {Path} path
       */
      _closePath(path4) {
        this._closeFile(path4);
        const dir = sysPath.dirname(path4);
        this._getWatchedDir(dir).remove(sysPath.basename(path4));
      }
      /**
       * Closes only file-specific watchers
       * @param {Path} path
       */
      _closeFile(path4) {
        const closers = this._closers.get(path4);
        if (!closers)
          return;
        closers.forEach((closer) => closer());
        this._closers.delete(path4);
      }
      /**
       *
       * @param {Path} path
       * @param {Function} closer
       */
      _addPathCloser(path4, closer) {
        if (!closer)
          return;
        let list = this._closers.get(path4);
        if (!list) {
          list = [];
          this._closers.set(path4, list);
        }
        list.push(closer);
      }
      _readdirp(root, opts) {
        if (this.closed)
          return;
        const options2 = { type: EV_ALL, alwaysStat: true, lstat: true, ...opts };
        let stream4 = readdirp(root, options2);
        this._streams.add(stream4);
        stream4.once(STR_CLOSE, () => {
          stream4 = void 0;
        });
        stream4.once(STR_END, () => {
          if (stream4) {
            this._streams.delete(stream4);
            stream4 = void 0;
          }
        });
        return stream4;
      }
    };
    chokidar.FSWatcher = FSWatcher;
    watch2 = (paths, options2) => {
      const watcher = new FSWatcher(options2);
      watcher.add(paths);
      return watcher;
    };
    chokidar.watch = watch2;
    shellQuote$1 = {};
    shellQuote$1.quote = function(xs) {
      return xs.map(function(s) {
        if (s && typeof s === "object") {
          return s.op.replace(/(.)/g, "\\$1");
        } else if (/["\s]/.test(s) && !/'/.test(s)) {
          return "'" + s.replace(/(['\\])/g, "\\$1") + "'";
        } else if (/["'\s]/.test(s)) {
          return '"' + s.replace(/(["\\$`!])/g, "\\$1") + '"';
        } else {
          return String(s).replace(/([A-Za-z]:)?([#!"$&'()*,:;<=>?@\[\\\]^`{|}])/g, "$1\\$2");
        }
      }).join(" ");
    };
    CONTROL = "(?:" + [
      "\\|\\|",
      "\\&\\&",
      ";;",
      "\\|\\&",
      "\\<\\(",
      ">>",
      ">\\&",
      "[&;()|<>]"
    ].join("|") + ")";
    META = "|&;()<> \\t";
    BAREWORD = `(\\\\['"` + META + `]|[^\\s'"` + META + "])+";
    SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
    DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
    TOKEN = "";
    for (i = 0; i < 4; i++) {
      TOKEN += (Math.pow(16, 8) * Math.random()).toString(16);
    }
    shellQuote$1.parse = function(s, env3, opts) {
      var mapped = parse$5(s, env3, opts);
      if (typeof env3 !== "function")
        return mapped;
      return mapped.reduce(function(acc, s2) {
        if (typeof s2 === "object")
          return acc.concat(s2);
        var xs = s2.split(RegExp("(" + TOKEN + ".*?" + TOKEN + ")", "g"));
        if (xs.length === 1)
          return acc.concat(xs[0]);
        return acc.concat(xs.filter(Boolean).map(function(x) {
          if (RegExp("^" + TOKEN).test(x)) {
            return JSON.parse(x.split(TOKEN)[1]);
          } else
            return x;
        }));
      }, []);
    };
    try {
      new Function("throw new Error(1)")();
    } catch (e) {
      const match = /:(\d+):\d+\)$/.exec(e.stack.split("\n")[1]);
      offset3 = match ? +match[1] - 1 : 0;
    }
    bufferUtilExports = {};
    bufferUtil$1 = {
      get exports() {
        return bufferUtilExports;
      },
      set exports(v) {
        bufferUtilExports = v;
      }
    };
    constants2 = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
    ({ EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants2);
    FastBuffer$2 = Buffer[Symbol.species];
    bufferUtil$1.exports = {
      concat: concat$1,
      mask: _mask,
      toArrayBuffer: toArrayBuffer$1,
      toBuffer: toBuffer$2,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil2 = require2("bufferutil");
        bufferUtilExports.mask = function(source, mask, output, offset4, length) {
          if (length < 48)
            _mask(source, mask, output, offset4, length);
          else
            bufferUtil2.mask(source, mask, output, offset4, length);
        };
        bufferUtilExports.unmask = function(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil2.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
    kDone = Symbol("kDone");
    kRun = Symbol("kRun");
    Limiter$1 = class Limiter {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    limiter = Limiter$1;
    zlib = import_zlib.default;
    bufferUtil = bufferUtilExports;
    Limiter2 = limiter;
    ({ kStatusCode: kStatusCode$2 } = constants2);
    FastBuffer$1 = Buffer[Symbol.species];
    TRAILER = Buffer.from([0, 0, 255, 255]);
    kPerMessageDeflate = Symbol("permessage-deflate");
    kTotalLength = Symbol("total-length");
    kCallback = Symbol("callback");
    kBuffers = Symbol("buffers");
    kError$1 = Symbol("error");
    PerMessageDeflate$4 = class PerMessageDeflate {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options2, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options2 || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter2(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value2 = params[key];
            if (value2.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value2 = value2[0];
            if (key === "client_max_window_bits") {
              if (value2 !== true) {
                const num = +value2;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value2}`
                  );
                }
                value2 = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value2}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value2;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value2}`
                );
              }
              value2 = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value2 !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value2}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value2;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data3, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data3, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data3, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data3, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data3, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data3);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError$1];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data4 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data4);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data3, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data3);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data4 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data4 = new FastBuffer$1(data4.buffer, data4.byteOffset, data4.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data4);
        });
      }
    };
    permessageDeflate = PerMessageDeflate$4;
    validationExports = {};
    validation = {
      get exports() {
        return validationExports;
      },
      set exports(v) {
        validationExports = v;
      }
    };
    ({ isUtf8 } = import_buffer.default);
    tokenChars$2 = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    validation.exports = {
      isValidStatusCode: isValidStatusCode$2,
      isValidUTF8: _isValidUTF8,
      tokenChars: tokenChars$2
    };
    if (isUtf8) {
      validationExports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF82 = require2("utf-8-validate");
        validationExports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF82(buf);
        };
      } catch (e) {
      }
    }
    ({ Writable: Writable$1 } = import_stream.default);
    PerMessageDeflate$3 = permessageDeflate;
    ({
      BINARY_TYPES: BINARY_TYPES$1,
      EMPTY_BUFFER: EMPTY_BUFFER$2,
      kStatusCode: kStatusCode$1,
      kWebSocket: kWebSocket$2
    } = constants2);
    ({ concat, toArrayBuffer, unmask } = bufferUtilExports);
    ({ isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validationExports);
    FastBuffer = Buffer[Symbol.species];
    GET_INFO = 0;
    GET_PAYLOAD_LENGTH_16 = 1;
    GET_PAYLOAD_LENGTH_64 = 2;
    GET_MASK = 3;
    GET_DATA = 4;
    INFLATING = 5;
    Receiver$1 = class Receiver extends Writable$1 {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options2 = {}) {
        super();
        this._binaryType = options2.binaryType || BINARY_TYPES$1[0];
        this._extensions = options2.extensions || {};
        this._isServer = !!options2.isServer;
        this._maxPayload = options2.maxPayload | 0;
        this._skipUTF8Validation = !!options2.skipUTF8Validation;
        this[kWebSocket$2] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n2) {
        this._bufferedBytes -= n2;
        if (n2 === this._buffers[0].length)
          return this._buffers.shift();
        if (n2 < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n2,
            buf.length - n2
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n2);
        }
        const dst = Buffer.allocUnsafe(n2);
        do {
          const buf = this._buffers[0];
          const offset4 = dst.length - n2;
          if (n2 >= buf.length) {
            dst.set(this._buffers.shift(), offset4);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n2), offset4);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n2,
              buf.length - n2
            );
          }
          n2 -= buf.length;
        } while (n2 > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data3 = EMPTY_BUFFER$2;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data3 = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data3, this._mask);
          }
        }
        if (this._opcode > 7)
          return this.controlMessage(data3);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data3, cb);
          return;
        }
        if (data3.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data3);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data3, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];
        perMessageDeflate.decompress(data3, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data3;
            if (this._binaryType === "nodebuffer") {
              data3 = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data3 = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data3 = fragments;
            }
            this.emit("message", data3, true);
          } else {
            const buf = concat(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data3) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data3.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER$2);
            this.end();
          } else {
            const code = data3.readUInt16BE(0);
            if (!isValidStatusCode$1(code)) {
              return error(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = new FastBuffer(
              data3.buffer,
              data3.byteOffset + 2,
              data3.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data3);
        } else {
          this.emit("pong", data3);
        }
        this._state = GET_INFO;
      }
    };
    receiver = Receiver$1;
    ({ randomFillSync } = import_crypto.default);
    PerMessageDeflate$2 = permessageDeflate;
    ({ EMPTY_BUFFER: EMPTY_BUFFER$1 } = constants2);
    ({ isValidStatusCode } = validationExports);
    ({ mask: applyMask, toBuffer: toBuffer$1 } = bufferUtilExports);
    kByteLength = Symbol("kByteLength");
    maskBuffer = Buffer.alloc(4);
    Sender$1 = class Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions3, generateMask) {
        this._extensions = extensions3 || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data3, options2) {
        let mask;
        let merge = false;
        let offset4 = 2;
        let skipMasking = false;
        if (options2.mask) {
          mask = options2.maskBuffer || maskBuffer;
          if (options2.generateMask) {
            options2.generateMask(mask);
          } else {
            randomFillSync(mask, 0, 4);
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset4 = 6;
        }
        let dataLength;
        if (typeof data3 === "string") {
          if ((!options2.mask || skipMasking) && options2[kByteLength] !== void 0) {
            dataLength = options2[kByteLength];
          } else {
            data3 = Buffer.from(data3);
            dataLength = data3.length;
          }
        } else {
          dataLength = data3.length;
          merge = options2.mask && options2.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset4 += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset4 += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset4 : offset4);
        target[0] = options2.fin ? options2.opcode | 128 : options2.opcode;
        if (options2.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options2.mask)
          return [target, data3];
        target[1] |= 128;
        target[offset4 - 4] = mask[0];
        target[offset4 - 3] = mask[1];
        target[offset4 - 2] = mask[2];
        target[offset4 - 1] = mask[3];
        if (skipMasking)
          return [target, data3];
        if (merge) {
          applyMask(data3, mask, target, offset4, dataLength);
          return [target];
        }
        applyMask(data3, mask, data3, 0, dataLength);
        return [target, data3];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data3, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER$1;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data3 === void 0 || !data3.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data3);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data3 === "string") {
            buf.write(data3, 2);
          } else {
            buf.set(data3, 2);
          }
        }
        const options2 = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options2, cb]);
        } else {
          this.sendFrame(Sender.frame(buf, options2), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data3, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data3 === "string") {
          byteLength = Buffer.byteLength(data3);
          readOnly = false;
        } else {
          data3 = toBuffer$1(data3);
          byteLength = data3.length;
          readOnly = toBuffer$1.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options2 = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data3, false, options2, cb]);
        } else {
          this.sendFrame(Sender.frame(data3, options2), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data3, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data3 === "string") {
          byteLength = Buffer.byteLength(data3);
          readOnly = false;
        } else {
          data3 = toBuffer$1(data3);
          byteLength = data3.length;
          readOnly = toBuffer$1.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options2 = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data3, false, options2, cb]);
        } else {
          this.sendFrame(Sender.frame(data3, options2), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data3, options2, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
        let opcode = options2.binary ? 2 : 1;
        let rsv1 = options2.compress;
        let byteLength;
        let readOnly;
        if (typeof data3 === "string") {
          byteLength = Buffer.byteLength(data3);
          readOnly = false;
        } else {
          data3 = toBuffer$1(data3);
          byteLength = data3.length;
          readOnly = toBuffer$1.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options2.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options2.fin,
            generateMask: this._generateMask,
            mask: options2.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data3, this._compress, opts, cb]);
          } else {
            this.dispatch(data3, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            Sender.frame(data3, {
              [kByteLength]: byteLength,
              fin: options2.fin,
              generateMask: this._generateMask,
              mask: options2.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1: false
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data3, compress, options2, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data3, options2), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
        this._bufferedBytes += options2[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data3, options2.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const params = this._queue[i];
              const callback = params[params.length - 1];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= options2[kByteLength];
          this._deflating = false;
          options2.readOnly = false;
          this.sendFrame(Sender.frame(buf, options2), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    sender = Sender$1;
    ({ kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants2);
    kCode = Symbol("kCode");
    kData = Symbol("kData");
    kError = Symbol("kError");
    kMessage = Symbol("kMessage");
    kReason = Symbol("kReason");
    kTarget = Symbol("kTarget");
    kType = Symbol("kType");
    kWasClean = Symbol("kWasClean");
    Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options2 = {}) {
        super(type);
        this[kCode] = options2.code === void 0 ? 0 : options2.code;
        this[kReason] = options2.reason === void 0 ? "" : options2.reason;
        this[kWasClean] = options2.wasClean === void 0 ? false : options2.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options2 = {}) {
        super(type);
        this[kError] = options2.error === void 0 ? null : options2.error;
        this[kMessage] = options2.message === void 0 ? "" : options2.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options2 = {}) {
        super(type);
        this[kData] = options2.data === void 0 ? null : options2.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options2 = {}) {
        for (const listener2 of this.listeners(type)) {
          if (!options2[kForOnEventAttribute$1] && listener2[kListener$1] === handler && !listener2[kForOnEventAttribute$1]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data3, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data3 : data3.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error2) {
            const event = new ErrorEvent("error", {
              error: error2,
              message: error2.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute$1] = !!options2[kForOnEventAttribute$1];
        wrapper[kListener$1] = handler;
        if (options2.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener2 of this.listeners(type)) {
          if (listener2[kListener$1] === handler && !listener2[kForOnEventAttribute$1]) {
            this.removeListener(type, listener2);
            break;
          }
        }
      }
    };
    eventTarget = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    ({ tokenChars: tokenChars$1 } = validationExports);
    extension$1 = { format: format$1, parse: parse$4 };
    EventEmitter$1 = import_events.default;
    https$2 = import_https.default;
    http$3 = import_http.default;
    net = import_net.default;
    tls = import_tls.default;
    ({ randomBytes, createHash: createHash$12 } = import_crypto.default);
    ({ URL: URL$2 } = import_url.default);
    PerMessageDeflate$1 = permessageDeflate;
    Receiver2 = receiver;
    Sender2 = sender;
    ({
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID: GUID$1,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket: kWebSocket$1,
      NOOP
    } = constants2);
    ({
      EventTarget: { addEventListener, removeEventListener }
    } = eventTarget);
    ({ format, parse: parse$3 } = extension$1);
    ({ toBuffer } = bufferUtilExports);
    closeTimeout = 30 * 1e3;
    kAborted = Symbol("kAborted");
    protocolVersions = [8, 13];
    readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    WebSocket$1 = class WebSocket extends EventEmitter$1 {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options2) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options2 = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options2);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options2) {
        const receiver2 = new Receiver2({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options2.maxPayload,
          skipUTF8Validation: options2.skipUTF8Validation
        });
        this._sender = new Sender2(socket, this._extensions, options2.generateMask);
        this._receiver = receiver2;
        this._socket = socket;
        receiver2[kWebSocket$1] = this;
        socket[kWebSocket$1] = this;
        receiver2.on("conclude", receiverOnConclude);
        receiver2.on("drain", receiverOnDrain);
        receiver2.on("error", receiverOnError);
        receiver2.on("message", receiverOnMessage);
        receiver2.on("ping", receiverOnPing);
        receiver2.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError$1);
        this._readyState = WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate$1.extensionName]) {
          this._extensions[PerMessageDeflate$1.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data3) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake$1(this, this._req, msg);
          return;
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data3, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data3, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data3 === "function") {
          cb = data3;
          data3 = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data3 === "number")
          data3 = data3.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data3, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data3 || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data3, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data3 === "function") {
          cb = data3;
          data3 = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data3 === "number")
          data3 = data3.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data3, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data3 || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data3, options2, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options2 === "function") {
          cb = options2;
          options2 = {};
        }
        if (typeof data3 === "number")
          data3 = data3.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data3, cb);
          return;
        }
        const opts = {
          binary: typeof data3 !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options2
        };
        if (!this._extensions[PerMessageDeflate$1.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data3 || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake$1(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket$1, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket$1.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket$1, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket$1.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket$1, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket$1.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket$1, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket$1.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket$1.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket$1.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener2 of this.listeners(method)) {
            if (listener2[kForOnEventAttribute])
              return listener2[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener2 of this.listeners(method)) {
            if (listener2[kForOnEventAttribute]) {
              this.removeListener(method, listener2);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket$1.prototype.addEventListener = addEventListener;
    WebSocket$1.prototype.removeEventListener = removeEventListener;
    ({ tokenChars } = validationExports);
    ({ createHash } = import_crypto.default);
    ({ GUID, kWebSocket } = constants2);
    httpProxyExports$1 = {};
    httpProxy$3 = {
      get exports() {
        return httpProxyExports$1;
      },
      set exports(v) {
        httpProxyExports$1 = v;
      }
    };
    httpProxyExports = {};
    httpProxy$2 = {
      get exports() {
        return httpProxyExports;
      },
      set exports(v) {
        httpProxyExports = v;
      }
    };
    eventemitter3Exports = {};
    eventemitter3 = {
      get exports() {
        return eventemitter3Exports;
      },
      set exports(v) {
        eventemitter3Exports = v;
      }
    };
    (function(module2) {
      var has = Object.prototype.hasOwnProperty, prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context, once2) {
        this.fn = fn;
        this.context = context;
        this.once = once2 || false;
      }
      function addListener(emitter, event, fn, context, once2) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener2 = new EE(fn, context || emitter, once2), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener2, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener2);
        else
          emitter._events[evt] = [emitter._events[evt], listener2];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events2, name2;
        if (this._eventsCount === 0)
          return names;
        for (name2 in events2 = this._events) {
          if (has.call(events2, name2))
            names.push(prefix ? name2.slice(1) : name2);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events2));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once)
              this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once2(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once2) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once2 || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once2 && !listeners[i].once || context && listeners[i].context !== context) {
              events2.push(listeners[i]);
            }
          }
          if (events2.length)
            this._events[evt] = events2.length === 1 ? events2[0] : events2;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      {
        module2.exports = EventEmitter2;
      }
    })(eventemitter3);
    common$3 = {};
    requiresPort = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port)
        return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
    (function(exports2) {
      var common2 = exports2, url2 = import_url.default, extend3 = import_util.default._extend, required2 = requiresPort;
      var upgradeHeader = /(^|,)\s*upgrade\s*($|,)/i, isSSL = /^https|wss/;
      common2.isSSL = isSSL;
      common2.setupOutgoing = function(outgoing, options2, req2, forward) {
        outgoing.port = options2[forward || "target"].port || (isSSL.test(options2[forward || "target"].protocol) ? 443 : 80);
        [
          "host",
          "hostname",
          "socketPath",
          "pfx",
          "key",
          "passphrase",
          "cert",
          "ca",
          "ciphers",
          "secureProtocol"
        ].forEach(
          function(e) {
            outgoing[e] = options2[forward || "target"][e];
          }
        );
        outgoing.method = options2.method || req2.method;
        outgoing.headers = extend3({}, req2.headers);
        if (options2.headers) {
          extend3(outgoing.headers, options2.headers);
        }
        if (options2.auth) {
          outgoing.auth = options2.auth;
        }
        if (options2.ca) {
          outgoing.ca = options2.ca;
        }
        if (isSSL.test(options2[forward || "target"].protocol)) {
          outgoing.rejectUnauthorized = typeof options2.secure === "undefined" ? true : options2.secure;
        }
        outgoing.agent = options2.agent || false;
        outgoing.localAddress = options2.localAddress;
        if (!outgoing.agent) {
          outgoing.headers = outgoing.headers || {};
          if (typeof outgoing.headers.connection !== "string" || !upgradeHeader.test(outgoing.headers.connection)) {
            outgoing.headers.connection = "close";
          }
        }
        var target = options2[forward || "target"];
        var targetPath = target && options2.prependPath !== false ? target.path || "" : "";
        var outgoingPath = !options2.toProxy ? url2.parse(req2.url).path || "" : req2.url;
        outgoingPath = !options2.ignorePath ? outgoingPath : "";
        outgoing.path = common2.urlJoin(targetPath, outgoingPath);
        if (options2.changeOrigin) {
          outgoing.headers.host = required2(outgoing.port, options2[forward || "target"].protocol) && !hasPort(outgoing.host) ? outgoing.host + ":" + outgoing.port : outgoing.host;
        }
        return outgoing;
      };
      common2.setupSocket = function(socket) {
        socket.setTimeout(0);
        socket.setNoDelay(true);
        socket.setKeepAlive(true, 0);
        return socket;
      };
      common2.getPort = function(req2) {
        var res = req2.headers.host ? req2.headers.host.match(/:(\d+)/) : "";
        return res ? res[1] : common2.hasEncryptedConnection(req2) ? "443" : "80";
      };
      common2.hasEncryptedConnection = function(req2) {
        return Boolean(req2.connection.encrypted || req2.connection.pair);
      };
      common2.urlJoin = function() {
        var args = Array.prototype.slice.call(arguments), lastIndex = args.length - 1, last = args[lastIndex], lastSegs = last.split("?"), retSegs;
        args[lastIndex] = lastSegs.shift();
        retSegs = [
          args.filter(Boolean).join("/").replace(/\/+/g, "/").replace("http:/", "http://").replace("https:/", "https://")
        ];
        retSegs.push.apply(retSegs, lastSegs);
        return retSegs.join("?");
      };
      common2.rewriteCookieProperty = function rewriteCookieProperty(header, config2, property) {
        if (Array.isArray(header)) {
          return header.map(function(headerElement) {
            return rewriteCookieProperty(headerElement, config2, property);
          });
        }
        return header.replace(new RegExp("(;\\s*" + property + "=)([^;]+)", "i"), function(match, prefix, previousValue) {
          var newValue;
          if (previousValue in config2) {
            newValue = config2[previousValue];
          } else if ("*" in config2) {
            newValue = config2["*"];
          } else {
            return match;
          }
          if (newValue) {
            return prefix + newValue;
          } else {
            return "";
          }
        });
      };
      function hasPort(host) {
        return !!~host.indexOf(":");
      }
    })(common$3);
    url$1 = import_url.default;
    common$2 = common$3;
    redirectRegex = /^201|30(1|2|7|8)$/;
    webOutgoing = {
      // <--
      /**
       * If is a HTTP 1.0 request, remove chunk headers
       *
       * @param {ClientRequest} Req Request object
       *@param {IncomingMessage} Res Response object
       * @param {proxyResponse} Res Response object from the proxy request
       *
       * @api private
       */
      removeChunked: function removeChunked(req2, res, proxyRes) {
        if (req2.httpVersion === "1.0") {
          delete proxyRes.headers["transfer-encoding"];
        }
      },
      /**
       * If is a HTTP 1.0 request, set the correct connection header
       * or if connection header not present, then use `keep-alive`
       *
       * @param {ClientRequest} Req Request object
       *@param {IncomingMessage} Res Response object
       * @param {proxyResponse} Res Response object from the proxy request
       *
       * @api private
       */
      setConnection: function setConnection(req2, res, proxyRes) {
        if (req2.httpVersion === "1.0") {
          proxyRes.headers.connection = req2.headers.connection || "close";
        } else if (req2.httpVersion !== "2.0" && !proxyRes.headers.connection) {
          proxyRes.headers.connection = req2.headers.connection || "keep-alive";
        }
      },
      setRedirectHostRewrite: function setRedirectHostRewrite(req2, res, proxyRes, options2) {
        if ((options2.hostRewrite || options2.autoRewrite || options2.protocolRewrite) && proxyRes.headers["location"] && redirectRegex.test(proxyRes.statusCode)) {
          var target = url$1.parse(options2.target);
          var u = url$1.parse(proxyRes.headers["location"]);
          if (target.host != u.host) {
            return;
          }
          if (options2.hostRewrite) {
            u.host = options2.hostRewrite;
          } else if (options2.autoRewrite) {
            u.host = req2.headers["host"];
          }
          if (options2.protocolRewrite) {
            u.protocol = options2.protocolRewrite;
          }
          proxyRes.headers["location"] = u.format();
        }
      },
      /**
       * Copy headers from proxyResponse to response
       * set each header in response object.
       *
       * @param {ClientRequest} Req Request object
       *@param {IncomingMessage} Res Response object
       * @param {proxyResponse} Res Response object from the proxy request
       * @param {Object} Options options.cookieDomainRewrite: Config to rewrite cookie domain
       *
       * @api private
       */
      writeHeaders: function writeHeaders(req2, res, proxyRes, options2) {
        var rewriteCookieDomainConfig = options2.cookieDomainRewrite, rewriteCookiePathConfig = options2.cookiePathRewrite, preserveHeaderKeyCase = options2.preserveHeaderKeyCase, rawHeaderKeyMap, setHeader = function(key2, header) {
          if (header == void 0)
            return;
          if (rewriteCookieDomainConfig && key2.toLowerCase() === "set-cookie") {
            header = common$2.rewriteCookieProperty(header, rewriteCookieDomainConfig, "domain");
          }
          if (rewriteCookiePathConfig && key2.toLowerCase() === "set-cookie") {
            header = common$2.rewriteCookieProperty(header, rewriteCookiePathConfig, "path");
          }
          res.setHeader(String(key2).trim(), header);
        };
        if (typeof rewriteCookieDomainConfig === "string") {
          rewriteCookieDomainConfig = { "*": rewriteCookieDomainConfig };
        }
        if (typeof rewriteCookiePathConfig === "string") {
          rewriteCookiePathConfig = { "*": rewriteCookiePathConfig };
        }
        if (preserveHeaderKeyCase && proxyRes.rawHeaders != void 0) {
          rawHeaderKeyMap = {};
          for (var i = 0; i < proxyRes.rawHeaders.length; i += 2) {
            var key = proxyRes.rawHeaders[i];
            rawHeaderKeyMap[key.toLowerCase()] = key;
          }
        }
        Object.keys(proxyRes.headers).forEach(function(key2) {
          var header = proxyRes.headers[key2];
          if (preserveHeaderKeyCase && rawHeaderKeyMap) {
            key2 = rawHeaderKeyMap[key2] || key2;
          }
          setHeader(key2, header);
        });
      },
      /**
       * Set the statusCode from the proxyResponse
       *
       * @param {ClientRequest} Req Request object
       *@param {IncomingMessage} Res Response object
       * @param {proxyResponse} Res Response object from the proxy request
       *
       * @api private
       */
      writeStatusCode: function writeStatusCode(req2, res, proxyRes) {
        if (proxyRes.statusMessage) {
          res.statusCode = proxyRes.statusCode;
          res.statusMessage = proxyRes.statusMessage;
        } else {
          res.statusCode = proxyRes.statusCode;
        }
      }
    };
    followRedirectsExports = {};
    followRedirects$1 = {
      get exports() {
        return followRedirectsExports;
      },
      set exports(v) {
        followRedirectsExports = v;
      }
    };
    debug_1 = function() {
      if (!debug$3) {
        try {
          debug$3 = srcExports$1("follow-redirects");
        } catch (error2) {
        }
        if (typeof debug$3 !== "function") {
          debug$3 = function() {
          };
        }
      }
      debug$3.apply(null, arguments);
    };
    url = import_url.default;
    URL$1 = url.URL;
    http$1 = import_http.default;
    https$1 = import_https.default;
    Writable = import_stream.default.Writable;
    assert = import_assert.default;
    debug$2 = debug_1;
    events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded"
    );
    MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data3, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!(typeof data3 === "string" || typeof data3 === "object" && "length" in data3)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (data3.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data3.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data3.length;
        this._requestBodyBuffers.push({ data: data3, encoding });
        this._currentRequest.write(data3, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data3, encoding, callback) {
      if (typeof data3 === "function") {
        callback = data3;
        data3 = encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (!data3) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data3, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name2, value2) {
      this._options.headers[name2] = value2;
      this._currentRequest.setHeader(name2, value2);
    };
    RedirectableRequest.prototype.removeHeader = function(name2) {
      delete this._options.headers[name2];
      this._currentRequest.removeHeader(name2);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options2) {
      if (!options2.headers) {
        options2.headers = {};
      }
      if (options2.host) {
        if (!options2.hostname) {
          options2.hostname = options2.host;
        }
        delete options2.host;
      }
      if (!options2.pathname && options2.path) {
        var searchPos = options2.path.indexOf("?");
        if (searchPos < 0) {
          options2.pathname = options2.path;
        } else {
          options2.pathname = options2.path.substring(0, searchPos);
          options2.search = options2.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      this._currentUrl = url.format(this._options);
      request._redirectable = this;
      for (var e = 0; e < events.length; e++) {
        request.on(events[e], eventHandlers[events[e]]);
      }
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error2) {
          if (request === self2._currentRequest) {
            if (error2) {
              self2.emit("error", error2);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location2 = response.headers.location;
      if (!location2 || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      abortRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = url.parse(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location2) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl;
      try {
        redirectUrl = url.resolve(currentUrl, location2);
      } catch (cause) {
        this.emit("error", new RedirectionError(cause));
        return;
      }
      debug$2("redirecting to", redirectUrl);
      this._isRedirect = true;
      var redirectUrlParts = url.parse(redirectUrl);
      Object.assign(this._options, redirectUrlParts);
      if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
      }
      if (typeof beforeRedirect === "function") {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        try {
          beforeRedirect(this._options, responseDetails, requestDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        this.emit("error", new RedirectionError(cause));
      }
    };
    followRedirects$1.exports = wrap({ http: http$1, https: https$1 });
    followRedirectsExports.wrap = wrap;
    httpNative = import_http.default;
    httpsNative = import_https.default;
    web_o = webOutgoing;
    common$1 = common$3;
    followRedirects = followRedirectsExports;
    web_o = Object.keys(web_o).map(function(pass) {
      return web_o[pass];
    });
    nativeAgents = { http: httpNative, https: httpsNative };
    webIncoming = {
      /**
       * Sets `content-length` to '0' if request is of DELETE type.
       *
       * @param {ClientRequest} Req Request object
       *@param {IncomingMessage} Res Response object
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      deleteLength: function deleteLength(req2, res, options2) {
        if ((req2.method === "DELETE" || req2.method === "OPTIONS") && !req2.headers["content-length"]) {
          req2.headers["content-length"] = "0";
          delete req2.headers["transfer-encoding"];
        }
      },
      /**
       * Sets timeout in request socket if it was specified in options.
       *
       * @param {ClientRequest} Req Request object
       *@param {IncomingMessage} Res Response object
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      timeout: function timeout(req2, res, options2) {
        if (options2.timeout) {
          req2.socket.setTimeout(options2.timeout);
        }
      },
      /**
       * Sets `x-forwarded-*` headers if specified in config.
       *
       * @param {ClientRequest} Req Request object
       *@param {IncomingMessage} Res Response object
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      XHeaders: function XHeaders(req2, res, options2) {
        if (!options2.xfwd)
          return;
        var encrypted = req2.isSpdy || common$1.hasEncryptedConnection(req2);
        var values = {
          for: req2.connection.remoteAddress || req2.socket.remoteAddress,
          port: common$1.getPort(req2),
          proto: encrypted ? "https" : "http"
        };
        ["for", "port", "proto"].forEach(function(header) {
          req2.headers["x-forwarded-" + header] = (req2.headers["x-forwarded-" + header] || "") + (req2.headers["x-forwarded-" + header] ? "," : "") + values[header];
        });
        req2.headers["x-forwarded-host"] = req2.headers["x-forwarded-host"] || req2.headers["host"] || "";
      },
      /**
       * Does the actual proxying. If `forward` is enabled fires up
       * a ForwardStream, same happens for ProxyStream. The request
       * just dies otherwise.
       *
       * @param {ClientRequest} Req Request object
       *@param {IncomingMessage} Res Response object
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      stream: function stream2(req2, res, options2, _, server, clb) {
        server.emit("start", req2, res, options2.target || options2.forward);
        var agents = options2.followRedirects ? followRedirects : nativeAgents;
        var http2 = agents.http;
        var https2 = agents.https;
        if (options2.forward) {
          var forwardReq = (options2.forward.protocol === "https:" ? https2 : http2).request(
            common$1.setupOutgoing(options2.ssl || {}, options2, req2, "forward")
          );
          var forwardError = createErrorHandler(forwardReq, options2.forward);
          req2.on("error", forwardError);
          forwardReq.on("error", forwardError);
          (options2.buffer || req2).pipe(forwardReq);
          if (!options2.target) {
            return res.end();
          }
        }
        var proxyReq = (options2.target.protocol === "https:" ? https2 : http2).request(
          common$1.setupOutgoing(options2.ssl || {}, options2, req2)
        );
        proxyReq.on("socket", function(socket) {
          if (server && !proxyReq.getHeader("expect")) {
            server.emit("proxyReq", proxyReq, req2, res, options2);
          }
        });
        if (options2.proxyTimeout) {
          proxyReq.setTimeout(options2.proxyTimeout, function() {
            proxyReq.abort();
          });
        }
        req2.on("aborted", function() {
          proxyReq.abort();
        });
        var proxyError = createErrorHandler(proxyReq, options2.target);
        req2.on("error", proxyError);
        proxyReq.on("error", proxyError);
        function createErrorHandler(proxyReq2, url2) {
          return function proxyError2(err) {
            if (req2.socket.destroyed && err.code === "ECONNRESET") {
              server.emit("econnreset", err, req2, res, url2);
              return proxyReq2.abort();
            }
            if (clb) {
              clb(err, req2, res, url2);
            } else {
              server.emit("error", err, req2, res, url2);
            }
          };
        }
        (options2.buffer || req2).pipe(proxyReq);
        proxyReq.on("response", function(proxyRes) {
          if (server) {
            server.emit("proxyRes", proxyRes, req2, res);
          }
          if (!res.headersSent && !options2.selfHandleResponse) {
            for (var i = 0; i < web_o.length; i++) {
              if (web_o[i](req2, res, proxyRes, options2)) {
                break;
              }
            }
          }
          if (!res.finished) {
            proxyRes.on("end", function() {
              if (server)
                server.emit("end", req2, res, proxyRes);
            });
            if (!options2.selfHandleResponse)
              proxyRes.pipe(res);
          } else {
            if (server)
              server.emit("end", req2, res, proxyRes);
          }
        });
      }
    };
    http = import_http.default;
    https = import_https.default;
    common = common$3;
    wsIncoming = {
      /**
       * WebSocket requests must have the `GET` method and
       * the `upgrade:websocket` header
       *
       * @param {ClientRequest} Req Request object
       *@param {Socket} Websocket
       *
       * @api private
       */
      checkMethodAndHeader: function checkMethodAndHeader(req2, socket) {
        if (req2.method !== "GET" || !req2.headers.upgrade) {
          socket.destroy();
          return true;
        }
        if (req2.headers.upgrade.toLowerCase() !== "websocket") {
          socket.destroy();
          return true;
        }
      },
      /**
       * Sets `x-forwarded-*` headers if specified in config.
       *
       * @param {ClientRequest} Req Request object
       *@param {Socket} Websocket
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      XHeaders: function XHeaders2(req2, socket, options2) {
        if (!options2.xfwd)
          return;
        var values = {
          for: req2.connection.remoteAddress || req2.socket.remoteAddress,
          port: common.getPort(req2),
          proto: common.hasEncryptedConnection(req2) ? "wss" : "ws"
        };
        ["for", "port", "proto"].forEach(function(header) {
          req2.headers["x-forwarded-" + header] = (req2.headers["x-forwarded-" + header] || "") + (req2.headers["x-forwarded-" + header] ? "," : "") + values[header];
        });
      },
      /**
       * Does the actual proxying. Make the request and upgrade it
       * send the Switching Protocols request and pipe the sockets.
       *
       * @param {ClientRequest} Req Request object
       *@param {Socket} Websocket
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      stream: function stream3(req2, socket, options2, head, server, clb) {
        var createHttpHeader = function(line, headers) {
          return Object.keys(headers).reduce(function(head2, key) {
            var value2 = headers[key];
            if (!Array.isArray(value2)) {
              head2.push(key + ": " + value2);
              return head2;
            }
            for (var i = 0; i < value2.length; i++) {
              head2.push(key + ": " + value2[i]);
            }
            return head2;
          }, [line]).join("\r\n") + "\r\n\r\n";
        };
        common.setupSocket(socket);
        if (head && head.length)
          socket.unshift(head);
        var proxyReq = (common.isSSL.test(options2.target.protocol) ? https : http).request(
          common.setupOutgoing(options2.ssl || {}, options2, req2)
        );
        if (server) {
          server.emit("proxyReqWs", proxyReq, req2, socket, options2, head);
        }
        proxyReq.on("error", onOutgoingError);
        proxyReq.on("response", function(res) {
          if (!res.upgrade) {
            socket.write(createHttpHeader("HTTP/" + res.httpVersion + " " + res.statusCode + " " + res.statusMessage, res.headers));
            res.pipe(socket);
          }
        });
        proxyReq.on("upgrade", function(proxyRes, proxySocket, proxyHead) {
          proxySocket.on("error", onOutgoingError);
          proxySocket.on("end", function() {
            server.emit("close", proxyRes, proxySocket, proxyHead);
          });
          socket.on("error", function() {
            proxySocket.end();
          });
          common.setupSocket(proxySocket);
          if (proxyHead && proxyHead.length)
            proxySocket.unshift(proxyHead);
          socket.write(createHttpHeader("HTTP/1.1 101 Switching Protocols", proxyRes.headers));
          proxySocket.pipe(socket).pipe(proxySocket);
          server.emit("open", proxySocket);
          server.emit("proxySocket", proxySocket);
        });
        return proxyReq.end();
        function onOutgoingError(err) {
          if (clb) {
            clb(err, req2, socket);
          } else {
            server.emit("error", err, req2, socket);
          }
          socket.end();
        }
      }
    };
    (function(module2) {
      var httpProxy = module2.exports, extend3 = import_util.default._extend, parse_url = import_url.default.parse, EE3 = eventemitter3Exports, http2 = import_http.default, https2 = import_https.default, web = webIncoming, ws = wsIncoming;
      httpProxy.Server = ProxyServer2;
      function createRightProxy(type) {
        return function(options2) {
          return function(req2, res) {
            var passes = type === "ws" ? this.wsPasses : this.webPasses, args = [].slice.call(arguments), cntr = args.length - 1, head, cbl;
            if (typeof args[cntr] === "function") {
              cbl = args[cntr];
              cntr--;
            }
            var requestOptions = options2;
            if (!(args[cntr] instanceof Buffer) && args[cntr] !== res) {
              requestOptions = extend3({}, options2);
              extend3(requestOptions, args[cntr]);
              cntr--;
            }
            if (args[cntr] instanceof Buffer) {
              head = args[cntr];
            }
            ["target", "forward"].forEach(function(e) {
              if (typeof requestOptions[e] === "string")
                requestOptions[e] = parse_url(requestOptions[e]);
            });
            if (!requestOptions.target && !requestOptions.forward) {
              return this.emit("error", new Error("Must provide a proper URL as target"));
            }
            for (var i = 0; i < passes.length; i++) {
              if (passes[i](req2, res, requestOptions, head, this, cbl)) {
                break;
              }
            }
          };
        };
      }
      httpProxy.createRightProxy = createRightProxy;
      function ProxyServer2(options2) {
        EE3.call(this);
        options2 = options2 || {};
        options2.prependPath = options2.prependPath === false ? false : true;
        this.web = this.proxyRequest = createRightProxy("web")(options2);
        this.ws = this.proxyWebsocketRequest = createRightProxy("ws")(options2);
        this.options = options2;
        this.webPasses = Object.keys(web).map(function(pass) {
          return web[pass];
        });
        this.wsPasses = Object.keys(ws).map(function(pass) {
          return ws[pass];
        });
        this.on("error", this.onError, this);
      }
      import_util.default.inherits(ProxyServer2, EE3);
      ProxyServer2.prototype.onError = function(err) {
        if (this.listeners("error").length === 1) {
          throw err;
        }
      };
      ProxyServer2.prototype.listen = function(port, hostname) {
        var self2 = this, closure = function(req2, res) {
          self2.web(req2, res);
        };
        this._server = this.options.ssl ? https2.createServer(this.options.ssl, closure) : http2.createServer(closure);
        if (this.options.ws) {
          this._server.on("upgrade", function(req2, socket, head) {
            self2.ws(req2, socket, head);
          });
        }
        this._server.listen(port, hostname);
        return this;
      };
      ProxyServer2.prototype.close = function(callback) {
        var self2 = this;
        if (this._server) {
          this._server.close(done);
        }
        function done() {
          self2._server = null;
          if (callback) {
            callback.apply(null, arguments);
          }
        }
      };
      ProxyServer2.prototype.before = function(type, passName, callback) {
        if (type !== "ws" && type !== "web") {
          throw new Error("type must be `web` or `ws`");
        }
        var passes = type === "ws" ? this.wsPasses : this.webPasses, i = false;
        passes.forEach(function(v, idx) {
          if (v.name === passName)
            i = idx;
        });
        if (i === false)
          throw new Error("No such pass");
        passes.splice(i, 0, callback);
      };
      ProxyServer2.prototype.after = function(type, passName, callback) {
        if (type !== "ws" && type !== "web") {
          throw new Error("type must be `web` or `ws`");
        }
        var passes = type === "ws" ? this.wsPasses : this.webPasses, i = false;
        passes.forEach(function(v, idx) {
          if (v.name === passName)
            i = idx;
        });
        if (i === false)
          throw new Error("No such pass");
        passes.splice(i++, 0, callback);
      };
    })(httpProxy$2);
    ProxyServer = httpProxyExports.Server;
    ProxyServer.createProxyServer = createProxyServer;
    ProxyServer.createServer = createProxyServer;
    ProxyServer.createProxy = createProxyServer;
    httpProxy$1 = ProxyServer;
    (function(module2) {
      module2.exports = httpProxy$1;
    })(httpProxy$3);
    debug$1 = createDebugger("vite:proxy");
    libExports = {};
    lib = {
      get exports() {
        return libExports;
      },
      set exports(v) {
        libExports = v;
      }
    };
    (function(module2, exports2) {
      var url2 = import_url.default;
      module2.exports = function historyApiFallback(options2) {
        options2 = options2 || {};
        var logger = getLogger(options2);
        return function(req2, res, next) {
          var headers = req2.headers;
          if (req2.method !== "GET" && req2.method !== "HEAD") {
            logger(
              "Not rewriting",
              req2.method,
              req2.url,
              "because the method is not GET or HEAD."
            );
            return next();
          } else if (!headers || typeof headers.accept !== "string") {
            logger(
              "Not rewriting",
              req2.method,
              req2.url,
              "because the client did not send an HTTP accept header."
            );
            return next();
          } else if (headers.accept.indexOf("application/json") === 0) {
            logger(
              "Not rewriting",
              req2.method,
              req2.url,
              "because the client prefers JSON."
            );
            return next();
          } else if (!acceptsHtml(headers.accept, options2)) {
            logger(
              "Not rewriting",
              req2.method,
              req2.url,
              "because the client does not accept HTML."
            );
            return next();
          }
          var parsedUrl = url2.parse(req2.url);
          var rewriteTarget;
          options2.rewrites = options2.rewrites || [];
          for (var i = 0; i < options2.rewrites.length; i++) {
            var rewrite = options2.rewrites[i];
            var match = parsedUrl.pathname.match(rewrite.from);
            if (match !== null) {
              rewriteTarget = evaluateRewriteRule(parsedUrl, match, rewrite.to, req2);
              if (rewriteTarget.charAt(0) !== "/") {
                logger(
                  "We recommend using an absolute path for the rewrite target.",
                  "Received a non-absolute rewrite target",
                  rewriteTarget,
                  "for URL",
                  req2.url
                );
              }
              logger("Rewriting", req2.method, req2.url, "to", rewriteTarget);
              req2.url = rewriteTarget;
              return next();
            }
          }
          var pathname = parsedUrl.pathname;
          if (pathname.lastIndexOf(".") > pathname.lastIndexOf("/") && options2.disableDotRule !== true) {
            logger(
              "Not rewriting",
              req2.method,
              req2.url,
              "because the path includes a dot (.) character."
            );
            return next();
          }
          rewriteTarget = options2.index || "/index.html";
          logger("Rewriting", req2.method, req2.url, "to", rewriteTarget);
          req2.url = rewriteTarget;
          next();
        };
      };
      function evaluateRewriteRule(parsedUrl, match, rule, req2) {
        if (typeof rule === "string") {
          return rule;
        } else if (typeof rule !== "function") {
          throw new Error("Rewrite rule can only be of type string or function.");
        }
        return rule({
          parsedUrl,
          match,
          request: req2
        });
      }
      function acceptsHtml(header, options2) {
        options2.htmlAcceptHeaders = options2.htmlAcceptHeaders || ["text/html", "*/*"];
        for (var i = 0; i < options2.htmlAcceptHeaders.length; i++) {
          if (header.indexOf(options2.htmlAcceptHeaders[i]) !== -1) {
            return true;
          }
        }
        return false;
      }
      function getLogger(options2) {
        if (options2 && options2.logger) {
          return options2.logger;
        } else if (options2 && options2.verbose) {
          return console.log.bind(console);
        }
        return function() {
        };
      }
    })(lib);
    debugCache = createDebugger("vite:cache");
    isDebug = !!process.env.DEBUG;
    logTime = createDebugger("vite:time");
    isWslExports = {};
    isWsl$2 = {
      get exports() {
        return isWslExports;
      },
      set exports(v) {
        isWslExports = v;
      }
    };
    fs$3 = import_fs.default;
    isDocker_1 = () => {
      if (isDocker$2 === void 0) {
        isDocker$2 = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker$2;
    };
    os = import_os.default;
    fs$2 = import_fs.default;
    isDocker$1 = isDocker_1;
    isWsl$1 = () => {
      if (process.platform !== "linux") {
        return false;
      }
      if (os.release().toLowerCase().includes("microsoft")) {
        if (isDocker$1()) {
          return false;
        }
        return true;
      }
      try {
        return fs$2.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker$1() : false;
      } catch (_) {
        return false;
      }
    };
    if (process.env.__IS_WSL_TEST__) {
      isWsl$2.exports = isWsl$1;
    } else {
      isWsl$2.exports = isWsl$1();
    }
    defineLazyProp = (object, propertyName, fn) => {
      const define = (value2) => Object.defineProperty(object, propertyName, { value: value2, enumerable: true, writable: true });
      Object.defineProperty(object, propertyName, {
        configurable: true,
        enumerable: true,
        get() {
          const result = fn();
          define(result);
          return result;
        },
        set(value2) {
          define(value2);
        }
      });
      return object;
    };
    path$3 = import_path2.default;
    childProcess = import_child_process.default;
    ({ promises: fs$1, constants: fsConstants } = import_fs.default);
    isWsl = isWslExports;
    isDocker = isDocker_1;
    defineLazyProperty = defineLazyProp;
    localXdgOpenPath = path$3.join(__dirname2, "xdg-open");
    ({ platform: platform2, arch } = process);
    hasContainerEnv = () => {
      try {
        fs$1.statSync("/run/.containerenv");
        return true;
      } catch {
        return false;
      }
    };
    getWslDrivesMountPoint = (() => {
      const defaultMountPoint = "/mnt/";
      let mountPoint;
      return async function() {
        if (mountPoint) {
          return mountPoint;
        }
        const configFilePath = "/etc/wsl.conf";
        let isConfigFileExists = false;
        try {
          await fs$1.access(configFilePath, fsConstants.F_OK);
          isConfigFileExists = true;
        } catch {
        }
        if (!isConfigFileExists) {
          return defaultMountPoint;
        }
        const configContent = await fs$1.readFile(configFilePath, { encoding: "utf8" });
        const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
        if (!configMountPoint) {
          return defaultMountPoint;
        }
        mountPoint = configMountPoint.groups.mountPoint.trim();
        mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
        return mountPoint;
      };
    })();
    pTryEach = async (array2, mapper) => {
      let latestError;
      for (const item of array2) {
        try {
          return await mapper(item);
        } catch (error2) {
          latestError = error2;
        }
      }
      throw latestError;
    };
    baseOpen = async (options2) => {
      options2 = {
        wait: false,
        background: false,
        newInstance: false,
        allowNonzeroExitCode: false,
        ...options2
      };
      if (Array.isArray(options2.app)) {
        return pTryEach(options2.app, (singleApp) => baseOpen({
          ...options2,
          app: singleApp
        }));
      }
      let { name: app, arguments: appArguments = [] } = options2.app || {};
      appArguments = [...appArguments];
      if (Array.isArray(app)) {
        return pTryEach(app, (appName) => baseOpen({
          ...options2,
          app: {
            name: appName,
            arguments: appArguments
          }
        }));
      }
      let command;
      const cliArguments = [];
      const childProcessOptions = {};
      if (platform2 === "darwin") {
        command = "open";
        if (options2.wait) {
          cliArguments.push("--wait-apps");
        }
        if (options2.background) {
          cliArguments.push("--background");
        }
        if (options2.newInstance) {
          cliArguments.push("--new");
        }
        if (app) {
          cliArguments.push("-a", app);
        }
      } else if (platform2 === "win32" || isWsl && !isInsideContainer() && !app) {
        const mountPoint = await getWslDrivesMountPoint();
        command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
        cliArguments.push(
          "-NoProfile",
          "-NonInteractive",
          "\u2013ExecutionPolicy",
          "Bypass",
          "-EncodedCommand"
        );
        if (!isWsl) {
          childProcessOptions.windowsVerbatimArguments = true;
        }
        const encodedArguments = ["Start"];
        if (options2.wait) {
          encodedArguments.push("-Wait");
        }
        if (app) {
          encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
          if (options2.target) {
            appArguments.unshift(options2.target);
          }
        } else if (options2.target) {
          encodedArguments.push(`"${options2.target}"`);
        }
        if (appArguments.length > 0) {
          appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
          encodedArguments.push(appArguments.join(","));
        }
        options2.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
      } else {
        if (app) {
          command = app;
        } else {
          const isBundled = !__dirname2 || __dirname2 === "/";
          let exeLocalXdgOpen = false;
          try {
            await fs$1.access(localXdgOpenPath, fsConstants.X_OK);
            exeLocalXdgOpen = true;
          } catch {
          }
          const useSystemXdgOpen = process.versions.electron || platform2 === "android" || isBundled || !exeLocalXdgOpen;
          command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
        }
        if (appArguments.length > 0) {
          cliArguments.push(...appArguments);
        }
        if (!options2.wait) {
          childProcessOptions.stdio = "ignore";
          childProcessOptions.detached = true;
        }
      }
      if (options2.target) {
        cliArguments.push(options2.target);
      }
      if (platform2 === "darwin" && appArguments.length > 0) {
        cliArguments.push("--args", ...appArguments);
      }
      const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
      if (options2.wait) {
        return new Promise((resolve5, reject) => {
          subprocess.once("error", reject);
          subprocess.once("close", (exitCode) => {
            if (!options2.allowNonzeroExitCode && exitCode > 0) {
              reject(new Error(`Exited with code ${exitCode}`));
              return;
            }
            resolve5(subprocess);
          });
        });
      }
      subprocess.unref();
      return subprocess;
    };
    open = (target, options2) => {
      if (typeof target !== "string") {
        throw new TypeError("Expected a `target`");
      }
      return baseOpen({
        ...options2,
        target
      });
    };
    openApp = (name2, options2) => {
      if (typeof name2 !== "string") {
        throw new TypeError("Expected a `name`");
      }
      const { arguments: appArguments = [] } = options2 || {};
      if (appArguments !== void 0 && appArguments !== null && !Array.isArray(appArguments)) {
        throw new TypeError("Expected `appArguments` as Array type");
      }
      return baseOpen({
        ...options2,
        app: {
          name: name2,
          arguments: appArguments
        }
      });
    };
    apps = {};
    defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
      darwin: "google chrome",
      win32: "chrome",
      linux: ["google-chrome", "google-chrome-stable", "chromium"]
    }, {
      wsl: {
        ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
        x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
      }
    }));
    defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
      darwin: "firefox",
      win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
      linux: "firefox"
    }, {
      wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
    }));
    defineLazyProperty(apps, "edge", () => detectPlatformBinary({
      darwin: "microsoft edge",
      win32: "msedge",
      linux: ["microsoft-edge", "microsoft-edge-dev"]
    }, {
      wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
    }));
    open.apps = apps;
    open.openApp = openApp;
    crossSpawnExports = {};
    crossSpawn = {
      get exports() {
        return crossSpawnExports;
      },
      set exports(v) {
        crossSpawnExports = v;
      }
    };
    if (process.platform === "win32" || commonjsGlobal.TESTING_WINDOWS) {
      core = requireWindows();
    } else {
      core = requireMode();
    }
    isexe_1 = isexe$1;
    isexe$1.sync = sync;
    isWindows2 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    path$2 = import_path2.default;
    COLON = isWindows2 ? ";" : ":";
    isexe = isexe_1;
    getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows2 && cmd.match(/\\/) ? [""] : [
        // windows always checks the cwd first
        ...isWindows2 ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon)
      ];
      const pathExtExe = isWindows2 ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows2 ? pathExtExe.split(colon) : [""];
      if (isWindows2) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    which$1 = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found2 = [];
      const step = (i) => new Promise((resolve5, reject) => {
        if (i === pathEnv.length)
          return opt.all && found2.length ? resolve5(found2) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path$2.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve5(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve5, reject) => {
        if (ii === pathExt.length)
          return resolve5(step(i + 1));
        const ext2 = pathExt[ii];
        isexe(p + ext2, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found2.push(p + ext2);
            else
              return resolve5(p + ext2);
          }
          return resolve5(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found2 = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path$2.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found2.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found2.length)
        return found2;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    which_1 = which$1;
    which$1.sync = whichSync;
    pathKeyExports = {};
    pathKey$1 = {
      get exports() {
        return pathKeyExports;
      },
      set exports(v) {
        pathKeyExports = v;
      }
    };
    pathKey = (options2 = {}) => {
      const environment = options2.env || process.env;
      const platform3 = options2.platform || process.platform;
      if (platform3 !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    pathKey$1.exports = pathKey;
    pathKeyExports.default = pathKey;
    path$12 = import_path2.default;
    which = which_1;
    getPathKey = pathKeyExports;
    resolveCommand_1 = resolveCommand$1;
    _escape = {};
    metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    _escape.command = escapeCommand;
    _escape.argument = escapeArgument;
    shebangRegex$1 = /^#!(.*)/;
    shebangRegex = shebangRegex$1;
    shebangCommand$1 = (string2 = "") => {
      const match = string2.match(shebangRegex);
      if (!match) {
        return null;
      }
      const [path4, argument] = match[0].replace(/#! ?/, "").split(" ");
      const binary2 = path4.split("/").pop();
      if (binary2 === "env") {
        return argument;
      }
      return argument ? `${binary2} ${argument}` : binary2;
    };
    fs = import_fs.default;
    shebangCommand = shebangCommand$1;
    readShebang_1 = readShebang$1;
    path3 = import_path2.default;
    resolveCommand = resolveCommand_1;
    escape$1 = _escape;
    readShebang = readShebang_1;
    isWin$1 = process.platform === "win32";
    isExecutableRegExp = /\.(?:com|exe)$/i;
    isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    parse_12 = parse$12;
    isWin = process.platform === "win32";
    enoent$1 = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
    cp = import_child_process.default;
    parse6 = parse_12;
    enoent = enoent$1;
    crossSpawn.exports = spawn;
    crossSpawnExports.spawn = spawn;
    crossSpawnExports.sync = spawnSync;
    crossSpawnExports._parse = parse6;
    crossSpawnExports._enoent = enoent;
    debug = createDebugger("vite:config");
    _require = (0, import_node_module.createRequire)(import_meta2.url);
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => createEntryShakingPlugin
});
module.exports = __toCommonJS(src_exports);

// src/logger.ts
var EOS = `\x1B[0m\x1B[29m`;
var COLORS = {
  cyan: `\x1B[36m`,
  gray: `\x1B[9m\x1B[90m`
};
var paint = (color, text) => `${COLORS[color]}${text}${EOS}`;
var logPrefix = paint("cyan", `[vite:entry-shaking]`);
var configureLogger = (logger, debug2) => ({
  ...logger,
  info(message, options2) {
    if (debug2)
      logger.info(`${logPrefix} ${message}`, options2);
  }
});

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = "";
    for (let i = 0; i < buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};
function encode(decoded) {
  const state = new Int32Array(5);
  const bufLength = 1024 * 16;
  const subLength = bufLength - 36;
  const buf = new Uint8Array(bufLength);
  const sub = buf.subarray(0, subLength);
  let pos = 0;
  let out = "";
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0) {
      if (pos === bufLength) {
        out += td.decode(buf);
        pos = 0;
      }
      buf[pos++] = semicolon;
    }
    if (line.length === 0)
      continue;
    state[0] = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      if (pos > subLength) {
        out += td.decode(sub);
        buf.copyWithin(0, subLength, pos);
        pos -= subLength;
      }
      if (j > 0)
        buf[pos++] = comma;
      pos = encodeInteger(buf, pos, state, segment, 0);
      if (segment.length === 1)
        continue;
      pos = encodeInteger(buf, pos, state, segment, 1);
      pos = encodeInteger(buf, pos, state, segment, 2);
      pos = encodeInteger(buf, pos, state, segment, 3);
      if (segment.length === 4)
        continue;
      pos = encodeInteger(buf, pos, state, segment, 4);
    }
  }
  return out + td.decode(buf.subarray(0, pos));
}
function encodeInteger(buf, pos, state, segment, j) {
  const next = segment[j];
  let num = next - state[j];
  state[j] = next;
  num = num < 0 ? -num << 1 | 1 : num << 1;
  do {
    let clamped = num & 31;
    num >>>= 5;
    if (num > 0)
      clamped |= 32;
    buf[pos++] = intToChar[clamped];
  } while (num > 0);
  return pos;
}

// node_modules/magic-string/dist/magic-string.es.mjs
var BitSet = class {
  constructor(arg) {
    this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
  }
  add(n2) {
    this.bits[n2 >> 5] |= 1 << (n2 & 31);
  }
  has(n2) {
    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
  }
};
var Chunk = class {
  constructor(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = "";
    this.outro = "";
    this.content = content;
    this.storeName = false;
    this.edited = false;
    {
      this.previous = null;
      this.next = null;
    }
  }
  appendLeft(content) {
    this.outro += content;
  }
  appendRight(content) {
    this.intro = this.intro + content;
  }
  clone() {
    const chunk = new Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  }
  contains(index) {
    return this.start < index && index < this.end;
  }
  eachNext(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.next;
    }
  }
  eachPrevious(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.previous;
    }
  }
  edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = "";
      this.outro = "";
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  }
  prependLeft(content) {
    this.outro = content + this.outro;
  }
  prependRight(content) {
    this.intro = content + this.intro;
  }
  split(index) {
    const sliceIndex = index - this.start;
    const originalBefore = this.original.slice(0, sliceIndex);
    const originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    const newChunk = new Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = "";
    this.end = index;
    if (this.edited) {
      newChunk.edit("", false);
      this.content = "";
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next)
      newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(rx) {
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length)
        return true;
    }
  }
  trimStart(rx) {
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.end - trimmed.length);
        this.edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length)
        return true;
    }
  }
};
function getBtoa() {
  if (typeof window !== "undefined" && typeof window.btoa === "function") {
    return (str) => window.btoa(unescape(encodeURIComponent(str)));
  } else if (typeof Buffer === "function") {
    return (str) => Buffer.from(str, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
var btoa2 = /* @__PURE__ */ getBtoa();
var SourceMap = class {
  constructor(properties) {
    this.version = 3;
    this.file = properties.file;
    this.sources = properties.sources;
    this.sourcesContent = properties.sourcesContent;
    this.names = properties.names;
    this.mappings = encode(properties.mappings);
    if (typeof properties.x_google_ignoreList !== "undefined") {
      this.x_google_ignoreList = properties.x_google_ignoreList;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa2(this.toString());
  }
};
function guessIndent(code) {
  const lines = code.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min2 = spaced.reduce((previous, current3) => {
    const numSpaces = /^ +/.exec(current3)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min2 + 1).join(" ");
}
function getRelativePath(from, to) {
  const fromParts = from.split(/[/\\]/);
  const toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--)
      fromParts[i] = "..";
  }
  return fromParts.concat(toParts).join("/");
}
var toString = Object.prototype.toString;
function isObject(thing) {
  return toString.call(thing) === "[object Object]";
}
function getLocator(source) {
  const originalLines = source.split("\n");
  const lineOffsets = [];
  for (let i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate(index) {
    let i = 0;
    let j = lineOffsets.length;
    while (i < j) {
      const m = i + j >> 1;
      if (index < lineOffsets[m]) {
        j = m;
      } else {
        i = m + 1;
      }
    }
    const line = i - 1;
    const column = index - lineOffsets[line];
    return { line, column };
  };
}
var Mappings = class {
  constructor(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  }
  addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
    }
    this.advance(content);
    this.pending = null;
  }
  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    let originalCharIndex = chunk.start;
    let first2 = true;
    while (originalCharIndex < chunk.end) {
      if (this.hires || first2 || sourcemapLocations.has(originalCharIndex)) {
        this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
      }
      if (original[originalCharIndex] === "\n") {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first2 = true;
      } else {
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first2 = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  }
  advance(str) {
    if (!str)
      return;
    const lines = str.split("\n");
    if (lines.length > 1) {
      for (let i = 0; i < lines.length - 1; i++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  }
};
var n = "\n";
var warned = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
var MagicString = class {
  constructor(string2, options2 = {}) {
    const chunk = new Chunk(0, string2.length, string2);
    Object.defineProperties(this, {
      original: { writable: true, value: string2 },
      outro: { writable: true, value: "" },
      intro: { writable: true, value: "" },
      firstChunk: { writable: true, value: chunk },
      lastChunk: { writable: true, value: chunk },
      lastSearchedChunk: { writable: true, value: chunk },
      byStart: { writable: true, value: {} },
      byEnd: { writable: true, value: {} },
      filename: { writable: true, value: options2.filename },
      indentExclusionRanges: { writable: true, value: options2.indentExclusionRanges },
      sourcemapLocations: { writable: true, value: new BitSet() },
      storedNames: { writable: true, value: {} },
      indentStr: { writable: true, value: void 0 },
      ignoreList: { writable: true, value: options2.ignoreList }
    });
    this.byStart[0] = chunk;
    this.byEnd[string2.length] = chunk;
  }
  addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  }
  append(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.outro += content;
    return this;
  }
  appendLeft(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  }
  appendRight(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  }
  clone() {
    const cloned = new MagicString(this.original, { filename: this.filename });
    let originalChunk = this.firstChunk;
    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      const nextOriginalChunk = originalChunk.next;
      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  }
  generateDecodedMap(options2) {
    options2 = options2 || {};
    const sourceIndex = 0;
    const names = Object.keys(this.storedNames);
    const mappings = new Mappings(options2.hires);
    const locate = getLocator(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext((chunk) => {
      const loc = locate(chunk.start);
      if (chunk.intro.length)
        mappings.advance(chunk.intro);
      if (chunk.edited) {
        mappings.addEdit(
          sourceIndex,
          chunk.content,
          loc,
          chunk.storeName ? names.indexOf(chunk.original) : -1
        );
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
      }
      if (chunk.outro.length)
        mappings.advance(chunk.outro);
    });
    return {
      file: options2.file ? options2.file.split(/[/\\]/).pop() : void 0,
      sources: [options2.source ? getRelativePath(options2.file || "", options2.source) : options2.file || ""],
      sourcesContent: options2.includeContent ? [this.original] : void 0,
      names,
      mappings: mappings.raw,
      x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
    };
  }
  generateMap(options2) {
    return new SourceMap(this.generateDecodedMap(options2));
  }
  _ensureindentStr() {
    if (this.indentStr === void 0) {
      this.indentStr = guessIndent(this.original);
    }
  }
  _getRawIndentString() {
    this._ensureindentStr();
    return this.indentStr;
  }
  getIndentString() {
    this._ensureindentStr();
    return this.indentStr === null ? "	" : this.indentStr;
  }
  indent(indentStr, options2) {
    const pattern2 = /^[^\r\n]/gm;
    if (isObject(indentStr)) {
      options2 = indentStr;
      indentStr = void 0;
    }
    if (indentStr === void 0) {
      this._ensureindentStr();
      indentStr = this.indentStr || "	";
    }
    if (indentStr === "")
      return this;
    options2 = options2 || {};
    const isExcluded = {};
    if (options2.exclude) {
      const exclusions = typeof options2.exclude[0] === "number" ? [options2.exclude] : options2.exclude;
      exclusions.forEach((exclusion) => {
        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
          isExcluded[i] = true;
        }
      });
    }
    let shouldIndentNextCharacter = options2.indentStart !== false;
    const replacer = (match) => {
      if (shouldIndentNextCharacter)
        return `${indentStr}${match}`;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern2, replacer);
    let charIndex = 0;
    let chunk = this.firstChunk;
    while (chunk) {
      const end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern2, replacer);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            const char = this.original[charIndex];
            if (char === "\n") {
              shouldIndentNextCharacter = true;
            } else if (char !== "\r" && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern2, replacer);
    return this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(index, content) {
    if (!warned.insertLeft) {
      console.warn(
        "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
      );
      warned.insertLeft = true;
    }
    return this.appendLeft(index, content);
  }
  insertRight(index, content) {
    if (!warned.insertRight) {
      console.warn(
        "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
      );
      warned.insertRight = true;
    }
    return this.prependRight(index, content);
  }
  move(start, end, index) {
    if (index >= start && index <= end)
      throw new Error("Cannot move a selection inside itself");
    this._split(start);
    this._split(end);
    this._split(index);
    const first2 = this.byStart[start];
    const last = this.byEnd[end];
    const oldLeft = first2.previous;
    const oldRight = last.next;
    const newRight = this.byStart[index];
    if (!newRight && last === this.lastChunk)
      return this;
    const newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft)
      oldLeft.next = oldRight;
    if (oldRight)
      oldRight.previous = oldLeft;
    if (newLeft)
      newLeft.next = first2;
    if (newRight)
      newRight.previous = last;
    if (!first2.previous)
      this.firstChunk = last.next;
    if (!last.next) {
      this.lastChunk = first2.previous;
      this.lastChunk.next = null;
    }
    first2.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft)
      this.firstChunk = first2;
    if (!newRight)
      this.lastChunk = last;
    return this;
  }
  overwrite(start, end, content, options2) {
    options2 = options2 || {};
    return this.update(start, end, content, { ...options2, overwrite: !options2.contentOnly });
  }
  update(start, end, content, options2) {
    if (typeof content !== "string")
      throw new TypeError("replacement content must be a string");
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (end > this.original.length)
      throw new Error("end is out of bounds");
    if (start === end)
      throw new Error(
        "Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead"
      );
    this._split(start);
    this._split(end);
    if (options2 === true) {
      if (!warned.storeName) {
        console.warn(
          "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
        );
        warned.storeName = true;
      }
      options2 = { storeName: true };
    }
    const storeName = options2 !== void 0 ? options2.storeName : false;
    const overwrite = options2 !== void 0 ? options2.overwrite : false;
    if (storeName) {
      const original = this.original.slice(start, end);
      Object.defineProperty(this.storedNames, original, {
        writable: true,
        value: true,
        enumerable: true
      });
    }
    const first2 = this.byStart[start];
    const last = this.byEnd[end];
    if (first2) {
      let chunk = first2;
      while (chunk !== last) {
        if (chunk.next !== this.byStart[chunk.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        chunk = chunk.next;
        chunk.edit("", false);
      }
      first2.edit(content, storeName, !overwrite);
    } else {
      const newChunk = new Chunk(start, end, "").edit(content, storeName);
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  }
  prepend(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.intro = content + this.intro;
    return this;
  }
  prependLeft(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  }
  prependRight(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  }
  remove(start, end) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (start === end)
      return this;
    if (start < 0 || end > this.original.length)
      throw new Error("Character is out of bounds");
    if (start > end)
      throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = "";
      chunk.outro = "";
      chunk.edit("");
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  lastChar() {
    if (this.outro.length)
      return this.outro[this.outro.length - 1];
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length)
        return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length)
        return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length)
        return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length)
      return this.intro[this.intro.length - 1];
    return "";
  }
  lastLine() {
    let lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1)
      return this.outro.substr(lineIndex + 1);
    let lineStr = this.outro;
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1)
      return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  }
  slice(start = 0, end = this.original.length) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    let result = "";
    let chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      if (chunk.start < end && chunk.end >= end) {
        return result;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start)
      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
    const startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
        result += chunk.intro;
      }
      const containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end)
        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
      const sliceStart = startChunk === chunk ? start - chunk.start : 0;
      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result;
  }
  // TODO deprecate this? not really very useful
  snip(start, end) {
    const clone = this.clone();
    clone.remove(0, start);
    clone.remove(end, clone.original.length);
    return clone;
  }
  _split(index) {
    if (this.byStart[index] || this.byEnd[index])
      return;
    let chunk = this.lastSearchedChunk;
    const searchForward = index > chunk.end;
    while (chunk) {
      if (chunk.contains(index))
        return this._splitChunk(chunk, index);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
    }
  }
  _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
      const loc = getLocator(this.original)(index);
      throw new Error(
        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \u2013 "${chunk.original}")`
      );
    }
    const newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk)
      this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  }
  toString() {
    let str = this.intro;
    let chunk = this.firstChunk;
    while (chunk) {
      str += chunk.toString();
      chunk = chunk.next;
    }
    return str + this.outro;
  }
  isEmpty() {
    let chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
        return false;
    } while (chunk = chunk.next);
    return true;
  }
  length() {
    let chunk = this.firstChunk;
    let length = 0;
    do {
      length += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  }
  trimEndAborted(charType) {
    const rx = new RegExp((charType || "\\s") + "+$");
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    let chunk = this.lastChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimEnd(rx);
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  }
  trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  }
  trimStartAborted(charType) {
    const rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    let chunk = this.firstChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        if (chunk === this.lastChunk)
          this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  }
  trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(searchValue, replacement) {
    function getReplacement(match, str) {
      if (typeof replacement === "string") {
        return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
          if (i === "$")
            return "$";
          if (i === "&")
            return match[0];
          const num = +i;
          if (num < match.length)
            return match[+i];
          return `$${i}`;
        });
      } else {
        return replacement(...match, match.index, str, match.groups);
      }
    }
    function matchAll(re, str) {
      let match;
      const matches = [];
      while (match = re.exec(str)) {
        matches.push(match);
      }
      return matches;
    }
    if (searchValue.global) {
      const matches = matchAll(searchValue, this.original);
      matches.forEach((match) => {
        if (match.index != null)
          this.overwrite(
            match.index,
            match.index + match[0].length,
            getReplacement(match, this.original)
          );
      });
    } else {
      const match = this.original.match(searchValue);
      if (match && match.index != null)
        this.overwrite(
          match.index,
          match.index + match[0].length,
          getReplacement(match, this.original)
        );
    }
    return this;
  }
  _replaceString(string2, replacement) {
    const { original } = this;
    const index = original.indexOf(string2);
    if (index !== -1) {
      this.overwrite(index, index + string2.length, replacement);
    }
    return this;
  }
  replace(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceString(searchValue, replacement);
    }
    return this._replaceRegexp(searchValue, replacement);
  }
  _replaceAllString(string2, replacement) {
    const { original } = this;
    const stringLength = string2.length;
    for (let index = original.indexOf(string2); index !== -1; index = original.indexOf(string2, index + stringLength)) {
      this.overwrite(index, index + stringLength, replacement);
    }
    return this;
  }
  replaceAll(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceAllString(searchValue, replacement);
    }
    if (!searchValue.global) {
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    }
    return this._replaceRegexp(searchValue, replacement);
  }
};

// node_modules/es-module-lexer/dist/lexer.js
var A = 1 === new Uint8Array(new Uint16Array([1]).buffer)[0];
function parse(E3, g = "@") {
  if (!C)
    return init.then(() => parse(E3));
  const I = E3.length + 1, o = (C.__heap_base.value || C.__heap_base) + 4 * I - C.memory.buffer.byteLength;
  o > 0 && C.memory.grow(Math.ceil(o / 65536));
  const D = C.sa(I - 1);
  if ((A ? B : Q)(E3, new Uint16Array(C.memory.buffer, D, I)), !C.parse())
    throw Object.assign(new Error(`Parse error ${g}:${E3.slice(0, C.e()).split("\n").length}:${C.e() - E3.lastIndexOf("\n", C.e() - 1)}`), { idx: C.e() });
  const K = [], k = [];
  for (; C.ri(); ) {
    const A3 = C.is(), Q2 = C.ie(), B2 = C.ai(), g2 = C.id(), I2 = C.ss(), o2 = C.se();
    let D2;
    C.ip() && (D2 = J(E3.slice(-1 === g2 ? A3 - 1 : A3, -1 === g2 ? Q2 + 1 : Q2))), K.push({ n: D2, s: A3, e: Q2, ss: I2, se: o2, d: g2, a: B2 });
  }
  for (; C.re(); ) {
    const A3 = C.es(), Q2 = C.ee(), B2 = C.els(), g2 = C.ele(), I2 = E3.slice(A3, Q2), o2 = I2[0], D2 = B2 < 0 ? void 0 : E3.slice(B2, g2), K2 = D2 ? D2[0] : "";
    k.push({ s: A3, e: Q2, ls: B2, le: g2, n: '"' === o2 || "'" === o2 ? J(I2) : I2, ln: '"' === K2 || "'" === K2 ? J(D2) : D2 });
  }
  function J(A3) {
    try {
      return (0, eval)(A3);
    } catch (A4) {
    }
  }
  return [K, k, !!C.f()];
}
function Q(A3, Q2) {
  const B2 = A3.length;
  let C4 = 0;
  for (; C4 < B2; ) {
    const B3 = A3.charCodeAt(C4);
    Q2[C4++] = (255 & B3) << 8 | B3 >>> 8;
  }
}
function B(A3, Q2) {
  const B2 = A3.length;
  let C4 = 0;
  for (; C4 < B2; )
    Q2[C4] = A3.charCodeAt(C4++);
}
var C;
var init = WebAssembly.compile((E = "AGFzbQEAAAABKghgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gAn9/AAMvLgABAQICAgICAgICAgICAgICAgIAAwMDBAQAAAADAAAAAAMDAAUGAAAABwAGAgUEBQFwAQEBBQMBAAEGDwJ/AUGw8gALfwBBsPIACwdwEwZtZW1vcnkCAAJzYQAAAWUAAwJpcwAEAmllAAUCc3MABgJzZQAHAmFpAAgCaWQACQJpcAAKAmVzAAsCZWUADANlbHMADQNlbGUADgJyaQAPAnJlABABZgARBXBhcnNlABILX19oZWFwX2Jhc2UDAQqHPC5oAQF/QQAgADYC9AlBACgC0AkiASAAQQF0aiIAQQA7AQBBACAAQQJqIgA2AvgJQQAgADYC/AlBAEEANgLUCUEAQQA2AuQJQQBBADYC3AlBAEEANgLYCUEAQQA2AuwJQQBBADYC4AkgAQufAQEDf0EAKALkCSEEQQBBACgC/AkiBTYC5AlBACAENgLoCUEAIAVBIGo2AvwJIARBHGpB1AkgBBsgBTYCAEEAKALICSEEQQAoAsQJIQYgBSABNgIAIAUgADYCCCAFIAIgAkECakEAIAYgA0YbIAQgA0YbNgIMIAUgAzYCFCAFQQA2AhAgBSACNgIEIAVBADYCHCAFQQAoAsQJIANGOgAYC1YBAX9BACgC7AkiBEEQakHYCSAEG0EAKAL8CSIENgIAQQAgBDYC7AlBACAEQRRqNgL8CSAEQQA2AhAgBCADNgIMIAQgAjYCCCAEIAE2AgQgBCAANgIACwgAQQAoAoAKCxUAQQAoAtwJKAIAQQAoAtAJa0EBdQseAQF/QQAoAtwJKAIEIgBBACgC0AlrQQF1QX8gABsLFQBBACgC3AkoAghBACgC0AlrQQF1Cx4BAX9BACgC3AkoAgwiAEEAKALQCWtBAXVBfyAAGwseAQF/QQAoAtwJKAIQIgBBACgC0AlrQQF1QX8gABsLOwEBfwJAQQAoAtwJKAIUIgBBACgCxAlHDQBBfw8LAkAgAEEAKALICUcNAEF+DwsgAEEAKALQCWtBAXULCwBBACgC3AktABgLFQBBACgC4AkoAgBBACgC0AlrQQF1CxUAQQAoAuAJKAIEQQAoAtAJa0EBdQseAQF/QQAoAuAJKAIIIgBBACgC0AlrQQF1QX8gABsLHgEBf0EAKALgCSgCDCIAQQAoAtAJa0EBdUF/IAAbCyUBAX9BAEEAKALcCSIAQRxqQdQJIAAbKAIAIgA2AtwJIABBAEcLJQEBf0EAQQAoAuAJIgBBEGpB2AkgABsoAgAiADYC4AkgAEEARwsIAEEALQCECgvmDAEGfyMAQYDQAGsiACQAQQBBAToAhApBAEEAKALMCTYCjApBAEEAKALQCUF+aiIBNgKgCkEAIAFBACgC9AlBAXRqIgI2AqQKQQBBADsBhgpBAEEAOwGICkEAQQA6AJAKQQBBADYCgApBAEEAOgDwCUEAIABBgBBqNgKUCkEAIAA2ApgKQQBBADoAnAoCQAJAAkACQANAQQAgAUECaiIDNgKgCiABIAJPDQECQCADLwEAIgJBd2pBBUkNAAJAAkACQAJAAkAgAkGbf2oOBQEICAgCAAsgAkEgRg0EIAJBL0YNAyACQTtGDQIMBwtBAC8BiAoNASADEBNFDQEgAUEEakGCCEEKEC0NARAUQQAtAIQKDQFBAEEAKAKgCiIBNgKMCgwHCyADEBNFDQAgAUEEakGMCEEKEC0NABAVC0EAQQAoAqAKNgKMCgwBCwJAIAEvAQQiA0EqRg0AIANBL0cNBBAWDAELQQEQFwtBACgCpAohAkEAKAKgCiEBDAALC0EAIQIgAyEBQQAtAPAJDQIMAQtBACABNgKgCkEAQQA6AIQKCwNAQQAgAUECaiIDNgKgCgJAAkACQAJAAkACQAJAAkACQCABQQAoAqQKTw0AIAMvAQAiAkF3akEFSQ0IAkACQAJAAkACQAJAAkACQAJAAkAgAkFgag4KEhEGEREREQUBAgALAkACQAJAAkAgAkGgf2oOCgsUFAMUARQUFAIACyACQYV/ag4DBRMGCQtBAC8BiAoNEiADEBNFDRIgAUEEakGCCEEKEC0NEhAUDBILIAMQE0UNESABQQRqQYwIQQoQLQ0REBUMEQsgAxATRQ0QIAEpAARC7ICEg7COwDlSDRAgAS8BDCIDQXdqIgFBF0sNDkEBIAF0QZ+AgARxRQ0ODA8LQQBBAC8BiAoiAUEBajsBiApBACgClAogAUEDdGoiAUEBNgIAIAFBACgCjAo2AgQMDwtBAC8BiAoiAkUNC0EAIAJBf2oiBDsBiApBAC8BhgoiAkUNDiACQQJ0QQAoApgKakF8aigCACIFKAIUQQAoApQKIARB//8DcUEDdGooAgRHDQ4CQCAFKAIEDQAgBSADNgIEC0EAIAJBf2o7AYYKIAUgAUEEajYCDAwOCwJAQQAoAowKIgEvAQBBKUcNAEEAKALkCSIDRQ0AIAMoAgQgAUcNAEEAQQAoAugJIgM2AuQJAkAgA0UNACADQQA2AhwMAQtBAEEANgLUCQtBAEEALwGICiIDQQFqOwGICkEAKAKUCiADQQN0aiIDQQZBAkEALQCcChs2AgAgAyABNgIEQQBBADoAnAoMDQtBAC8BiAoiAUUNCUEAIAFBf2oiATsBiApBACgClAogAUH//wNxQQN0aigCAEEERg0EDAwLQScQGAwLC0EiEBgMCgsgAkEvRw0JAkACQCABLwEEIgFBKkYNACABQS9HDQEQFgwMC0EBEBcMCwsCQAJAQQAoAowKIgEvAQAiAxAZRQ0AAkACQCADQVVqDgQACAEDCAsgAUF+ai8BAEErRg0GDAcLIAFBfmovAQBBLUYNBQwGCwJAIANB/QBGDQAgA0EpRw0FQQAoApQKQQAvAYgKQQN0aigCBBAaRQ0FDAYLQQAoApQKQQAvAYgKQQN0aiICKAIEEBsNBSACKAIAQQZGDQUMBAsgAUF+ai8BAEFQakH//wNxQQpJDQMMBAtBACgClApBAC8BiAoiAUEDdCIDakEAKAKMCjYCBEEAIAFBAWo7AYgKQQAoApQKIANqQQM2AgALEBwMBwtBAC0A8AlBAC8BhgpBAC8BiApyckUhAgwJCyABEB0NACADRQ0AIANBL0ZBAC0AkApBAEdxDQAgAUF+aiEBQQAoAtAJIQICQANAIAFBAmoiBCACTQ0BQQAgATYCjAogAS8BACEDIAFBfmoiBCEBIAMQHkUNAAsgBEECaiEEC0EBIQUgA0H//wNxEB9FDQEgBEF+aiEBAkADQCABQQJqIgMgAk0NAUEAIAE2AowKIAEvAQAhAyABQX5qIgQhASADEB8NAAsgBEECaiEDCyADECBFDQEQIUEAQQA6AJAKDAULECFBACEFC0EAIAU6AJAKDAMLECJBACECDAULIANBoAFHDQELQQBBAToAnAoLQQBBACgCoAo2AowKC0EAKAKgCiEBDAALCyAAQYDQAGokACACCxoAAkBBACgC0AkgAEcNAEEBDwsgAEF+ahAjC80JAQV/QQBBACgCoAoiAEEMaiIBNgKgCkEAKALsCSECQQEQJyEDAkACQAJAAkACQAJAAkACQAJAAkBBACgCoAoiBCABRw0AIAMQJkUNAQsCQAJAAkACQCADQSpGDQAgA0H7AEcNAUEAIARBAmo2AqAKQQEQJyEEQQAoAqAKIQEDQAJAAkAgBEH//wNxIgNBIkYNACADQSdGDQAgAxAqGkEAKAKgCiEDDAELIAMQGEEAQQAoAqAKQQJqIgM2AqAKC0EBECcaAkAgASADECsiBEEsRw0AQQBBACgCoApBAmo2AqAKQQEQJyEEC0EAKAKgCiEDIARB/QBGDQMgAyABRg0NIAMhASADQQAoAqQKTQ0ADA0LC0EAIARBAmo2AqAKQQEQJxpBACgCoAoiAyADECsaDAILQQBBADoAhAoCQAJAAkACQAJAAkAgA0Gff2oODAIIBAEIAwgICAgIBQALIANB9gBGDQQMBwtBACAEQQ5qIgM2AqAKAkACQAJAQQEQJ0Gff2oOBgAQAhAQARALQQAoAqAKIgEpAAJC84Dkg+CNwDFSDQ8gAS8BChAfRQ0PQQAgAUEKajYCoApBABAnGgtBACgCoAoiAUECakGiCEEOEC0NDiABLwEQIgBBd2oiAkEXSw0LQQEgAnRBn4CABHFFDQsMDAtBACgCoAoiASkAAkLsgISDsI7AOVINDSABLwEKIgBBd2oiAkEXTQ0HDAgLQQAgBEEKajYCoApBABAnGkEAKAKgCiEEC0EAIARBEGo2AqAKAkBBARAnIgRBKkcNAEEAQQAoAqAKQQJqNgKgCkEBECchBAtBACgCoAohAyAEECoaIANBACgCoAoiBCADIAQQAkEAQQAoAqAKQX5qNgKgCg8LAkAgBCkAAkLsgISDsI7AOVINACAELwEKEB5FDQBBACAEQQpqNgKgCkEBECchBEEAKAKgCiEDIAQQKhogA0EAKAKgCiIEIAMgBBACQQBBACgCoApBfmo2AqAKDwtBACAEQQRqIgQ2AqAKC0EAIARBBGoiAzYCoApBAEEAOgCECgJAA0BBACADQQJqNgKgCkEBECchBEEAKAKgCiEDIAQQKkEgckH7AEYNAUEAKAKgCiIEIANGDQQgAyAEIAMgBBACQQEQJ0EsRw0BQQAoAqAKIQMMAAsLQQBBACgCoApBfmo2AqAKDwtBACADQQJqNgKgCgtBARAnIQRBACgCoAohAwJAIARB5gBHDQAgA0ECakGcCEEGEC0NAEEAIANBCGo2AqAKIABBARAnECkgAkEQakHYCSACGyEDA0AgAygCACIDRQ0CIANCADcCCCADQRBqIQMMAAsLQQAgA0F+ajYCoAoLDwtBASACdEGfgIAEcQ0BCyAAQaABRg0AIABB+wBHDQQLQQAgAUEKajYCoApBARAnIgFB+wBGDQMMAgsCQCAAQVhqDgMBAwEACyAAQaABRw0CC0EAIAFBEGo2AqAKAkBBARAnIgFBKkcNAEEAQQAoAqAKQQJqNgKgCkEBECchAQsgAUEoRg0BC0EAKAKgCiECIAEQKhpBACgCoAoiASACTQ0AIAQgAyACIAEQAkEAQQAoAqAKQX5qNgKgCg8LIAQgA0EAQQAQAkEAIARBDGo2AqAKDwsQIgvUBgEEf0EAQQAoAqAKIgBBDGoiATYCoAoCQAJAAkACQAJAAkACQAJAAkACQEEBECciAkFZag4IBAIBBAEBAQMACyACQSJGDQMgAkH7AEYNBAtBACgCoAogAUcNAkEAIABBCmo2AqAKDwtBACgClApBAC8BiAoiAkEDdGoiAUEAKAKgCjYCBEEAIAJBAWo7AYgKIAFBBTYCAEEAKAKMCi8BAEEuRg0DQQBBACgCoAoiAUECajYCoApBARAnIQIgAEEAKAKgCkEAIAEQAUEAQQAvAYYKIgFBAWo7AYYKQQAoApgKIAFBAnRqQQAoAuQJNgIAAkAgAkEiRg0AIAJBJ0YNAEEAQQAoAqAKQX5qNgKgCg8LIAIQGEEAQQAoAqAKQQJqIgI2AqAKAkACQAJAQQEQJ0FXag4EAQICAAILQQBBACgCoApBAmo2AqAKQQEQJxpBACgC5AkiASACNgIEIAFBAToAGCABQQAoAqAKIgI2AhBBACACQX5qNgKgCg8LQQAoAuQJIgEgAjYCBCABQQE6ABhBAEEALwGICkF/ajsBiAogAUEAKAKgCkECajYCDEEAQQAvAYYKQX9qOwGGCg8LQQBBACgCoApBfmo2AqAKDwtBAEEAKAKgCkECajYCoApBARAnQe0ARw0CQQAoAqAKIgJBAmpBlghBBhAtDQICQEEAKAKMCiIBECgNACABLwEAQS5GDQMLIAAgACACQQhqQQAoAsgJEAEPC0EALwGICg0CQQAoAqAKIQJBACgCpAohAwNAIAIgA08NBQJAAkAgAi8BACIBQSdGDQAgAUEiRw0BCyAAIAEQKQ8LQQAgAkECaiICNgKgCgwACwtBACgCoAohAkEALwGICg0CAkADQAJAAkACQCACQQAoAqQKTw0AQQEQJyICQSJGDQEgAkEnRg0BIAJB/QBHDQJBAEEAKAKgCkECajYCoAoLQQEQJyEBQQAoAqAKIQICQCABQeYARw0AIAJBAmpBnAhBBhAtDQgLQQAgAkEIajYCoApBARAnIgJBIkYNAyACQSdGDQMMBwsgAhAYC0EAQQAoAqAKQQJqIgI2AqAKDAALCyAAIAIQKQsPC0EAQQAoAqAKQX5qNgKgCg8LQQAgAkF+ajYCoAoPCxAiC0cBA39BACgCoApBAmohAEEAKAKkCiEBAkADQCAAIgJBfmogAU8NASACQQJqIQAgAi8BAEF2ag4EAQAAAQALC0EAIAI2AqAKC5gBAQN/QQBBACgCoAoiAUECajYCoAogAUEGaiEBQQAoAqQKIQIDQAJAAkACQCABQXxqIAJPDQAgAUF+ai8BACEDAkACQCAADQAgA0EqRg0BIANBdmoOBAIEBAIECyADQSpHDQMLIAEvAQBBL0cNAkEAIAFBfmo2AqAKDAELIAFBfmohAQtBACABNgKgCg8LIAFBAmohAQwACwuIAQEEf0EAKAKgCiEBQQAoAqQKIQICQAJAA0AgASIDQQJqIQEgAyACTw0BIAEvAQAiBCAARg0CAkAgBEHcAEYNACAEQXZqDgQCAQECAQsgA0EEaiEBIAMvAQRBDUcNACADQQZqIAEgAy8BBkEKRhshAQwACwtBACABNgKgChAiDwtBACABNgKgCgtsAQF/AkACQCAAQV9qIgFBBUsNAEEBIAF0QTFxDQELIABBRmpB//8DcUEGSQ0AIABBKUcgAEFYakH//wNxQQdJcQ0AAkAgAEGlf2oOBAEAAAEACyAAQf0ARyAAQYV/akH//wNxQQRJcQ8LQQELLgEBf0EBIQECQCAAQZYJQQUQJA0AIABBoAlBAxAkDQAgAEGmCUECECQhAQsgAQuDAQECf0EBIQECQAJAAkACQAJAAkAgAC8BACICQUVqDgQFBAQBAAsCQCACQZt/ag4EAwQEAgALIAJBKUYNBCACQfkARw0DIABBfmpBsglBBhAkDwsgAEF+ai8BAEE9Rg8LIABBfmpBqglBBBAkDwsgAEF+akG+CUEDECQPC0EAIQELIAEL3gEBBH9BACgCoAohAEEAKAKkCiEBAkACQAJAA0AgACICQQJqIQAgAiABTw0BAkACQAJAIAAvAQAiA0Gkf2oOBQIDAwMBAAsgA0EkRw0CIAIvAQRB+wBHDQJBACACQQRqIgA2AqAKQQBBAC8BiAoiAkEBajsBiApBACgClAogAkEDdGoiAkEENgIAIAIgADYCBA8LQQAgADYCoApBAEEALwGICkF/aiIAOwGICkEAKAKUCiAAQf//A3FBA3RqKAIAQQNHDQMMBAsgAkEEaiEADAALC0EAIAA2AqAKCxAiCwu0AwECf0EAIQECQAJAAkACQAJAAkACQAJAAkACQCAALwEAQZx/ag4UAAECCQkJCQMJCQQFCQkGCQcJCQgJCwJAAkAgAEF+ai8BAEGXf2oOBAAKCgEKCyAAQXxqQboIQQIQJA8LIABBfGpBvghBAxAkDwsCQAJAAkAgAEF+ai8BAEGNf2oOAwABAgoLAkAgAEF8ai8BACICQeEARg0AIAJB7ABHDQogAEF6akHlABAlDwsgAEF6akHjABAlDwsgAEF8akHECEEEECQPCyAAQXxqQcwIQQYQJA8LIABBfmovAQBB7wBHDQYgAEF8ai8BAEHlAEcNBgJAIABBemovAQAiAkHwAEYNACACQeMARw0HIABBeGpB2AhBBhAkDwsgAEF4akHkCEECECQPCyAAQX5qQegIQQQQJA8LQQEhASAAQX5qIgBB6QAQJQ0EIABB8AhBBRAkDwsgAEF+akHkABAlDwsgAEF+akH6CEEHECQPCyAAQX5qQYgJQQQQJA8LAkAgAEF+ai8BACICQe8ARg0AIAJB5QBHDQEgAEF8akHuABAlDwsgAEF8akGQCUEDECQhAQsgAQs0AQF/QQEhAQJAIABBd2pB//8DcUEFSQ0AIABBgAFyQaABRg0AIABBLkcgABAmcSEBCyABCzABAX8CQAJAIABBd2oiAUEXSw0AQQEgAXRBjYCABHENAQsgAEGgAUYNAEEADwtBAQtOAQJ/QQAhAQJAAkAgAC8BACICQeUARg0AIAJB6wBHDQEgAEF+akHoCEEEECQPCyAAQX5qLwEAQfUARw0AIABBfGpBzAhBBhAkIQELIAELcAECfwJAAkADQEEAQQAoAqAKIgBBAmoiATYCoAogAEEAKAKkCk8NAQJAAkACQCABLwEAIgFBpX9qDgIBAgALAkAgAUF2ag4EBAMDBAALIAFBL0cNAgwECxAsGgwBC0EAIABBBGo2AqAKDAALCxAiCws1AQF/QQBBAToA8AlBACgCoAohAEEAQQAoAqQKQQJqNgKgCkEAIABBACgC0AlrQQF1NgKACgtDAQJ/QQEhAQJAIAAvAQAiAkF3akH//wNxQQVJDQAgAkGAAXJBoAFGDQBBACEBIAIQJkUNACACQS5HIAAQKHIPCyABC0YBA39BACEDAkAgACACQQF0IgJrIgRBAmoiAEEAKALQCSIFSQ0AIAAgASACEC0NAAJAIAAgBUcNAEEBDwsgBBAjIQMLIAMLPQECf0EAIQICQEEAKALQCSIDIABLDQAgAC8BACABRw0AAkAgAyAARw0AQQEPCyAAQX5qLwEAEB4hAgsgAgtoAQJ/QQEhAQJAAkAgAEFfaiICQQVLDQBBASACdEExcQ0BCyAAQfj/A3FBKEYNACAAQUZqQf//A3FBBkkNAAJAIABBpX9qIgJBA0sNACACQQFHDQELIABBhX9qQf//A3FBBEkhAQsgAQucAQEDf0EAKAKgCiEBAkADQAJAAkAgAS8BACICQS9HDQACQCABLwECIgFBKkYNACABQS9HDQQQFgwCCyAAEBcMAQsCQAJAIABFDQAgAkF3aiIBQRdLDQFBASABdEGfgIAEcUUNAQwCCyACEB9FDQMMAQsgAkGgAUcNAgtBAEEAKAKgCiIDQQJqIgE2AqAKIANBACgCpApJDQALCyACCzEBAX9BACEBAkAgAC8BAEEuRw0AIABBfmovAQBBLkcNACAAQXxqLwEAQS5GIQELIAELiQQBAX8CQCABQSJGDQAgAUEnRg0AECIPC0EAKAKgCiECIAEQGCAAIAJBAmpBACgCoApBACgCxAkQAUEAQQAoAqAKQQJqNgKgCgJAAkACQAJAQQAQJyIBQeEARg0AIAFB9wBGDQFBACgCoAohAQwCC0EAKAKgCiIBQQJqQbAIQQoQLQ0BQQYhAAwCC0EAKAKgCiIBLwECQekARw0AIAEvAQRB9ABHDQBBBCEAIAEvAQZB6ABGDQELQQAgAUF+ajYCoAoPC0EAIAEgAEEBdGo2AqAKAkBBARAnQfsARg0AQQAgATYCoAoPC0EAKAKgCiICIQADQEEAIABBAmo2AqAKAkACQAJAQQEQJyIAQSJGDQAgAEEnRw0BQScQGEEAQQAoAqAKQQJqNgKgCkEBECchAAwCC0EiEBhBAEEAKAKgCkECajYCoApBARAnIQAMAQsgABAqIQALAkAgAEE6Rg0AQQAgATYCoAoPC0EAQQAoAqAKQQJqNgKgCgJAQQEQJyIAQSJGDQAgAEEnRg0AQQAgATYCoAoPCyAAEBhBAEEAKAKgCkECajYCoAoCQAJAQQEQJyIAQSxGDQAgAEH9AEYNAUEAIAE2AqAKDwtBAEEAKAKgCkECajYCoApBARAnQf0ARg0AQQAoAqAKIQAMAQsLQQAoAuQJIgEgAjYCECABQQAoAqAKQQJqNgIMC20BAn8CQAJAA0ACQCAAQf//A3EiAUF3aiICQRdLDQBBASACdEGfgIAEcQ0CCyABQaABRg0BIAAhAiABECYNAkEAIQJBAEEAKAKgCiIAQQJqNgKgCiAALwECIgANAAwCCwsgACECCyACQf//A3ELqwEBBH8CQAJAQQAoAqAKIgIvAQAiA0HhAEYNACABIQQgACEFDAELQQAgAkEEajYCoApBARAnIQJBACgCoAohBQJAAkAgAkEiRg0AIAJBJ0YNACACECoaQQAoAqAKIQQMAQsgAhAYQQBBACgCoApBAmoiBDYCoAoLQQEQJyEDQQAoAqAKIQILAkAgAiAFRg0AIAUgBEEAIAAgACABRiICG0EAIAEgAhsQAgsgAwtyAQR/QQAoAqAKIQBBACgCpAohAQJAAkADQCAAQQJqIQIgACABTw0BAkACQCACLwEAIgNBpH9qDgIBBAALIAIhACADQXZqDgQCAQECAQsgAEEEaiEADAALC0EAIAI2AqAKECJBAA8LQQAgAjYCoApB3QALSQEDf0EAIQMCQCACRQ0AAkADQCAALQAAIgQgAS0AACIFRw0BIAFBAWohASAAQQFqIQAgAkF/aiICDQAMAgsLIAQgBWshAwsgAwsL4gECAEGACAvEAQAAeABwAG8AcgB0AG0AcABvAHIAdABlAHQAYQByAG8AbQB1AG4AYwB0AGkAbwBuAHMAcwBlAHIAdAB2AG8AeQBpAGUAZABlAGwAZQBjAG8AbgB0AGkAbgBpAG4AcwB0AGEAbgB0AHkAYgByAGUAYQByAGUAdAB1AHIAZABlAGIAdQBnAGcAZQBhAHcAYQBpAHQAaAByAHcAaABpAGwAZQBmAG8AcgBpAGYAYwBhAHQAYwBmAGkAbgBhAGwAbABlAGwAcwAAQcQJCxABAAAAAgAAAAAEAAAwOQAA", "undefined" != typeof Buffer ? Buffer.from(E, "base64") : Uint8Array.from(atob(E), (A3) => A3.charCodeAt(0)))).then(WebAssembly.instantiate).then(({ exports: A3 }) => {
  C = A3;
});
var E;

// node_modules/vite/dist/node/index.js
init_dep_79892de8();
init_constants();
var import_esbuild2 = __toESM(require_main(), 1);
init_rollup();
var import_node_fs3 = require("fs");
var import_node_path6 = require("path");
var import_node_url4 = require("url");
var import_node_perf_hooks4 = require("perf_hooks");
var import_node_module3 = require("module");
var import_node_os2 = require("os");
var import_node_crypto4 = require("crypto");
var import_node_util2 = require("util");
var import_node_dns2 = require("dns");
var import_resolve2 = __toESM(require_resolve(), 1);
var import_node_buffer2 = require("buffer");
var import_promises4 = require("fs/promises");
var import_node_assert2 = require("assert");
var import_node_process4 = require("process");
var import_node_v82 = require("v8");
var import_node_http2 = require("http");
var import_node_https2 = require("https");
var import_node_readline2 = require("readline");
var import_node_child_process2 = require("child_process");
var import_node_zlib2 = require("zlib");

// src/analyze-import.ts
var getImportParams = (importString) => {
  const [name2, alias] = importString.trim().split(" as ");
  return { name: name2, alias };
};
var getImportedNamedExports = (code, startPosition, endPosition) => {
  const a = {
    name: [],
    chunk: ""
  };
  if (code.slice(
    startPosition,
    endPosition
  ).match(/{([\s\S]*?)}/)) {
    const [, importContentString] = code.slice(
      startPosition,
      endPosition
    ).match(/{([\s\S]*?)}/) ?? [];
    a.name = (importContentString?.split(",") ?? []).map((namedExport) => namedExport.trim());
  } else {
    const sliceCode = code.slice(
      startPosition,
      endPosition + 50
    );
    let index = null;
    if (sliceCode.match("default:")) {
      a.chunk = ".";
      index = sliceCode.match("default:").index;
    } else if (sliceCode.match("resolveComponent:")) {
      index = sliceCode.match("resolveComponent:").index;
      a.chunk = ",";
    }
    a.name.push(sliceCode.slice(index).split(".")[1].split("\n")[0]);
  }
  return a;
};
var getImportsMap = async (entryExports, entryPath, imports, resolver) => {
  const map2 = /* @__PURE__ */ new Map([]);
  await Promise.all(
    imports.map(async (importString) => {
      const { name: name2, alias } = methods.getImportParams(importString);
      const namedImport = entryExports.get(name2);
      if (namedImport) {
        const resolvedPath = await resolver(namedImport.path, entryPath);
        if (resolvedPath) {
          const { importDefault: importDefault2, originalName } = namedImport;
          map2.set(resolvedPath, [
            ...map2.get(resolvedPath) ?? [],
            { name: name2, importDefault: importDefault2, originalName, alias }
          ]);
        }
      } else {
        map2.set(entryPath, [
          ...map2.get(entryPath) ?? [],
          { name: name2, importDefault: false }
        ]);
      }
    })
  );
  return map2;
};
var formatImportReplacement = ({
  name: name2,
  alias,
  originalName,
  importDefault: importDefault2
}) => {
  if (importDefault2) {
    return `default as ${alias ?? originalName ?? name2}`;
  }
  if (originalName) {
    return `${originalName}${alias ? ` as ${alias}` : ` as ${name2}`}`;
  }
  return `${name2}${alias ? ` as ${alias}` : ""}`;
};
var getImportReplacement = (imported) => {
  const replacement = [];
  imported.forEach((importedItems, importedPath) => {
    const path4 = normalizePath$3(importedPath);
    const imports = importedItems.map((importedItem) => methods.formatImportReplacement(importedItem));
    replacement.push(`import { ${imports.join(", ")} } from '${path4}'`);
  });
  return replacement;
};
var analyzeImportStatement = async (src2, code, entryExports, entryPath, startPosition, endPosition, resolver) => {
  const { name: name2, chunk } = methods.getImportedNamedExports(code, startPosition, endPosition);
  const imported = await methods.getImportsMap(entryExports, entryPath, name2, resolver);
  const replacement = methods.getImportReplacement(imported);
  const isDefault = checkIsDefaultExport([...imported][0]);
  if (!chunk) {
    src2.overwrite(
      startPosition,
      endPosition + 1,
      `${replacement.join(";\n")};`
    );
  } else {
    if (!isDefault)
      src2.overwrite(startPosition, endPosition + 1, "import(" + replacement[0].split("from")[1] + ")" + chunk);
    else {
      const codeLazy = code.slice(startPosition, endPosition + 200);
      const findCode = codeLazy.indexOf(";");
      src2.overwrite(startPosition, startPosition + findCode, "import(" + replacement[0].split("from")[1] + "))");
    }
  }
};
var checkIsDefaultExport = (key) => {
  return key[1][0].importDefault;
};
var methods = {
  getImportParams,
  getImportedNamedExports,
  getImportsMap,
  getImportReplacement,
  formatImportReplacement,
  analyzeImportStatement
};
var analyze_import_default = methods;

// src/transform.ts
var requiresTransform = (id, options2) => {
  const extension = id.split(".").pop();
  const isIgnored2 = options2.ignorePatterns.some((pattern2) => id.match(pattern2));
  return !isIgnored2 && options2.extensions.includes(extension);
};
var importsTargetEntry = async (id, imports, entries, resolver) => {
  try {
    return await Promise.any(
      imports.map(async (importParams) => {
        const { n: importPath } = importParams;
        const resolvedPath = importPath && await resolver(importPath, id);
        if (!resolvedPath || !entries.has(resolvedPath))
          throw new Error();
        return true;
      })
    );
  } catch (e) {
    return false;
  }
};
async function transformImports(id, code, entries, imports, resolver, logger) {
  await init;
  const src2 = new MagicString(code);
  for (const {
    n: targetPath,
    ss: startPosition,
    se: endPosition
  } of imports) {
    const resolvedImport = targetPath && await resolver(targetPath, id);
    const entry2 = resolvedImport && entries.get(resolvedImport);
    if (entry2) {
      await analyze_import_default.analyzeImportStatement(
        src2,
        code,
        entry2.exports,
        resolvedImport,
        startPosition,
        endPosition,
        resolver
      );
    }
  }
  logger.info(`[MATCHED] ${id}`);
  return src2.toString();
}
async function transformImportsIfNeeded(id, code, entries, resolver, logger) {
  const [imports] = parse(code);
  const importsTarget = await importsTargetEntry(id, imports, entries, resolver);
  if (!importsTarget) {
    logger.info(paint("gray", `[IGNORED BY ANALYZIS] ${id}`));
  } else {
    return await transformImports(
      id,
      code,
      entries,
      imports,
      resolver,
      logger
    );
  }
}
async function transformIfNeeded(id, code, entries, options2, resolver, logger) {
  const isCandidate = requiresTransform(id, options2);
  if (!isCandidate) {
    logger.info(paint("gray", `[IGNORED BY OPTIONS] ${id}`));
  } else {
    return await transformImportsIfNeeded(
      id,
      code,
      entries,
      resolver,
      logger
    );
  }
}

// src/options.ts
var extensions2 = ["js", "jsx", "mjs", "ts", "tsx", "mts"];
var ignorePatterns = [/node_modules/];
var mergeOptions = (userOptions) => ({
  extensions: extensions2,
  ignorePatterns: [...ignorePatterns, ...userOptions.ignorePatterns ?? []],
  debug: false,
  ...userOptions,
  targets: userOptions.targets.map(normalizePath$3)
});

// src/analyze-entry.ts
var import_fs2 = require("fs");
var import_path3 = require("path");

// src/cleanup-entry.ts
var reformatRemainingExports = (content) => content.replace(
  /export {([^}]*)}/mg,
  (_, exports2) => {
    const reformattedExport = exports2.split(",").map((item) => item.trim()).filter((item) => item !== "").join(",");
    return `export { ${reformattedExport} }`;
  }
);
var removeEmptyExports = (content) => content.replace(
  /(export {[^\w}]*}.*;?)/mg,
  ""
);
var removeResolvedExports = (rawEntry, entryMap, exports2) => {
  const output = new MagicString(rawEntry);
  const replace = /* @__PURE__ */ new Set([]);
  exports2.forEach(({
    n: exportedName,
    s: lineStart,
    e: lineEnd
  }) => {
    if (entryMap.has(exportedName)) {
      replace.add([lineStart, lineEnd, ""]);
    }
  });
  replace.forEach(([start, end, replacement]) => {
    output.overwrite(start, end, replacement);
  });
  return output.toString().replace(
    /(\w*\s*as\s*)([,}])/mg,
    "$2"
  );
};
var cleanupEntry = (rawEntry, entryMap, exports2) => methods2.reformatRemainingExports(
  methods2.removeEmptyExports(
    methods2.removeResolvedExports(
      rawEntry,
      entryMap,
      exports2
    )
  )
);
var methods2 = {
  removeResolvedExports,
  removeEmptyExports,
  reformatRemainingExports,
  cleanupEntry
};
var cleanup_entry_default = methods2;

// src/analyze-entry.ts
var parseImportStatement = (statement) => {
  const output = { namedImports: [], defaultImport: null };
  let [, , importContent] = statement.match(/(im|ex)port (.*) from/) ?? [, , void 0];
  if (importContent) {
    const [namedImportsStatement, namedImportsContent] = importContent.match(/{(.*)}/) ?? [, void 0];
    if (namedImportsStatement && namedImportsContent) {
      importContent = importContent.replace(namedImportsStatement, "");
      namedImportsContent.split(",").forEach((namedImport) => {
        const name2 = namedImport.split(" as ").map((param) => param.trim());
        if (name2.length === 1) {
          output.namedImports.push(name2[0]);
        } else {
          const [originalName, alias] = name2;
          if (originalName === "default") {
            output.defaultImport = alias;
          } else {
            output.namedImports.push(namedImport.trim());
          }
        }
      });
    }
    const defaultImport = importContent.replace(/,/g, "").trim();
    output.defaultImport = defaultImport.length ? defaultImport : output.defaultImport;
  }
  return output;
};
var analyzeEntryImport = (rawEntry, analyzedImports, path4, startPosition, endPosition) => {
  const statement = rawEntry.slice(
    startPosition,
    endPosition
  );
  const { namedImports, defaultImport } = methods3.parseImportStatement(statement);
  if (defaultImport) {
    analyzedImports.set(defaultImport, { path: path4, importDefault: true });
  }
  if (namedImports.length) {
    namedImports.forEach((namedImport) => {
      const { name: name2, alias } = analyze_import_default.getImportParams(namedImport);
      analyzedImports.set(alias ?? name2, {
        path: path4,
        importDefault: false,
        originalName: name2
      });
    });
  }
};
var analyzeEntryExport = (entryMap, analyzedImports, namedExport) => {
  if (namedExport && analyzedImports.has(namedExport)) {
    const { path: path4, importDefault: importDefault2, originalName } = analyzedImports.get(namedExport);
    entryMap.set(namedExport, { path: path4, importDefault: importDefault2, originalName });
  }
};
var doAnalyzeEntry = async (entries, entryPath) => {
  await init;
  const entryMap = /* @__PURE__ */ new Map([]);
  const analyzedImports = /* @__PURE__ */ new Map([]);
  const rawEntry = (0, import_fs2.readFileSync)((0, import_path3.resolve)(entryPath), "utf-8");
  const [imports, exports2] = parse(rawEntry);
  imports.forEach(({
    n: path4,
    ss: startPosition,
    se: endPosition
  }) => {
    methods3.analyzeEntryImport(
      rawEntry,
      analyzedImports,
      path4,
      startPosition,
      endPosition
    );
  });
  exports2.forEach(({ n: namedExport }) => {
    methods3.analyzeEntryExport(
      entryMap,
      analyzedImports,
      namedExport
    );
  });
  entries.set(entryPath, {
    exports: entryMap,
    updatedSource: cleanup_entry_default.cleanupEntry(
      rawEntry,
      entryMap,
      exports2
    )
  });
};
var analyzeEntry = async (entries, entryPath) => {
  if (entries.has(entryPath))
    return;
  await methods3.doAnalyzeEntry(
    entries,
    entryPath
  );
};
var analyzeEntries = async (targets, resolver) => {
  const entries = /* @__PURE__ */ new Map([]);
  await Promise.all(
    targets.map(async (path4) => {
      const absolutePath = await resolver(path4) ?? path4;
      await methods3.analyzeEntry(entries, absolutePath);
    })
  );
  return entries;
};
var methods3 = {
  parseImportStatement,
  analyzeEntryImport,
  analyzeEntryExport,
  doAnalyzeEntry,
  analyzeEntry,
  analyzeEntries
};
var analyze_entry_default = methods3;

// src/index.ts
async function createEntryShakingPlugin(userOptions) {
  const options2 = mergeOptions(userOptions);
  let logger;
  let resolver;
  let entries;
  return {
    name: "vite-plugin-entry-shaking-lazy-load",
    enforce: "post",
    async configResolved({ logger: loggerConfig, createResolver }) {
      logger = configureLogger(loggerConfig, options2.debug);
      resolver = createResolver();
      entries = await analyze_entry_default.analyzeEntries(options2.targets, resolver);
      logger.info(`List of merged options: ${JSON.stringify(options2)}`);
      logger.info(`List of parsed entries: ${JSON.stringify([...entries.keys()])}`);
    },
    async handleHotUpdate({ file }) {
      if (entries.has(file)) {
        await analyze_entry_default.doAnalyzeEntry(entries, file);
      }
    },
    async transform(code, id) {
      return await transformIfNeeded(
        id,
        code,
        entries,
        options2,
        resolver,
        logger
      );
    },
    load(id) {
      if (entries.has(id)) {
        logger.info(`Serving mutated entry file ${id}`);
        return entries.get(id).updatedSource;
      }
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*! Bundled license information:

rollup/dist/es/shared/node-entry.js:
  (*
    @license
  	Rollup.js v3.20.2
  	Fri, 24 Mar 2023 06:17:57 GMT - commit 1517d0360d66893d5cacdbaf7bc9d841c1c38069
  
  	https://github.com/rollup/rollup
  
  	Released under the MIT License.
  *)

rollup/dist/es/rollup.js:
  (*
    @license
  	Rollup.js v3.20.2
  	Fri, 24 Mar 2023 06:17:57 GMT - commit 1517d0360d66893d5cacdbaf7bc9d841c1c38069
  
  	https://github.com/rollup/rollup
  
  	Released under the MIT License.
  *)

vite/dist/node/chunks/dep-79892de8.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (**
   * Autoload Config for PostCSS
   *
   * @author Michael Ciniawsky @michael-ciniawsky <michael.ciniawsky@gmail.com>
   * @license MIT
   *
   * @module postcss-load-config
   * @version 2.1.0
   *
   * @requires comsiconfig
   * @requires ./options
   * @requires ./plugins
   *)
  (*!
   * etag
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * encodeurl
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   *)
  (*!
   * ee-first
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   *)
  (*!
   * on-finished
   * Copyright(c) 2013 Jonathan Ong
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * parseurl
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * unpipe
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * finalhandler
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * connect
   * Copyright(c) 2010 Sencha Inc.
   * Copyright(c) 2011 TJ Holowaychuk
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
  (*!
   * vary
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)
  (*!
   * Array of passes.
   *
   * A `pass` is just a function that is executed on `req, res, options`
   * so that you can easily add new checks while still keeping the base
   * flexible.
   *)
  (*!
   * Array of passes.
   *
   * A `pass` is just a function that is executed on `req, socket, options`
   * so that you can easily add new checks while still keeping the base
   * flexible.
   *)
  (*!
   * Caron dimonio, con occhi di bragia
   * loro accennando, tutte le raccoglie;
   * batte col remo qualunque sadagia 
   *
   * Charon the demon, with the eyes of glede,
   * Beckoning to them, collects them all together,
   * Beats with his oar whoever lags behind
   *          
   *          Dante - The Divine Comedy (Canto III)
   *)
*/
